코딩 필기



=== 201903026_01_sys.sql ===

--1줄 주석문 처리(단일행 주석문 처리)

/*
여러줄
(다중 행)
주서문
처리
*/

--○ 현재 오라클 서버에 접속한 자신의 계정 조회
show user;
--==>> USER이(가) "SYS"입니다.
--> sqlplus 상태일 때 사용하는 명령어


SELECT USER
FROM DUAL;
--==>> 

SELECT 1+2
FROM DUAL;
--==>> 3

SELECT 1 + 2
FROM DUAL;
--==>> 3

SELECT '쌍용강북F강의장'
FROM DUAL;
--==>> 쌍용강북F강의장


SELECT '아직은 지루한 오라클 수업';
--==>>
/*
ORA-00923: FROM keyword not found where expected
00923. 00000 -  "FROM keyword not found where expected"
*Cause:    
*Action:
34행, 23열에서 오류 발생
*/

SELECT '아직은 지루한 오라클 수업'
FROM DUAL;
--==>> 아직은 지루한 오라클 수업

SELECT 3.14 + 1.36
FROM DUAL;
--==>> 4.5

SELECT 1.234 + 2.345
FROM DUAL;
--==>> 3.579

SELECT 10 * 5
FROM DUAL;
--==>> 50

SELECT 1000/3
FROM DUAL;
--==>> 333.333333333333333333333333333333333333

SELECT 100-23
FROM DUAL;
--==>> 77

SELECT "테스트"
FROM DUAL;
--==>>
/*
ORA-00904: "테스트": invalid identifier
00904. 00000 -  "%s: invalid identifier"
*Cause:    
*Action:
68행, 8열에서 오류 발생
*/

SELECT '김정규' + '윤희진'
FROM DUAL;
--==>> 
/*
ORA-01722: invalid number
01722. 00000 -  "invalid number"
*Cause:    The specified number was invalid.
*Action:   Specify a valid number.
*/

 
 --○ 현재 오라클 서버에 존재하는 사용자 계정 상태 정보 조회
 
 SELECT *
 FROM DBA_USERS;
 --==>>
 /*
SYS	0		OPEN		19/09/21	SYSTEM	TEMP	14/05/29	DEFAULT	SYS_GROUP		10G 11G 	N	PASSWORD
SYSTEM	5		OPEN		19/09/21	SYSTEM	TEMP	14/05/29	DEFAULT	SYS_GROUP		10G 11G 	N	PASSWORD
ANONYMOUS	35		OPEN		14/11/25	SYSAUX	TEMP	14/05/29	DEFAULT	DEFAULT_CONSUMER_GROUP			N	PASSWORD
HR	43		OPEN		19/09/21	USERS	TEMP	14/05/29	DEFAULT	DEFAULT_CONSUMER_GROUP		10G 11G 	N	PASSWORD
APEX_PUBLIC_USER	45		LOCKED	14/05/29	14/11/25	SYSTEM	TEMP	14/05/29	DEFAULT	DEFAULT_CONSUMER_GROUP		10G 11G 	N	PASSWORD
FLOWS_FILES	44		LOCKED	14/05/29	14/11/25	SYSAUX	TEMP	14/05/29	DEFAULT	DEFAULT_CONSUMER_GROUP		10G 11G 	N	PASSWORD
APEX_040000	47		LOCKED	14/05/29	14/11/25	SYSAUX	TEMP	14/05/29	DEFAULT	DEFAULT_CONSUMER_GROUP		10G 11G 	N	PASSWORD
OUTLN	9		EXPIRED & LOCKED	19/03/25	19/03/25	SYSTEM	TEMP	14/05/29	DEFAULT	DEFAULT_CONSUMER_GROUP		10G 11G 	N	PASSWORD
DIP	14		EXPIRED & LOCKED	14/05/29	14/05/29	SYSTEM	TEMP	14/05/29	DEFAULT	DEFAULT_CONSUMER_GROUP		10G 11G 	N	PASSWORD
ORACLE_OCM	21		EXPIRED & LOCKED	14/05/29	14/05/29	SYSTEM	TEMP	14/05/29	DEFAULT	DEFAULT_CONSUMER_GROUP		10G 11G 	N	PASSWORD
XS$NULL	2147483638		EXPIRED & LOCKED	14/05/29	14/05/29	SYSTEM	TEMP	14/05/29	DEFAULT	DEFAULT_CONSUMER_GROUP		10G 11G 	N	PASSWORD
MDSYS	42		EXPIRED & LOCKED	14/05/29	19/03/25	SYSAUX	TEMP	14/05/29	DEFAULT	DEFAULT_CONSUMER_GROUP		10G 11G 	N	PASSWORD
CTXSYS	32		EXPIRED & LOCKED	19/03/25	19/03/25	SYSAUX	TEMP	14/05/29	DEFAULT	DEFAULT_CONSUMER_GROUP		10G 11G 	N	PASSWORD
DBSNMP	29		EXPIRED & LOCKED	14/05/29	14/05/29	SYSAUX	TEMP	14/05/29	DEFAULT	DEFAULT_CONSUMER_GROUP		10G 11G 	N	PASSWORD
XDB	34		EXPIRED & LOCKED	14/05/29	14/05/29	SYSAUX	TEMP	14/05/29	DEFAULT	DEFAULT_CONSUMER_GROUP		10G 11G 	N	PASSWORD
APPQOSSYS	30		EXPIRED & LOCKED	14/05/29	14/05/29	SYSAUX	TEMP	14/05/29	DEFAULT	DEFAULT_CONSUMER_GROUP		10G 11G 	N	PASSWORD
 */
 
 --> 『DBA_』로 시작하는 Oracle Data Dictionary View 는
 --  오로지 관리자 권한으로 접속했을 경우에만 조회가 가능하다.
 --  아직은 데이터 딕셔너리 개념을 잡지 못해도 상관없다.
 
 --○ 『HR』 사용자 계정을 잠금 상태로 설정
 ALTER USER HR ACCOUNT LOCK;
 --==>> User HR이(가) 변경되었습니다.
 
--○ 다시 사용자 계정 정보 조회
SELECT USERNAME, ACCOUNT_STATUS
FROM DBA_USERS;
--==>>
/*
    :
HR	LOCKED
    :
*/

--○ 『HR』 사용자 계정 잠금 해체
ALTER USER HR ACCOUNT UNLOCK;
--==>> User HR이(가) 변경되었습니다
 
--○ 다시 사용자 계정 정보 조회
SELECT USERNAME, ACCOUNT_STATUS
FROM DBA_USERS; 
--==>>
/*
    :
HR	OPEN
    :
*/
 
---------------------------------------------------------------------------

--○ TABLESPACE 생성

--※ TABLESPACE 란?
--   세그먼트(테이블, 인덱스, ...)를 담아두는(저장해두는)
--   오라클의 논리적인 저장 구조를 의미한다.

CREATE TABLESPACE TBS_EDUA                      -- CREATE 유형 개체명 → 생성 
DATAFILE 'C:\TESTORADATA\TBS_EDUA01.DBF'        -- 물리적으로 연결되는 데이터 파일
SIZE 4M                                         -- 물리적 데이터 파일의 용량
EXTENT MANAGEMENT LOCAL                         -- 오라클 서버가 세그먼트를 알아서 관리
SEGMENT SPACE MANAGEMENT AUTO;                  -- 세그먼트 공간 관리도 사동으로 오라클 서버가
--==>> TABLESPACE TBS_EDUA이(가) 생성되었습니다.

--※ 테이블스페이스 생성 구문을 실행하기 전에
--   물리적인 경로에 디렉터리(TESTORADATA) 생성할 것.

--○ 생성된 테이블 스페이스(TBS_EDUA) 조회
SELECT *
FROM DBA_TABLESPACES;
/*
    :
TBS_EDUA	8192	65536		1	2147483645	2147483645		65536	ONLINE	PERMANENT	LOGGING	NO	LOCAL	SYSTEM	NO	AUTO	DISABLED	NOT APPLY	NO	HOST	NO	
    :
*/


--○ 물리적인 파일 이름 조회
SELECT *
FROM DBA_DATA_FILES;
--==>>
/*
    :
C:\TESTORADATA\TBS_EDUA01.DBF	5	TBS_EDUA	4194304	512	AVAILABLE	5	NO	0	0	0	3145728	384	ONLINE
    :
*/


--○ 오라클 사용자 계정 생성
CREATE USER yhj IDENTIFIED BY java006$
DEFAULT TABLESPACE TBS_EDUA;
--> yhj 라는 사용자 계정을 만들겠다. (생성하겠다.)
--  이 계정을 통해 생성하는 오라클 객체는(세크먼트들은)
--  기본적으로 TBS_EDUA 라는 테이블스페이스에 생성할 수 있도록 설정하겠다.
--==>> User YHJ이(가) 생성되었습니다.


--※ 생성된 오라클 사용자 계정(yhj)을 통해
--   접속을 시도해 보았으나 접속 불가.
--   → 『create session』 권한이 없기 때문
 

--○ 생성된 오라클 사용자 계정(yhj)에
--   서버 접속이 가능할 수 있도록 create session 권한 부여 → sys 가
GRANT CREATE SESSION TO YHJ;
--==>> Grant을(를) 성공했습니다.


--○ 생성된 오라클 사용자 계정(YHJ)의
--   DEFAULT TABLESPACE 조회
SELECT USERNAME, DEFAULT_TABLESPACE
FROM DBA_USERS;
--==>>
/*
        :
HR	                USERS
YHJ	                TBS_EDUA
        :
*/


--○ 생성된 오라클 사용자 계정(YHJ)의
--   시스템 관련 권한 조회
SELECT *
FROM DBA_SYS_PRIVS;
--==>>
/*
    :
YHJ	CREATE SESSION	NO
    :
*/


--○ 생성된 오라클 사용자 계정(YHJ)에
--   테이블 생성이 가능할 수 있도록 CREATE TABLE 권한 부여
GRANT CREATE TABLE TO YHJ;
--==>> Grant을(를) 성공했습니다.


--○ 생성된 오라클 사용자 계정(YHJ)에
--   테이블스페이스(TBS_EDUA)에서 사용할 수 있는 공간(할당량)
--   의 크기를 무제한으로 지정.
ALTER USER YHJ
QUOTA UNLIMITED ON TBS_EDUA;
--==>> User YHJ이(가) 변경되었습니다.



=== 20190326_02_yhj.sql ===

--○ 접속된 사용자 확인
SELECT USER
FROM DUAL;
--==>> YHJ


--○ 테이블 생성(테이블 명 : TBL_ORAUSERTEST)
CREATE TABLE TBL_ORAUSERTEST
( NO    NUMBER(10)
, NAME  VARCHAR(30)
);
--==>> 에러 발생
/*
ORA-01031: insufficient privileges
01031. 00000 -  "insufficient privileges"
*Cause:    An attempt was made to perform a database operation without
           the necessary privileges.
*Action:   Ask your database administrator or designated security
           administrator to grant you the necessary privileges
*/
--> 현재 YHJ 계정은 CREATE SESSION 권한만 갖고 있으며
--  테이블을 생성할 수 있는 권한은 갖고 있지 않은 상태이다.
--  그러므로 관리자로부터 테이블 생성 권한을 부여받아야 한다.


--○ SYS로 부터 CREATE TABLE 권한을 부여받은 이후
--   테이블 생성(테이블 명 : TBL_ORAUSERTEST)
CREATE TABLE TBL_ORAUSERTEST
( NO    NUMBER(10)
, NAME  VARCHAR(30)
);
--==>> 에러 발생
/*
ORA-01950: no privileges on tablespace 'TBS_EDUA'
01950. 00000 -  "no privileges on tablespace '%s'"
*Cause:    User does not have privileges to allocate an extent in the
           specified tablespace.
*Action:   Grant the user the appropriate system privileges or grant the user
           space resource on the tablespace.
*/
--> 테이블 생성 권한까지 부여받은 상황이지만
--  YHJ 사용자 계정은 기본 테이블스페이스(DEFAULT TABLESPACE)는
--  『TBS_EDUA』이며, 이 공간에 대한 할당량을 부여받지 못한 상태.
--  그러므로 이 테이블스페이스를 사용할 권한이 없다는 에러메시지를
--  오라클이 출력해주고 있는 상황.


--○ SYS로 부터 테이블스페이스(TBS_EDUA)에 대한 할당량을 부여받은 이후
--   테이블 생성(테이블 명 : TBL_ORAUSERTEST)
CREATE TABLE TBL_ORAUSERTEST
( NO    NUMBER(10)
, NAME  VARCHAR(30)
);
--==>> Table TBL_ORAUSERTEST이(가) 생성되었습니다.


--※ 자신에게 부여되어진 할당량 조회
SELECT *
FROM USER_TS_QUOTAS;
--==>> TBS_EDUA	65536	-1	8	-1	NO


--○ 생성된 테이블(TBL_ORAUSERTEST)이
--   어떤 테이블스페이스에 저장되어 있는지 조회
SELECT TABLE_NAME, TABLESPACE_NAME
FROM USER_TABLES;
--==>> TBL_ORAUSERTEST	TBS_EDUA



=== 20190326_03_hr.sql ===

--○ 현재 접속된 오라클 사용자 조회
SELECT USER
FROM DUAL;
--==>> HR



=== 20190326_04_sys.sql ===

--○ 접속된 사용자 조회
SELECT USER
FROM DUAL;
--==>> SYS


--○ 오라클 사용자 계정 생성(SCOTT)
CREATE USER SCOTT
IDENTIFIED BY tiger;
--==>> User SCOTT이(가) 생성되었습니다.


--○ 생성된 오라클 사용자(SCOTT)에게 권한 부여
GRANT CONNECT,RESOURCE,UNLIMITED TABLESPACE TO SCOTT;
--==>> Grant을(를) 성공했습니다.


--○ 생성된 오라클 사용자(SCOTT)에게 기본 테이블 스페이스 설정
ALTER USER SCOTT DEFAULT TABLESPACE USERS;
--==>> User SCOTT이(가) 변경되었습니다.


--○ 생성된 오라클 사용자(SCOTT)에게 임시 테이블스페이스 설정
ALTER USER SCOTT TEMPORARY TABLESPACE TEMP;
--==>> User SCOTT이(가) 변경되었습니다.



=== 20190326_05_scott.sql ===

--○ 접속된 사용자 계정 조회
SELECT USER
FROM DUAL;
--==>> SCOTT


--○ 테이블 생성(DEPT)
CREATE TABLE DEPT
(DEPTNO NUMBER(2) CONSTRAINT PK_DEPT PRIMARY KEY
, DNAME VARCHAR2(14) 
, LOC VARCHAR2(13) 
);
--==>> Table DEPT이(가) 생성되었습니다.


--○ 테이블 생성(EMP)
CREATE TABLE EMP
(EMPNO NUMBER(4) CONSTRAINT PK_EMP PRIMARY KEY
, ENAME VARCHAR2(10)
, JOB VARCHAR2(9)
, MGR NUMBER(4)
, HIREDATE DATE
, SAL NUMBER(7,2)
, COMM NUMBER(7,2)
, DEPTNO NUMBER(2) CONSTRAINT FK_DEPTNO REFERENCES DEPT
);
--==>> Table EMP이(가) 생성되었습니다.


--○ 데이터 입력(DEPT)
INSERT INTO DEPT VALUES	(10, 'ACCOUNTING', 'NEW YORK');
INSERT INTO DEPT VALUES (20, 'RESEARCH', 'DALLAS');
INSERT INTO DEPT VALUES	(30, 'SALES', 'CHICAGO');
INSERT INTO DEPT VALUES	(40, 'OPERATIONS', 'BOSTON');
--==>> 1 행 이(가) 삽입되었습니다. * 4


--○ 데이터 입력(EMP)
INSERT INTO EMP VALUES
(7369, 'SMITH', 'CLERK', 7902, to_date('17-12-1980','dd-mm-yyyy'), 800,NULL,20);
INSERT INTO EMP VALUES
(7499, 'ALLEN', 'SALESMAN', 7698, to_date('20-2-1981','dd-mm-yyyy'), 1600, 300, 30);
INSERT INTO EMP VALUES
(7521, 'WARD', 'SALESMAN', 7698, to_date('22-2-1981','dd-mm-yyyy'), 1250, 500, 30);
INSERT INTO EMP VALUES
(7566, 'JONES', 'MANAGER', 7839, to_date('2-4-1981','dd-mm-yyyy'), 2975, NULL, 20);
INSERT INTO EMP VALUES
(7654, 'MARTIN', 'SALESMAN', 7698, to_date('28-9-1981','dd-mm-yyyy'), 1250, 1400, 30);
INSERT INTO EMP VALUES
(7698, 'BLAKE', 'MANAGER', 7839, to_date('1-5-1981','dd-mm-yyyy'), 2850, NULL, 30);
INSERT INTO EMP VALUES
(7782, 'CLARK', 'MANAGER', 7839, to_date('9-6-1981','dd-mm-yyyy'), 2450, NULL, 10);
INSERT INTO EMP VALUES
(7788, 'SCOTT', 'ANALYST', 7566, to_date('13-7-1987','dd-mm-yyyy'), 3000, NULL, 20);
INSERT INTO EMP VALUES
(7839, 'KING', 'PRESIDENT', NULL, to_date('17-11-1981','dd-mm-yyyy'), 5000, NULL, 10);
INSERT INTO EMP VALUES
(7844, 'TURNER', 'SALESMAN', 7698, to_date('8-9-1981','dd-mm-yyyy'), 1500, 0, 30);
INSERT INTO EMP VALUES
(7876, 'ADAMS', 'CLERK', 7788, to_date('13-7-1987','dd-mm-yyyy'), 1100, NULL, 20);
INSERT INTO EMP VALUES
(7900, 'JAMES', 'CLERK', 7698, to_date('3-12-1981','dd-mm-yyyy'), 950, NULL, 30);
INSERT INTO EMP VALUES
(7902, 'FORD', 'ANALYST', 7566, to_date('3-12-1981','dd-mm-yyyy'), 3000, NULL, 20);
INSERT INTO EMP VALUES
(7934, 'MILLER', 'CLERK', 7782, to_date('23-1-1982','dd-mm-yyyy'), 1300, NULL, 10);
--==>> 1 행 이(가) 삽입되었습니다. * 14


--○ 테이블 생성(BONUS)
CREATE TABLE BONUS
( ENAME VARCHAR2(10)	
, JOB VARCHAR2(9)   
, SAL NUMBER
, COMM NUMBER
);
--==>> Table BONUS이(가) 생성되었습니다.


--○ 테이블 생성(SALGRADE)
CREATE TABLE SALGRADE
( GRADE NUMBER
, LOSAL NUMBER
, HISAL NUMBER 
);
--==>> Table SALGRADE이(가) 생성되었습니다.


--○ 데이터 입력(SALGRADE)
INSERT INTO SALGRADE VALUES (1,700,1200);
INSERT INTO SALGRADE VALUES (2,1201,1400);
INSERT INTO SALGRADE VALUES (3,1401,2000);
INSERT INTO SALGRADE VALUES (4,2001,3000);
INSERT INTO SALGRADE VALUES (5,3001,9999);
--==>> 1 행 이(가) 삽입되었습니다. * 5


--○ 커밋
COMMIT;
--==>> 커밋 완료.


--○ 현재 SCOTT 오라클 계정 사용자가 소유하고 있는 테이블 조회
SELECT *
FROM TAB;
--==>>
/*
BONUS	    TABLE	
DEPT	    TABLE	
EMP	        TABLE	
SALGRADE	TABLE	
*/


--○ 어떤 테이블스페이스에 저장되어 있는지 조회
SELECT TABLE_NAME, TABLESPACE_NAME
FROM USER_TABLES;
--==>>
/*
DEPT	    USERS
EMP	        USERS
BONUS	    USERS
SALGRADE	USERS
*/


--○ 테이블 생성(TBL_EXAMPLE1)
CREATE TABLE TBL_EXAMPLE1
( NO    NUMBER
, NAME  VARCHAR(10)
, ADDR  VARCHAR(20)
);
--==>> Table TBL_EXAMPLE1이(가) 생성되었습니다.


--○ 테이블 생성(TBL_EXAMPLE2)
CREATE TABLE TBL_EXAMPLE2
( NO    NUMBER
, NAME  VARCHAR(10)
, ADDR  VARCHAR(20)
)TABLESPACE TBS_EDUA;
--==>> Table TBL_EXAMPLE2이(가) 생성되었습니다.


--○ TBL_EXAMPLE1 과 TBL_EXAMPLE2 테이블이
--   어떤 테이블스페이스에 저장되어 있는지 조회
SELECT TABLE_NAME, TABLESPACE_NAME
FROM USER_TABLES;
--==>>
/*
DEPT	        USERS
EMP	            USERS
BONUS	        USERS
SALGRADE	    USERS
TBL_EXAMPLE1	USERS
TBL_EXAMPLE2	TBS_EDUA
*/


------------------------------------------------------------------------------------------------------------------------

--■■■ 관계형 데이터 베이스 ■■■--

-- 데이터를 테이블의 형태로 저장시켜 놓은 것
-- 그리고 이들 각 테이블들 간의 관계를 설정하는 것

/*=============================================
  ★★★ SELECT 문의 처리(PARSING) 순서 ★★★
  
  SELECT 컬럼명     -- ⑤
  FROM 테이블명     -- ①
  WHERE 조건절      -- ②
  GROUP BY 절       -- ③
  HAVING 조건절     -- ④
  ORDER BY 절       -- ⑥
  
=============================================*/


--○ 현재 접속된 오라클 사용자(SCOTT) 소유의
--   테이블(TABEL), 뷰(VIEW)의 목록을 조회
SELECT *
FROM TAB;
--==>>
/*
BONUS	        TABLE	→ 보너스 정보 테이블
DEPT	        TABLE	→ DEPARTMENTS(부서) 정보 테이블
EMP	            TABLE	→ EMPLOYEES(사원) 정보 테이블
SALGRADE	    TABLE	→ 급여(SAL)의 등급 정보 테이블
TBL_EXAMPLE1	TABLE	
TBL_EXAMPLE2	TABLE	
*/


--○ 각 테이블 데이터 조회
SELECT *
FROM BONUS;
--==>> 데이터 조회하지 않음

SELECT *
FROM DEPT;
--==>>
/*
10	ACCOUNTING	NEW YORK
20	RESEARCH	DALLAS
30	SALES	    CHICAGO
40	OPERATIONS	BOSTON
*/

SELECT *
FROM EMP;
--==>>
/*
7369	SMITH	CLERK	    7902	80/12/17	800		        20
7499	ALLEN	SALESMAN	7698	81/02/20	1600	300	    30
7521	WARD	SALESMAN	7698	81/02/22	1250	500	    30
7566	JONES	MANAGER 	7839	81/04/02	2975		    20
7654	MARTIN	SALESMAN	7698	81/09/28	1250	1400	30
7698	BLAKE	MANAGER	    7839	81/05/01	2850		    30
7782	CLARK	MANAGER	    7839	81/06/09	2450		    10
7788	SCOTT	ANALYST	    7566	87/07/13	3000		    20
7839	KING	PRESIDENT		    81/11/17	5000		    10
7844	TURNER	SALESMAN	7698	81/09/08	1500	0	    30
7876	ADAMS	CLERK	    7788	87/07/13	1100		    20
7900	JAMES	CLERK	    7698	81/12/03	950		        30
7902	FORD	ANALYST	    7566	81/12/03	3000		    20
7934	MILLER	CLERK	    7782	82/01/23	1300		    10
*/

SELECT *
FROM SALGRADE;
--==>>
/*
1	700	    1200
2	1201	1400
3	1401	2000
4	2001	3000
5	3001	9999
*/


--○ DEPT 테이블에 존재하는 컬럼의 정부(구조) 조회
DESCRIBE DEPT;
--==>>
/*
이름     널?       유형           
------ -------- ------------ 
DEPTNO NOT NULL NUMBER(2)    
DNAME           VARCHAR2(14) 
LOC             VARCHAR2(13) 
*/

--※ 우리가 흔히 웹 사이트에서 회원가입을 수행할 경우
--   필수 입력 사항과 선택 입력 사항이 있다.
--   필수 입력 항목은 ID, PW, 성명, 주민번호, 전화번호, 주소, ...
--   등과 같은 컬럼이며, 이 값들은 회원 가입 절차에 따라
--   반드시 필요한(존재해야 하는) 값이므로 NOT NULL 로 한다.

--  선택 입력 항목은 취미, 결혼여부, 차량소유여부, 특기, ...
--  등과 같은 컬럼이며, 이 값들은 회원 가입 과정에서
--  반드시 필요한 값이 아니므로(즉, 입력하지 않아도 무방하므로)
--  NULL 이어도 상관 없는 상황이 된다.


--  DEPTNO      DNAME      LOC
--  부서번호    부서명     부서위치
--  NOT NULL    NULL 허용  NULL 허용

-- EX)          인사부     서울      → 데이터 입력 불가
--      80                 인천      → 데이터 입력 가능
--      90                           → 데이터 입력 가능


--■■■ 오라클의 주요 자료형(DATA TYPE) ■■■--
/*
cf) MSSQL 서버의 정수 표현 타입
    tinyint     0 ~ 255             1Byte
    smallint    -32.768 ~ 32767     2Byte
    int         -21억 ~ 21억        4Byte
    bigint      엄청큼              8Byte
    
    MSSQL 서버의 실수 표현 타입
    float, real
    
    MSSQL 서버의 숫자 표현 타입
    decimal, numeric
    
    MSSQL 서버의 문자 표현 타입
    char, varchar, Nvarchar
*/

--※ ORACLE 서버는 숫자 표현 타입이 한 가지로 통일되어 있다.
/*
1. 숫자형 NUMBER        → -10의 38승-1 ~ 10의 38승
          NUMBER(3)     → -999 ~ 999
          NUMBER(4)     → -9999 ~ 9999
          NUMBER(4,1)   → -999.9 ~ 999.9
*/

--※ ORACLE 서버의 문자 표현 타입
--   CHAR, VARCHAR2, NVARCHAR2
/*
2. 문자형  CHAR
           CHAR(10)  → 무조건 10BYTE 소모
           CHAR(10)  ← '강의실'        6Byte 이지만 10Byte 를 소모
           CHAR(10)  ← '잠깬조현우'    10Byte
           CHAR(10)  ← 'Oh잠깬조현우'  10Byte 를 초과하므로 입력 불가
           
           VARCHAR2     → 가변형 크기
           VARCHAR2(10) ← '강의실'         6Byte 소모
           VARCHAR2(10) ← '잠깬조현우'     10Byte
           VARCHAR2(10) ← 'Oh잠깬조현우'   10Byte 를 초과하므로 입력 불가 
           
           NCHAR        - 유니코드 기반 고정형 크리(글자수)
           NCAHT(10)    - 10글자
           NVARCHAR2    - 유니코드 기반 가변형 크기(글자수)
           NVARCHAR2    - 10글자
           
3. 날짜형 DATE

*/

SELECT SYSDATE
FROM DUAL;
--==>> 19/03/26

--※ 날짜 형식에 대한 세션 설정 변경
ALTER SESSION SET NLS_DATE_FORMAT = 'YYYY-MM-DD HH24:MI:SS';
--==>> Session이(가) 변경되었습니다.


SELECT SYSDATE
FROM DUAL;
--==>> 2019-03-26 16:48:52


--○ EMP 테이블에서 사원번호, 사원명, 급여, 커미션 정보만 조회
SELECT EMPNO, ENAME, SAL, COMM
FROM EMP;
--==>>
/*
7369	SMITH	800	
7499	ALLEN	1600	300
7521	WARD	1250	500
7566	JONES	2975	
7654	MARTIN	1250	1400
7698	BLAKE	2850	
7782	CLARK	2450	
7788	SCOTT	3000	
7839	KING	5000	
7844	TURNER	1500	0
7876	ADAMS	1100	
7900	JAMES	950	
7902	FORD	3000	
7934	MILLER	1300	
*/


--○ EMP 테이블에서 부서본호가 20번인 직원들의 정보 중
--   사원번호, 사원명, 직종명, 급여 , 부서번호 조회
SELECT EMPNO, ENAME, JOB, SAL, DEPTNO
FROM EMP 
WHERE DEPTNO = 20;
--==>>
/*
7369	SMITH	CLERK	800	    20
7566	JONES	MANAGER	2975	20
7788	SCOTT	ANALYST	3000	20
7876	ADAMS	CLERK	1100	20
7902	FORD	ANALYST	3000	20
*/

--※ 테이블을 조회하는 과정에서 각 컬럼에 별칭(ALIAS)을 부여할 수 있다.

SELECT EMPNO AS "사원번호", ENAME "사원명", JOB 직종명, SAL AS "급 여", DEPTNO"부서번호"
FROM EMP 
WHERE DEPTNO = 20;
--==>>
/*
7369	SMITH	CLERK	800	    20
7566	JONES	MANAGER	2975	20
7788	SCOTT	ANALYST	3000	20
7876	ADAMS	CLERK	1100	20
7902	FORD	ANALYST	3000	20
*/


--※ 테이블 조회시 사용하는 별칭의 기본 구문은 『AS "별칭명"』의 형태로 작성되며
--   이 때 『AS』는 생략 가능하다.
--   또한, 『""』도 생략 가능하다.
--   하지만, 『""』를 생략할 경우 별칭명에 공백은 사용할 수 없다.
--   공백은 해당 컬럼의 종결을 의미하므로 별칭의 이름 내부에 공백을 사용할 경우
--   『""』를 사용하여 별칭을 부여할 수 있도록 처리해야 한다.

--○ EMP 테이블에서 부서번호가 20번과 30번 직원들의 정보중
--   사원번호, 사원명, 직종명, 급여, 부서번호 항복을 조회한다.
--   단, 별칭(ALIAS)을 사용한다.
SELECT EMPNO AS "사원번호", ENAME "사원명", JOB 직종명, SAL AS "급 여", DEPTNO"부서번호"
FROM EMP 
WHERE DEPTNO = 20 OR DEPTNO = 30;
--==>>
/*
7369	SMITH	CLERK	    800	    20
7499	ALLEN	SALESMAN	1600	30
7521	WARD	SALESMAN	1250	30
7566	JONES	MANAGER	    2975	20
7654	MARTIN	SALESMAN	1250	30
7698	BLAKE	MANAGER	    2850	30
7788	SCOTT	ANALYST	    3000	20
7844	TURNER	SALESMAN	1500	30
7876	ADAMS	CLERK	    1100	20
7900	JAMES	CLERK	    950	    30
7902	FORD	ANALYST	    3000	20
*/


SELECT EMPNO AS "사원번호", ENAME "사원명", JOB 직종명, SAL AS "급 여", DEPTNO"부서번호"
FROM EMP 
WHERE DEPTNO IN(20, 30);    
--> IN 연산자를 활용하여 이와 같이 처리할 수 있으며
--  위의 구문과 같은 결과를 반환하게 된다.


--○ EMP 테이블에서 직종이 CLERK 인 사원들의 정보를 모두 조회한다.
SELECT *
FROM EMP
WHERE JOB='CLERK';
--==>> 
/*
7369	SMITH	CLERK	7902	1980-12-17 00:00:00	800		    20
7876	ADAMS	CLERK	7788	1987-07-13 00:00:00	1100		20
7900	JAMES	CLERK	7698	1981-12-03 00:00:00	950		    30
7934	MILLER	CLERK	7782	1982-01-23 00:00:00	1300		10
*/

select *
from emp
where job='clerk';      --> 에러는 아니지만 출력 안됨

Select *
From Emp
Where Job='CLERK';


--※ 오라클에서 입력된 데이터(값) 만큼은
--   반.드.시 대·소문자 구문을 한다.









=== 20190327_01_scott.sql === 

--○ 접속된 사용자 조회
SELECT USER
FROM DUAL;
--==>> SCOTT

--○ EMP 테이블에서 직종이 CLERK 인 사원들 중
--   20번 부서에서 근무하는 사원들의
--   사원번호, 사원명, 직종명, 급여, 부서번호 항복을 조회한다.
SELECT EMPNO"사원번호", ENAME "사원명", JOB "직종명", SAL "급여", DEPTNO "부서번호"
FROM EMP
WHERE JOB='CLERK' AND DEPTNO=20;
--==>>
/*
7369	SMITH	CLERK	800	    20
7876	ADAMS	CLERK	1100	20
*/


--○ EMP 테이블에서 10번 부서에 근무하는 직원들 중
--   급여가 2500 이상인 사원들의
--   사원명, 직종명, 급여, 부서번호 항복을 조회한다,
SELECT ENAME "사원명", JOB "직종명", SAL "급여", DEPTNO "부서번호"
FROM EMP
WHERE DEPTNO=10 AND SAL >= 2500;
--==>> KING	PRESIDENT	5000	10


--○ 테이블 복사
--> 내부적으로 대상 테이블 안에 있는 데이터 내용만 복사하는 과정

--※ EMP 테이블의 정보를 확인하여
--   이와 똑같은 데이터가 들어있는 EMPCOPY 테이블을 생성한다.(팀별로)
SELECT *
FROM EMP;

DESCRIBE EMP;

CREATE TABLE EMPCOPY
(EMPNO NUMBER(4)  
, ENAME VARCHAR2(10)
, JOB VARCHAR2(9)
, MGR NUMBER(4)
, HIREDATE DATE
, SAL NUMBER(7,2)
, COMM NUMBER(7,2)
, DEPTNO NUMBER(2) 
);

ALTER TABLE EMPCOPY MODIFY(EMPNO NUMBER(4) CONSTRAINT PK_EMPCOPY PRIMARY KEY);

INSERT INTO EMPCOPY VALUES
(7369, 'SMITH', 'CLERK', 7902, to_date('17-12-1980','dd-mm-yyyy'), 800, NULL, 20);
INSERT INTO EMPCOPY VALUES
(7499, 'ALLEN', 'SALESMAN', 7698, to_date('20-02-1980','dd-mm-yyyy'), 1600, 300, 30);
INSERT INTO EMPCOPY VALUES
(7521, 'WARD', 'SALESMAN', 7698, to_date('22-02-1981','dd-mm-yyyy'), 1250, 500, 30);
INSERT INTO EMPCOPY VALUES
(7566, 'JONES', 'MANAGER', 7839, to_date('02-04-1981','dd-mm-yyyy'), 2975, NULL, 20);
INSERT INTO EMPCOPY VALUES
(7654, 'MARTIN', 'SALESMAN', 7698, to_date('28-09-1981','dd-mm-yyyy'), 1250, 1400, 30);
INSERT INTO EMPCOPY VALUES
(7698, 'BLAKE', 'MANAGER', 7839, to_date('01-05-1981','dd-mm-yyyy'), 2850, NULL, 30);
INSERT INTO EMPCOPY VALUES
(7782, 'CLARK', 'MANAGER', 7839, to_date('09-06-1981','dd-mm-yyyy'), 2450, NULL, 10);
INSERT INTO EMPCOPY VALUES
(7788, 'SCOTT', 'ANALYST', 7566, to_date('13-07-1987','dd-mm-yyyy'), 3000, NULL, 20);
INSERT INTO EMPCOPY VALUES
(7839, 'KING', 'PRESIDENT', NULL, to_date('17-11-1981','dd-mm-yyyy'), 5000, NULL, 10);
INSERT INTO EMPCOPY VALUES
(7844, 'TURNER', 'SALESMAN', 7698, to_date('08-09-1981','dd-mm-yyyy'), 1500, 0, 30);
INSERT INTO EMPCOPY VALUES
(7876, 'ADAMS', 'CLERK', 7788, to_date('13-07-1987','dd-mm-yyyy'), 1100, NULL, 20);
INSERT INTO EMPCOPY VALUES
(7900, 'JAMES', 'CLERK', 7698, to_date('03-12-1981','dd-mm-yyyy'), 950, NULL, 30);
INSERT INTO EMPCOPY VALUES
(7902, 'FORD', 'ANALYST', 7566, to_date('03-12-1981','dd-mm-yyyy'), 3000, NULL, 20);
INSERT INTO EMPCOPY VALUES
(7934, 'MILLER', 'CLERK', 7782, to_date('23-01-1982','dd-mm-yyyy'), 1300, NULL, 10);

DESC EMPCOPY;

SELECT * 
FROM EMPCOPY;

CREATE TABLE EMP2
AS
SELECT *
FROM EMP;
--==>> Table EMP2이(가) 생성되었습니다.

--○ 복사한 테이블 확인
SELECT *
FROM EMP2;


--※ 날짜 관련 세션 정보 설정
ALTER SESSION SET NLS_DATE_FORMAT = 'YYYY-MM-DD';
--==>> Session이(가) 변경되었습니다.


--○ 테이블 복사
CREATE TABLE TBL_EMP
AS
SELECT *
FROM EMP;
--==>> Table TBL_EMP이(가) 생성되었습니다.

CREATE TABLE TBL_DEPT
AS 
SELECT *
FROM DEPT;
--==>> Table TBL_DEPT이(가) 생성되었습니다.


--○ 복사한 테이블 확인
SELECT *
FROM TBL_EMP;

SELECT *
FROM TBL_DEPT;


--○ 테이블의 커멘트 정보 확인
SELECT *
FROM USER_TAB_COMMENTS;
--==>>
/*
DEPT	        TABLE	
EMP	            TABLE	
BONUS	        TABLE	
SALGRADE	    TABLE	
TBL_EXAMPLE1	TABLE	
TBL_EXAMPLE2	TABLE	
EMPCOPY	        TABLE	
EMP2	        TABLE	
TBL_EMP	        TABLE	
TBL_DEPT	    TABLE	
*/


--○ 테이블의 커멘트 정보 입력
COMMENT ON TABLE TBL_EMP IS '사원정보';
--==>> Comment이(가) 생성되었습니다.

--○ 커멘트 정보 입력 이후 다시 확인
SELECT *
FROM USER_TAB_COMMENTS;
--==>>
/*
TBL_DEPT	    TABLE	
TBL_EMP	        TABLE   사원정보
EMP2	        TABLE	
EMPCOPY	        TABLE	
TBL_EXAMPLE2	TABLE	
TBL_EXAMPLE1	TABLE	
SALGRADE	    TABLE	
BONUS	        TABLE	
EMP	            TABLE	
DEPT	        TABLE	
*/


--○ 테이블 레벨의 커멘트 정보 입력 (TBL_DEPT → 부서정보)
COMMENT ON TABLE TBL_DEPT IS '부서정보'
--==>> Comment이(가) 생성되었습니다.

--○ 커멘트 정보 입력 후 다시 확인
SELECT *
FROM USER_TAB_COMMENTS;
--==>>
/*
TBL_DEPT	    TABLE	부서정보
TBL_EMP	        TABLE	사원정보
EMP2	        TABLE	
EMPCOPY	        TABLE	
TBL_EXAMPLE2	TABLE	
TBL_EXAMPLE1	TABLE	
SALGRADE	    TABLE	
BONUS	        TABLE	
EMP	            TABLE	
DEPT	        TABLE	
*/


--※ 휴지통 비우기
PURGE RECYCLEBIN;
--==>> RECYCLEBIN이(가) 비워졌습니다.


--○ 컬럼 레벨의 커멘트 정보 확인
SELECT *
FROM USER_COL_COMMENTS;
--==>>
/*
EMPCOPY	        MGR	
DEPT	        LOC	
BONUS	        COMM	
TBL_EMP	        EMPNO	
EMPCOPY	        DEPTNO	
SALGRADE	    LOSAL	
EMP2	        DEPTNO	
TBL_DEPT	    DNAME	
TBL_EMP	        COMM	
EMPCOPY	        COMM	
EMPCOPY	        EMPNO	
EMP 	        DEPTNO	
SALGRADE	    HISAL	
EMP	            EMPNO	
DEPT	        DEPTNO	
DEPT	        DNAME	
TBL_EMP	        JOB	
EMP2	        JOB	
EMP2	        HIREDATE	
EMP2	        COMM	
EMPCOPY	        JOB	
TBL_EXAMPLE2	NO	
BONUS	        JOB	
TBL_EXAMPLE1	NO	
TBL_EMP	        HIREDATE	
EMP	            ENAME	
EMP2	        SAL	
EMPCOPY	        HIREDATE	
EMPCOPY	        ENAME	
EMP	            JOB	
TBL_EXAMPLE2	NAME	
BONUS	        SAL	
EMP	            SAL	
TBL_EMP	        SAL	
TBL_EXAMPLE1	NAME	
EMP2	        ENAME	
EMP	            COMM	
SALGRADE	    GRADE	
TBL_EXAMPLE1	ADDR	
TBL_EXAMPLE2	ADDR	
EMP	            HIREDATE	
EMPCOPY	        SAL	
TBL_EMP	        DEPTNO	
TBL_EMP	        ENAME	
TBL_DEPT	    DEPTNO	
EMP2	        EMPNO	
EMP	            MGR	
TBL_EMP	        MGR	
TBL_DEPT	    LOC	
BONUS	        ENAME	
EMP2	        MGR	
*/


SELECT *
FROM USER_COL_COMMENTS
WHERE TABLE_NAME = 'TBL_DEPT';
--==>>
/*
TBL_DEPT	DEPTNO	
TBL_DEPT	DNAME	
TBL_DEPT	LOC	
*/


--○ 테이블에 소속된(포함된) 컬럼 레벨의 커멘트 정보 입력(설정)
COMMENT ON COLUMN TBL_DEPT.DEPTNO IS '부서번호';
--==>> Comment이(가) 생성되었습니다.
COMMENT ON COLUMN TBL_DEPT.DNAME IS '부서명';
--==>> Comment이(가) 생성되었습니다.
COMMENT ON COLUMN TBL_DEPT.LOC IS '부서위치';
--==>> Comment이(가) 생성되었습니다.


--○ 커멘트 정보가 입력된 테이블의 컬럼 레벨의 정보 확인 
SELECT *
FROM USER_COL_COMMENTS
WHERE TABLE_NAME='TBL_DEPT';
--==>>
/*
TBL_DEPT	DEPTNO	부서번호
TBL_DEPT	DNAME	부서명
TBL_DEPT	LOC	    부서위치
*/


DESC EMP;
--==>>
/*
EMPNO    NOT NULL NUMBER(4)    -- 사원번호
ENAME             VARCHAR2(10) -- 사원명
JOB               VARCHAR2(9)  -- 직종명
MGR               NUMBER(4)    -- 관리자사원번호
HIREDATE          DATE         -- 입사일
SAL               NUMBER(7,2)  -- 급여
COMM              NUMBER(7,2)  -- 수당
DEPTNO            NUMBER(2)    -- 부서번호
*/


--○ TBL_EMP 테이블에 소속된(포함된)
--   컬럼에 대한 커멘트 정보를 입력(설정)한다.
COMMENT ON COLUMN TBL_EMP.EMPNO IS '사원번호';
COMMENT ON COLUMN TBL_EMP.ENAME IS '사원명';
COMMENT ON COLUMN TBL_EMP.JOB IS '직종명';
COMMENT ON COLUMN TBL_EMP.MGR IS '관리자사원번호';
COMMENT ON COLUMN TBL_EMP.HIREDATE IS '입사일';
COMMENT ON COLUMN TBL_EMP.SAL IS '급여';
COMMENT ON COLUMN TBL_EMP.COMM IS '수당';
COMMENT ON COLUMN TBL_EMP.DEPTNO IS '부서번호';
--==>> Comment이(가) 생성되었습니다. * 8


--○ 커멘트 정보가 입력된 테이블의 컬럼 레벨의 정보 확인 
SELECT *
FROM USER_COL_COMMENTS
WHERE TABLE_NAME='TBL_EMP';
--==>>
/*
TBL_EMP	EMPNO	    사원번호
TBL_EMP	ENAME	    사원명
TBL_EMP	JOB	        직종명
TBL_EMP	MGR	        관리자사원번호
TBL_EMP	HIREDATE	입사일
TBL_EMP	SAL	        급여
TBL_EMP	COMM	    수당
TBL_EMP	DEPTNO	    부서번호
*/


--■■■ 컬럼의 구조의 추가 및 제거 ■■■--
SELECT *
FROM TBL_EMP;

--○ TBL_EMP 테이블에 주민등록번호 정보를 담을 수 있는 컬럼 추가
ALTER TABLE TBL_EMP
ADD SSN CHAR(13);
--==>> Table TBL_EMP이(가) 변경되었습니다.
-- 맨 앞에 0이 들어올 가능성이 있는 숫자가 조합된 데이터라면
-- 숫자형이 아닌 문자형으로 데이터타입을 처리해야 한다.

SELECT 0012121234567
FROM DUAL;
--==>> 12121234567

SELECT '0012121234567'
FROM DUAL;
--==>> 0012121234567


--○ 확인
SELECT *
FROM TBL_EMP;
--==>>
/*
     EMPNO ENAME      JOB              MGR HIREDATE          SAL       COMM     DEPTNO SSN          
---------- ---------- --------- ---------- ---------- ---------- ---------- ---------- -------------
      7369 SMITH      CLERK           7902 1980-12-17        800                    20              
      7499 ALLEN      SALESMAN        7698 1981-02-20       1600        300         30              
      7521 WARD       SALESMAN        7698 1981-02-22       1250        500         30              
      7566 JONES      MANAGER         7839 1981-04-02       2975                    20              
      7654 MARTIN     SALESMAN        7698 1981-09-28       1250       1400         30              
      7698 BLAKE      MANAGER         7839 1981-05-01       2850                    30              
      7782 CLARK      MANAGER         7839 1981-06-09       2450                    10              
      7788 SCOTT      ANALYST         7566 1987-07-13       3000                    20              
      7839 KING       PRESIDENT            1981-11-17       5000                    10              
      7844 TURNER     SALESMAN        7698 1981-09-08       1500          0         30              
      7876 ADAMS      CLERK           7788 1987-07-13       1100                    20              
      7900 JAMES      CLERK           7698 1981-12-03        950                    30              
      7902 FORD       ANALYST         7566 1981-12-03       3000                    20              
      7934 MILLER     CLERK           7782 1982-01-23       1300                    10 

14개 행이 선택되었습니다. 
*/

DESC TBL_EMP;
--==>>
/*
EMPNO       NUMBER(4)    
ENAME       VARCHAR2(10) 
JOB         VARCHAR2(9)  
MGR         NUMBER(4)    
HIREDATE    DATE         
SAL         NUMBER(7,2)  
COMM        NUMBER(7,2)  
DEPTNO      NUMBER(2)    
SSN         CHAR(13) 
*/


SELECT EMPNO, ENAME, SSN, HIREDATE, SAL, COMM
FROM TBL_EMP;
--==>>
/*
     EMPNO ENAME      SSN           HIREDATE          SAL       COMM
---------- ---------- ------------- ---------- ---------- ----------
      7369 SMITH                    1980-12-17        800           
      7499 ALLEN                    1981-02-20       1600        300
      7521 WARD                     1981-02-22       1250        500
      7566 JONES                    1981-04-02       2975           
      7654 MARTIN                   1981-09-28       1250       1400
      7698 BLAKE                    1981-05-01       2850           
      7782 CLARK                    1981-06-09       2450           
      7788 SCOTT                    1987-07-13       3000           
      7839 KING                     1981-11-17       5000           
      7844 TURNER                   1981-09-08       1500          0
      7876 ADAMS                    1987-07-13       1100           
      7900 JAMES                    1981-12-03        950           
      7902 FORD                     1981-12-03       3000           
      7934 MILLER                   1982-01-23       1300   
      
14개 행이 선택되었습니다. 
*/
--> 테이블 내에서 컬럼의 순서는 구조적으로 의미 없음


--○ TBL_EMP 테이블에서 추가한 SSN(주민등록번호) 컬럼 제거
ALTER TABLE TBL_EMP
DROP COLUMN SSN;
--==>> Table TBL_EMP이(가) 변경되었습니다.


--○ 확인
SELECT *
FROM TBL_EMP;
--==>>
/*
     EMPNO ENAME      JOB              MGR HIREDATE          SAL       COMM     DEPTNO
---------- ---------- --------- ---------- ---------- ---------- ---------- ----------
      7369 SMITH      CLERK           7902 1980-12-17        800                    20
      7499 ALLEN      SALESMAN        7698 1981-02-20       1600        300         30
      7521 WARD       SALESMAN        7698 1981-02-22       1250        500         30
      7566 JONES      MANAGER         7839 1981-04-02       2975                    20
      7654 MARTIN     SALESMAN        7698 1981-09-28       1250       1400         30
      7698 BLAKE      MANAGER         7839 1981-05-01       2850                    30
      7782 CLARK      MANAGER         7839 1981-06-09       2450                    10
      7788 SCOTT      ANALYST         7566 1987-07-13       3000                    20
      7839 KING       PRESIDENT            1981-11-17       5000                    10
      7844 TURNER     SALESMAN        7698 1981-09-08       1500          0         30
      7876 ADAMS      CLERK           7788 1987-07-13       1100                    20
      7900 JAMES      CLERK           7698 1981-12-03        950                    30
      7902 FORD       ANALYST         7566 1981-12-03       3000                    20
      7934 MILLER     CLERK           7782 1982-01-23       1300                    10
      
14개 행이 선택되었습니다. 
*/

DESC TBL_EMP;
--==>>
/*
EMPNO       NUMBER(4)    
ENAME       VARCHAR2(10) 
JOB         VARCHAR2(9)  
MGR         NUMBER(4)    
HIREDATE    DATE         
SAL         NUMBER(7,2)  
COMM        NUMBER(7,2)  
DEPTNO      NUMBER(2)
*/

--> SSN(주민등록번호) 컬럼이 정상적으로 제거되었음을 확이


DELETE
FROM TBL_EMP
WHERE ENAME='SMITH';
--==>> 1 행 이(가) 삭제되었습니다.

--○ 확인
SELECT *
FROM TBL_EMP;
--==>>
/*
     EMPNO ENAME      JOB              MGR HIREDATE          SAL       COMM     DEPTNO
---------- ---------- --------- ---------- ---------- ---------- ---------- ----------
      7499 ALLEN      SALESMAN        7698 1981-02-20       1600        300         30
      7521 WARD       SALESMAN        7698 1981-02-22       1250        500         30
      7566 JONES      MANAGER         7839 1981-04-02       2975                    20
      7654 MARTIN     SALESMAN        7698 1981-09-28       1250       1400         30
      7698 BLAKE      MANAGER         7839 1981-05-01       2850                    30
      7782 CLARK      MANAGER         7839 1981-06-09       2450                    10
      7788 SCOTT      ANALYST         7566 1987-07-13       3000                    20
      7839 KING       PRESIDENT            1981-11-17       5000                    10
      7844 TURNER     SALESMAN        7698 1981-09-08       1500          0         30
      7876 ADAMS      CLERK           7788 1987-07-13       1100                    20
      7900 JAMES      CLERK           7698 1981-12-03        950                    30
      7902 FORD       ANALYST         7566 1981-12-03       3000                    20
      7934 MILLER     CLERK           7782 1982-01-23       1300                    10

13개 행이 선택되었습니다. 
*/


DELETE TBL_EMP;     -- 권장하지 않음

DELETE
FROM TBL_EMP;       -- 권장

--==>> 13개 행 이(가) 삭제되었습니다.


--○ 확인
SELECT *
FROM TBL_EMP;
--> 테이블의 구조는 그대로 남아있는 상태에서
--  데이터 모두 소실(삭제)된 상황임을 확인


DROP TABLE TBL_EMP;
--==>> Table TBL_EMP이(가) 삭제되었습니다.


--○ 확인
SELECT *
FROM TBL_EMP;
--==>>
/*
ORA-00942: table or view does not exist
00942. 00000 -  "table or view does not exist"
*Cause:    
*Action:
498행, 6열에서 오류 발생
*/


--○ 테이블 다시 생성(복사)
CREATE TABLE TBL_EMP
AS
SELECT *
FROM EMP;
--==>> Table TBL_EMP이(가) 생성되었습니다.


-------------------------------------------------------------------------------------------------------

--○ NULL 의 처리

SELECT 2, 10+2, 10-2, 10*2, 10/2
FROM DUAL;
--==>> 2	12	8	20	5

SELECT NULL, NULL+2, NULL-2, NULL*2, NULL/2, 10+NULL, 10-NULL, 10*NULL, 10/NULL
FROM DUAL;
--==>> (NULL) (NULL) (NULL) (NULL) (NULL) (NULL) (NULL) (NULL)(NULL) (NULL)

--※ 관찰 결과
--   NULL 은 상태의 값을 의미하며 실제 존재하지 않는 값이기 때문에
--   이 NULL 이 연산에 포함될 경우 그 결과는 무조건 NULL 이다.


--○ TBL_EMP 테이블에서 커미션(COMM, 수당)이 NULL 인 직원의
--   사원명, 직종명, 급여, 커미션 항목을 조회한다.
SELECT ENAME "사원명", JOB "직종명", SAL "급여", COMM "커미션"
FROM TBL_EMP
WHERE COMM = NULL;
--==>> 조회 결과 없음

SELECT ENAME "사원명", JOB "직종명", SAL "급여", COMM "커미션"
FROM TBL_EMP
WHERE COMM = (null);
--==>> 조회 결과 없음

SELECT ENAME "사원명", JOB "직종명", SAL "급여", COMM "커미션"
FROM TBL_EMP
WHERE COMM = 'NULL';
--==>> 에러 발생
/*
ORA-01722: invalid number
01722. 00000 -  "invalid number"
*Cause:    The specified number was invalid.
*Action:   Specify a valid number.
*/

DESC TBL_EMP;
--> COMM 칼럼은 숫자형 데이터 타입을 취하고 있음을 확인

--※ NULL 은 실제 존재하지 않는 값이기 때문에 일반적인 연산자를 활용하여 비교할 수 없다.
--   즉, 산술적인 비교 연산을 수행할 수 없다는 의미이다.
--   NULL 을 대상으로 사용할 수 없는 연산자들
--   >=, <=, >, <, !=, ^=, <>


SELECT ENAME "사원명", JOB "직종명", SAL "급여", COMM "커미션"
FROM TBL_EMP
WHERE COMM IS NULL;
--==>>
/*
SMITH	CLERK	    800	
JONES	MANAGER	    2975	
BLAKE	MANAGER	    2850	
CLARK	MANAGER	    2450	
SCOTT	ANALYST	    3000	
KING	PRESIDENT	5000	
ADAMS	CLERK	    1100	
JAMES	CLERK	    950	
FORD	ANALYST	    3000	
MILLER	CLERK	    1300	
*/


--○ TBL_EMP 테이블에서 20번 부서에 근무하지 않는 직원들의
--   사원명, 직족명, 부서번호 항목을 조회한다.
SELECT ENAME "사원명", JOB "직종명", DEPTNO "부서번호"
FROM TBL_EMP
WHERE DEPTNO != 20;
--==>>
/*
ALLEN	SALESMAN	30
WARD	SALESMAN	30
MARTIN	SALESMAN	30
BLAKE	MANAGER	    30
CLARK	MANAGER	    10
KING	PRESIDENT	10
TURNER	SALESMAN	30
JAMES	CLERK	    30
MILLER	CLERK	    10
*/

SELECT ENAME "사원명", JOB "직종명", DEPTNO "부서번호"
FROM TBL_EMP
WHERE DEPTNO ^= 20;

SELECT ENAME "사원명", JOB "직종명", DEPTNO "부서번호"
FROM TBL_EMP
WHERE DEPTNO = 10 OR DEPTNO = 30;

SELECT ENAME "사원명", JOB "직종명", DEPTNO "부서번호"
FROM TBL_EMP
WHERE DEPTNO IN(10, 30);


--○ TBL_EMP 테이블에서 커미션이 NULL 이 아닌 직원들의
--   사원명, 직종명, 급여, 커미션 항목을 조회한다.
SELECT ENAME "사원명", JOB "직종명", SAL "급여", COMM "커미션"
FROM TBL_EMP
WHERE COMM IS NOT NULL;
--==>>
/*
ALLEN	SALESMAN	1600	300
WARD	SALESMAN	1250	500
MARTIN	SALESMAN	1250	1400
TURNER	SALESMAN	1500	0
*/
SELECT ENAME "사원명", JOB "직종명", SAL "급여", COMM "커미션"
FROM TBL_EMP
WHERE NOT COMM IS NULL;


--○ TBL_EMP 테이블에서 모든 사원들의
--   사원번호, 사원명, 급여, 커미션, 연봉 항목을 조회한다.
--   단, 급여(SAL)는 매월 지급한다,
--   또한, 수당(COMM)은 매년 지급한다.
ALTER TABLE TBL_EMP
ADD ALLS NUMBER(4);

COMMENT ON COLUMN TBL_EMP.ALLS IS '연봉';

ALTER TABLE TBL_EMP DROP COLUMN ALLS;

SELECT EMPNO "사원번호", ENAME "사원명", SAL "급여", COMM "커미션", SAL*12 + COMM "연봉"
FROM TBL_EMP;

SELECT 1600*12+300
FROM DUAL;
--==>> 19500


-- NVL()
SELECT NULL"ⓐ", NVL(NULL, 10)"ⓑ", NVL(10, 20)"ⓒ"
FROM DUAL;
--==>> (null)   10  10
--> 첫 번째 파라미터 값이 NULL 이면, 두 번째 파라미터 값을 반환한다.
--  첫 번째 파라미터 값이 NULL 이 아니면, 그 값을 그대로 반환한다.

-- 관찰
SELECT *
FROM TBL_EMP
WHERE EMPNO=7369;
--==>> 7369	SMITH	CLERK	7902	80/12/17	800	  (null)	20	

SELECT ENAME, COMM
FROM TBL_EMP
WHERE EMPNO=7369;
--==>> SMITH    (null)

SELECT ENAME, NVL(COMM, 0)"확인여부"
FROM TBL_EMP
WHERE EMPNO=7369;
--==>> SMITH	0


SELECT EMPNO "사원번호", ENAME "사원명", SAL "급여", NVL(COMM, 0) "커미션", SAL*12 + NVL(COMM, 0) "연봉"
FROM TBL_EMP;
--==>>
/*
7369	SMITH	800	    0	    9600
7499	ALLEN	1600	300	    19500
7521	WARD	1250	500	    15500
7566	JONES	2975	0	    35700
7654	MARTIN	1250	1400	16400
7698	BLAKE	2850	0	    34200
7782	CLARK	2450	0	    29400
7788	SCOTT	3000	0	    36000
7839	KING	5000	0	    60000
7844	TURNER	1500	0	    18000
7876	ADAMS	1100	0	    13200
7900	JAMES	950	    0	    11400
7902	FORD	3000	0	    36000
7934	MILLER	1300	0	    15600
*/


--○ NVL2()
--> 첫 번째 파라미터 값이 NULL 이 아닌 경우, 두 번째 파라미터 값을 반환하고
--  첫 번째 파라미터 값이 NULL 인 경우, 세 번째 파라미터 값을 반환한다.
SELECT ENAME, COMM, NVL2(COMM, '청기올려', '백기올려')"확인여부"
FROM TBL_EMP;
--==>> 
/*
SMITH		    백기올려 --
ALLEN	300	    청기올려
WARD	500	    청기올려
JONES		    백기올려 --
MARTIN	1400	청기올려
BLAKE		    백기올려 --
CLARK		    백기올려 --
SCOTT		    백기올려 --
KING		    백기올려 --
TURNER	0	    청기올려
ADAMS		    백기올려 --
JAMES		    백기올려 --
FORD		    백기올려 --
MILLER		    백기올려 --
*/

SELECT EMPNO "사원번호", ENAME "사원명", SAL "급여", NVL2(COMM, COMM, 0) "커미션", NVL2(COMM, SAL*12+COMM, SAL*12) "연봉"
FROM TBL_EMP;
--==>>
/*
7369	SMITH	800	    0	     9600
7499	ALLEN	1600	300	    19500
7521	WARD	1250	500	    15500
7566	JONES	2975	0	    35700
7654	MARTIN	1250	1400	16400
7698	BLAKE	2850	0	    34200
7782	CLARK	2450	0	    29400
7788	SCOTT	3000	0	    36000
7839	KING	5000	0	    60000
7844	TURNER	1500	0	    18000
7876	ADAMS	1100	0	    13200
7900	JAMES	950 	0	    11400
7902	FORD	3000	0	    36000
7934	MILLER	1300	0	    15600
*/


--○ COALESCE()
--> 매개변수 제한이 없는 형태로 인지하고 활용한다.
--  맨 앞에 있는 매개변수부터 차례로 NULL 인지 아닌지 확인하여
--  NULL 이 아닐경우 적용(반환, 처리)하고,
--  NULL 인 경우에는 그 다음 매개변수의 값으로 적용(반환, 처리)한다.
--  NVL() 나 NVL2() 에 비해 모든 경우의 수를 고려할 수 있는 특징을 갖고 있다.
SELECT NULL "기본확인"
    , COALESCE(NULL, NULL, NULL, 30) "함수 확인1"
    , COALESCE(NULL, NULL, NULL, NULL, NULL, NULL, 100) "함수 확인2"
    , COALESCE(10, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 100) "함수 확인3"
    , COALESCE(NULL, NULL, 80, NULL, NULL, NULL, NULL, NULL, 100) "함수 확인4"
FROM DUAL;


--○ 실습을 위한 데이터 입력
INSERT INTO TBL_EMP(EMPNO, ENAME, JOB, MGR, HIREDATE, DEPTNO)
VALUES(8000, '승워니', 'SALEMAN', 7839, SYSDATE, 10);
--==>> 1 행 이(가) 삽입되었습니다.

INSERT INTO TBL_EMP(EMPNO, ENAME, JOB, MGR, HIREDATE, COMM, DEPTNO)
VALUES(8001, '희지니', 'SALESMAN', 7839, SYSDATE, 100, 10);
--==>> 1 행 이(가) 삽입되었습니다.

ROLLBACK;   -- 데이터 수정하기 위해...

INSERT INTO TBL_EMP(EMPNO, ENAME, JOB, MGR, HIREDATE, DEPTNO)
VALUES(8000, '승워니', 'SALESMAN', 7839, SYSDATE, 10);
--==>> 1 행 이(가) 삽입되었습니다.

INSERT INTO TBL_EMP(EMPNO, ENAME, JOB, MGR, HIREDATE, COMM, DEPTNO)
VALUES(8001, '희지니', 'SALESMAN', 7839, SYSDATE, 100, 10);
--==>> 1 행 이(가) 삽입되었습니다.

ALTER TABLE TBL_EMP
DROP COLUMN YEAR;       --YEAR 컬럼 삭제

SELECT *
FROM TBL_EMP;

COMMIT;
--==>> 커밋 완료.

SELECT EMPNO "사원번호", ENAME "사원명", SAL "급여", COMM "커미션", SAL*12 + NVL(COMM, 0) "연봉"
FROM TBL_EMP;

SELECT EMPNO "사원번호", ENAME "사원명", SAL "급여", COMM "커미션", COALESCE((SAL*12 +COMM), (COMM), (SAL*12), 0) "연봉"
FROM TBL_EMP;
--==>>
/*
7369	SMITH	 800	         9600
7499	ALLEN	1600	 300	19500
7521	WARD	1250	 500    15500
7566	JONES	2975		    35700
7654	MARTIN	1250	1400	16400
7698	BLAKE	2850		    34200
7782	CLARK	2450		    29400
7788	SCOTT	3000		    36000
7839	KING	5000		    60000
7844	TURNER	1500	   0    18000
7876	ADAMS	1100		    13200
7900	JAMES	 950	        11400
7902	FORD	3000		    36000
7934	MILLER	1300		    15600
8000	승워니			            0
8001	희지니		      100	  100
*/


-----------------------------------------------------------------------------------------------------------

--※ 날짜에 대한 세션 설정 변경
ALTER SESSION SET NLS_DATE_FORMAT = 'YYYY-MM-DD HH24:MI:SS';
--==>> Session이(가) 변경되었습니다.


--○ 현재 날짜 및 시간을 반환하는 함수
SELECT SYSDATE, CURRENT_DATE, LOCALTIMESTAMP
FROM DUAL;
--==>>
/*
2019-03-27 15:45:55	
2019-03-27 15:45:55	
19/03/27 15:45:55.000000000
*/


--※ 날짜에 대한 세션 설정 정보 다시 변경하기
ALTER SESSION SET NLS_DATE_FORMAT = 'YYYY-MM-DD';
--==>> Session이(가) 변경되었습니다.


--○ 컬럼과 컬럼의 연결(결합)
--   문자타입과 문자타입의 연결
--   『+』 연산자를 통한 결합 수행은 불가능 → 『||』
SELECT 1+1
FROM DUAL;
--==>> 2

SELECT '이원영' + '전훈의'
FROM DUAL;
--==>> 에러 발생
/*
ORA-01722: invalid number
01722. 00000 -  "invalid number"
*Cause:    The specified number was invalid.
*Action:   Specify a valid number.
*/

SELECT '이원영', '전훈의'
FROM DUAL;
--==>> 이원영	전훈의

SELECT '이원영' || '전훈의'
FROM DUAL;
--==>> 이원영전훈의

SELECT EMPNO, ENAME
FROM TBL_EMP;
--==>>
/*
7369	SMITH
7499	ALLEN
7521	WARD
7566	JONES
7654	MARTIN
7698	BLAKE
7782	CLARK
7788	SCOTT
7839	KING
7844	TURNER
7876	ADAMS
7900	JAMES
7902	FORD
7934	MILLER
8000	승워니
8001	희지니
*/

SELECT EMPNO || ENAME
FROM TBL_EMP;
/*
7369SMITH
7499ALLEN
7521WARD
7566JONES
7654MARTIN
7698BLAKE
7782CLARK
7788SCOTT
7839KING
7844TURNER
7876ADAMS
7900JAMES
7902FORD
7934MILLER
8000승워니
8001희지니
*/

--      문자타입   날짜타입  문자타입 숫자타입 문자타입
--     ----------  -------  ----------  ---  --------------
SELECT '원영이는', SYSDATE, '에 연봉 ', 500, '억을 원한다.'
FROM DUAL;
--==>> 원영이는	2019-03-27	에 연봉 	500	억을 원한다.

--      문자타입    날짜타입     문자타입   숫자타입   문자타입
--     ----------    -------    ----------    ---    --------------
SELECT '원영이는' || SYSDATE || '에 연봉 ' || 500 || '억을 원한다.'
FROM DUAL;
--==>> 원영이는2019-03-27에 연봉 500억을 원한다.

--※ 오라클에서 문자 타입의 형태로 형 변환하는 별도의 과정 없이
--   위에서 처리한 내용 처럼 『||』만 삽입해주면 간단히 컬럼과 컬럼을
--   (서로 다른 종류의 데이터) 결합하는 것이 가능하다.
--   MYSQL 에서는 모든 데이터를 문자타입으로 CONVERT 해야 한다.


--○ TBL_EMP 테이블의 정보를 활용하여
--   모든 직원들의 데이터에 대하여
--   다음과 같은 결과를 얻을 수 있도록 쿼리문을 구성한다.

--   SMITH 의 현재 연봉은 9600인데 희망 연봉은 19200이다.
--   ALLEN 의 현재 연봉은 19500인데 희망 연봉은 39000이다.
--                         :


SELECT *
FROM TBL_EMP
WHERE EMPNO IN (8000, 8001);

DELETE
FROM TBL_EMP
WHERE EMPNO IN (8000, 8001);
--==>> 2개 행 이(가) 삭제되었습니다.

COMMIT;
--==>> 커밋 완료.

--방식1
SELECT ENAME || ' 의 현재 연봉은 ' || NVL(SAL*12 +COMM, SAL*12) || '인데 희망 연봉은 ' || NVL((SAL*12 +COMM), SAL*12)*2 || '이다.'
FROM TBL_EMP;

--방식2
SELECT ENAME || ' 의 현재 연봉은 ' || NVL2(COMM, SAL*12 +COMM, SAL*12) || '인데 희망 연봉은 ' || NVL2(COMM, (SAL*12 +COMM), SAL*12)*2 || '이다.'
FROM TBL_EMP;

--방식3
SELECT ENAME || ' 의 현재 연봉은 ' || COALESCE((SAL*12 +COMM), (COMM), (SAL*12), 0) || '인데 희망 연봉은 ' || COALESCE((SAL*12 +COMM), (COMM), (SAL*12), 0)*2 || '이다.'
FROM TBL_EMP;


-- SMITH's 입사일은 1980-12-17 이다. 그리고 급여는 800이다.
-- ALLEN's 입사일은 1981-02-20 이다. 그리고 급여는 1600이다.
--                      :

SELECT ENAME || '''s 입사일은 ' || HIREDATE || ' 이다. 그리고 급여는 ' || SAL || '이다.'
FROM TBL_EMP;

--※ 문자열을 나타내는 홑따옴표 사이에서(시작과 끝)
--   홑따옴표 두 개가 홑따옴표 하나(어퍼스트로피)를 의미한다.
--   홑따옴표 『'』하나는 문자열의 시작을 나타내고
--   홑따옴표 『''』두 개는 문자열 영역 안에서 어퍼스트로피를 나타내며
--   다시 등장하는 홑따옴표 『'』하나가 문자열 영역의 종료를 의미하게 되는 것이다.




=== 20190328_01_scott.sql ===

SELECT USER
FROM DUAL;
--==>> SCOTT

SELECT *
FROM EMP
WHERE JOB='salesman';
--==>> 조회 결과 없음


--○ UPPER(), LOWER(), INITCAP()
SELECT 'oRaCLe' "1", UPPER('oRaCLe') "2", LOWER('oRaCLe') "3", INITCAP('oRaCLe') "4"
FROM DUAL;
--==>> oRaCLe	ORACLE	oracle	Oracle
--> UPPER() 는 모두 대문자로 변환
--  LOWER() 는 모두 소문자로 변환
--  INITCAP() 는 첫 글자만 대문자로 하고 나머지는 모두 소문자로 변환하여 변환


SELECT *
FROM EMP
WHERE JOB=UPPER('SalEsmAn');
--==>> 
/*
7499	ALLEN	SALESMAN	7698	81/02/20	1600	 300    30
7521	WARD	SALESMAN	7698	81/02/22	1250	 500    30
7654	MARTIN	SALESMAN	7698	81/09/28	1250	1400	30
7844	TURNER	SALESMAN	7698	81/09/08	1500	   0    30
*/

SELECT *
FROM EMP
WHERE UPPER(JOB)=UPPER('SalEsmAn');

SELECT *
FROM EMP
WHERE LOWER(JOB)=LOWER('SalEsmAn');

SELECT *
FROM EMP
WHERE INITCAP(JOB)=INITCAP('SalEsmAn');


--○ TBL_EMP 테이블에서 입사일이 1981년 9월 28일 입사한 직원의
--   사원명, 직종명 입사일 항목을 조회한다.
SELECT ENAME "사원명", JOB "직종명", HIREDATE "입사일"
FROM TBL_EMP
WHERE HIREDATE=('19810928');
--==>> MARTIN	SALESMAN	81/09/28    '1981-09-28'도 가능


--○ TO_DATE()
SELECT ENAME "사원명", JOB "직종명", HIREDATE "입사일"
FROM TBL_EMP
WHERE HIREDATE=TO_DATE('1981-09-28', 'YYYY-MM-DD');


--○ TBL_EMP 테이블에서 입사일이 1981년 9월 28일 이후(해당일 포함)로 입사한 직원의
--   사원명, 직종명, 입사일 항목을 조회한다.
SELECT ENAME"사원명", JOB"직종명", HIREDATE"입사일"
FROM TBL_EMP
WHERE HIREDATE >= TO_DATE('1981-09-28', 'YYYY-MM-DD');
--==>>
/*
MARTIN	SALESMAN	81/09/28
SCOTT	ANALYST	    87/07/13
KING	PRESIDENT	81/11/17
ADAMS	CLERK	    87/07/13
JAMES	CLERK	    81/12/03
FORD	ANALYST	    81/12/03
MILLER	CLERK	    82/01/23
*/

--※ 오라클에서는 날짜 데이터의 크기 비교가 가능하다.
--   오라클에서 날짜 데이터에 대한 크기 비교 시
--   과거보다 미래를 더 큰 값으로 간주하여 처리된다.


--○ TBL_EMP 테이블에서 입사일이 1981년 4월 2일 부터
--   1981년 9월 28일 사이에 입사한 직원들의
--   사원명, 직종명, 입사일 항목을 조회한다. (해당일 포함)\
SELECT ENAME"사원명", JOB"직종명", HIREDATE"입사일"
FROM TBL_EMP
WHERE TO_DATE('1981-09-28') >= HIREDATE AND HIREDATE >= TO_DATE('1981-04-02', 'YYYY-MM-DD');
--==>> 
/*
JONES	MANAGER	    81/04/02
MARTIN	SALESMAN	81/09/28
BLAKE	MANAGER	    81/05/01
CLARK	MANAGER	    81/06/09
TURNER	SALESMAN	81/09/08
*/

--○ BETWEEN ⓐ AND ⓑ
SELECT ENAME"사원명", JOB"직종명", HIREDATE"입사일"
FROM TBL_EMP
WHERE HIREDATE BETWEEN TO_DATE('1981-04-02', 'YYYY-MM-DD') AND TO_DATE('1981-09-28')  ;

SELECT *
FROM TBL_EMP
WHERE SAL BETWEEN 2000 AND 3000;
--==>>
/*
7566	JONES	MANAGER	7839	81/04/02	2975		20
7698	BLAKE	MANAGER	7839	81/05/01	2850		30
7782	CLARK	MANAGER	7839	81/06/09	2450		10
7788	SCOTT	ANALYST	7566	87/07/13	3000		20
7902	FORD	ANALYST	7566	81/12/03	3000		20
*/

SELECT *
FROM TBL_EMP
WHERE ENAME BETWEEN 'C' AND 'S';

SELECT *
FROM TBL_EMP
WHERE ENAME BETWEEN 'C' AND 's';
--==>>
/*
7369	SMITH	CLERK	    7902	80/12/17	800		        20
7521	WARD	SALESMAN	7698	81/02/22	1250	 500    30
7566	JONES	MANAGER	    7839	81/04/02	2975		    20
7654	MARTIN	SALESMAN	7698	81/09/28	1250	1400	30
7782	CLARK	MANAGER	    7839	81/06/09	2450		    10
7788	SCOTT	ANALYST	    7566	87/07/13	3000		    20
7839	KING	PRESIDENT		    81/11/17	5000		    10
7844	TURNER	SALESMAN	7698	81/09/08	1500	   0    30
7900	JAMES	CLERK	    7698	81/12/03	950		        30
7902	FORD	ANALYST	    7566	81/12/03	3000		    20
7934	MILLER	CLERK	    7782	82/01/23	1300		    10
*/

--※ BETWEEN ⓐ AND ⓑ 는 날짜형, 숫자형, 문자형 데이터 모두에 적용된다.
--   단, 문자형일 경우 아스키코드 순서를 따르기 때문에
--   대문자가 앞쪽에 위치하고 소문자가 뒤쪽에 위치한다.
--   또한, BETWEEN ⓐ AND ⓑ 는 쿼리문이 수행되는 시점에서
--   오라클 내부적으로는 부등호 연산자의 형태로 바뀌어 연산이 처리된다.

--○ ASCII()
SELECT ASCII('A'), ASCII('B'), ASCII('a'), ASCII('b')
FROM DUAL;
--==>> 65	66	97	98


--○ TBL_EMP 테이블에서 직종이 SALESMAN 과 CLERK 인 사원의
--   사원명, 직종명, 급여 항목을 조회한다.
SELECT ENAME"사원명", JOB"직종명", SAL"급여"
FROM TBL_EMP
WHERE JOB='SALESMAN' OR JOB='CLERK');

SELECT ENAME"사원명", JOB"직종명", SAL"급여"
FROM TBL_EMP
WHERE JOB IN ('SALESMAN', 'CLERK');

SELECT ENAME"사원명", JOB"직종명", SAL"급여"
FROM TBL_EMP
WHERE JOB =ANY ('SALESMAN', 'CLERK');   --cf. 『=ALL』

--※ 위의 3가지 유형의 쿼리문은 모두 같은 결과를 반환한다.
--   하지만, 맨 위의 커리문이 가장 빠르게 처리된다.
--   물론, 메모리에 대한 내용이 아니라 CPU 에 대한 내용이므로
--   이 부분까지 감안하여 쿼리문의 내용을 구성하는 일은 많지 않다.
--   → 『IN』 과 『=ANY』 는 같은 연산자 효과를 가진다.
--   모두 내부적으로 『OR』 구조로 변경되어 연산 처리 된다.


-----------------------------------------------------------------------------------------------------------------

--○ 추가 실습 테이블 구성(TBL_SAWON)
CREATE TABLE TBL_SAWON
( SANO      NUMBER(4)
, SANAME     VARCHAR(30)
, JUBUN     CHAR(13)
, HIREDATE  DATE DEFAULT SYSDATE
, SAL       NUMBER(10)
);
--==>> Table TBL_SAWON이(가) 생성되었습니다.

SELECT *
FROM TBL_SAWON;

DESC TBL_SAWON;
--==>>
/*
SANO        NUMBER(4)    
SANAME       VARCHAR2(30) 
JUBUN       CHAR(13)     
HIREDATE    DATE         
SAL         NUMBER(10)   
*/


--○ 데이터 입력(TBL_SAWON)
INSERT INTO TBL_SAWON(SANO, SANAME, JUBUN, HIREDATE, SAL)
VALUES(1001, '이원영', '8706241234567', TO_DATE('2001-01-03', 'YYYY-MM-DD'), 3000);

INSERT INTO TBL_SAWON(SANO, SANAME, JUBUN, HIREDATE, SAL)
VALUES(1002, '나주영', '9405022234567', TO_DATE('2001-11-05', 'YYYY-MM-DD'), 2000);

INSERT INTO TBL_SAWON(SANO, SANAME, JUBUN, HIREDATE, SAL)
VALUES(1003, '진윤비', '9710012234567', TO_DATE('1999-08-16', 'YYYY-MM-DD'), 5000);

INSERT INTO TBL_SAWON(SANO, SANAME, JUBUN, HIREDATE, SAL)
VALUES(1004, '권홍비', '9504102234567', TO_DATE('1997-11-05', 'YYYY-MM-DD'), 4000);

INSERT INTO TBL_SAWON(SANO, SANAME, JUBUN, HIREDATE, SAL)
VALUES(1005, '이비승', '7210101234567', TO_DATE('1998-02-02', 'YYYY-MM-DD'), 2000);

INSERT INTO TBL_SAWON(SANO, SANAME, JUBUN, HIREDATE, SAL)
VALUES(1006, '조영우', '8004271234567', TO_DATE('1998-02-02', 'YYYY-MM-DD'), 2000);

INSERT INTO TBL_SAWON(SANO, SANAME, JUBUN, HIREDATE, SAL)
VALUES(1007, '이하이', '0405064234567', TO_DATE('2010-07-15', 'YYYY-MM-DD'), 1000);

INSERT INTO TBL_SAWON(SANO, SANAME, JUBUN, HIREDATE, SAL)
VALUES(1008, '소이현', '0506074234567', TO_DATE('2010-07-15', 'YYYY-MM-DD'), 1000);

INSERT INTO TBL_SAWON(SANO, SANAME, JUBUN, HIREDATE, SAL)
VALUES(1009, '선동열', '0505053234567', TO_DATE('2011-07-15', 'YYYY-MM-DD'), 3000);

INSERT INTO TBL_SAWON(SANO, SANAME, JUBUN, HIREDATE, SAL)
VALUES(1010, '선우선', '9505052234567', TO_DATE('1999-11-11', 'YYYY-MM-DD'), 4000);

INSERT INTO TBL_SAWON(SANO, SANAME, JUBUN, HIREDATE, SAL)
VALUES(1011, '선우용녀', '7512122234567', TO_DATE('1999-11-11', 'YYYY-MM-DD'), 5000);

INSERT INTO TBL_SAWON(SANO, SANAME, JUBUN, HIREDATE, SAL)
VALUES(1012, '남상현', '9302131234567', TO_DATE('2010-11-11', 'YYYY-MM-DD'), 3000);

INSERT INTO TBL_SAWON(SANO, SANAME, JUBUN, HIREDATE, SAL)
VALUES(1013, '남궁선', '7202021234567', TO_DATE('1992-10-10', 'YYYY-MM-DD'), 2000);

INSERT INTO TBL_SAWON(SANO, SANAME, JUBUN, HIREDATE, SAL)
VALUES(1014, '남이', '6912121234567', TO_DATE('1987-10-10', 'YYYY-MM-DD'), 4000);

--==>> 1 행 이(가) 삽입되었습니다. * 14


--○ 확인
SELECT *
FROM TBL_SAWON;
--==>>
/*
1001	이원영	    8706241234567	01/01/03	3000
1002	나주영	    9405022234567	01/11/05	2000
1003	진윤비	    9710012234567	99/08/16	5000
1004	권홍비	    9504102234567	97/11/05	4000
1005	이비승	    7210101234567	98/02/02	2000
1006	조영우	    8004271234567	98/02/02	2000
1007	이하이	    0405064234567	10/07/15	1000
1008	소이현	    0506074234567	10/07/15	1000
1009	선동열	    0505053234567	11/07/15	3000
1010	선우선	    9505052234567	99/11/11	4000
1011	선우용녀	7512122234567	99/11/11	5000
1012	남상현	    9302131234567	10/11/11	3000
1013	남궁선	    7202021234567	92/10/10	2000
1014	남이	    6912121234567	87/10/10	4000
*/

--○ 커밋
COMMIT;
--==>> 커밋 완료.


--○ TBL_SAWON 테이블에서 이원영 사원의 정보를 모두 조회한다,.
SELECT *
FROM TBL_SAWON
WHERE SANAME='이원영';
--==>> 1001	이원영	8706241234567	01/01/03	3000

SELECT *
FROM TBL_SAWON
WHERE SANAME LIKE '이원영';
--==>> 1001	이원영	8706241234567	01/01/03	3000

--※ LIKE : 동사 → 좋아하다.
--          부사 → ~와 같이, ~처럼

--※ WILD CHARACTER → 『%』
--   『LIKE』와 함께 사용되는 『%』는 모든 글자를 의미하고
--   『LIKE』와 함께 사용되는 『_』는 아무 글자 1개를 의미한다.


--○ TBL_SAWON 테이블에서 성씨가 『이』씨인 사원의
--   사원명, 주민번호, 급여 항목을 조회한다.
SELECT SANAME, JUBUN, SAL
FROM TBL_SAWON
WHERE SANAME='이';
--==>> 조회 결과 없음

SELECT SANAME, JUBUN, SAL
FROM TBL_SAWON
WHERE SANAME='이__';
--==>> 조회 결과 없음

SELECT SANAME, JUBUN, SAL
FROM TBL_SAWON
WHERE SANAME LIKE '이__';
--==>>
/*
이원영	8706241234567	3000
이비승	7210101234567	2000
이하이	0405064234567	1000
*/

SELECT SANAME, JUBUN, SAL
FROM TBL_SAWON
WHERE SANAME LIKE '이_';
--==>> 조회 결과 없음

SELECT SANAME, JUBUN, SAL
FROM TBL_SAWON
WHERE SANAME LIKE '이___';
--==>> 조회 결과 없음

SELECT SANAME, JUBUN, SAL
FROM TBL_SAWON
WHERE SANAME LIKE '이%';
--==>>
/*
이원영	8706241234567	3000
이비승	7210101234567	2000
이하이	0405064234567	1000
*/

SELECT SANAME, JUBUN, SAL
FROM TBL_SAWON
WHERE SANAME LIKE '남%';
--==>>
/*
남상현	9302131234567	3000
남궁선	7202021234567	2000
남이	6912121234567	4000
*/

--○ TBL_SAWON 테이블에서 이름의 마지막 글자가 『비』로 
--   끝나는 사원의 사원명, 주민번호, 입사일, 급여 항목을 조회한다.
SELECT SANAME, JUBUN, HIREDATE, SAL
FROM TBL_SAWON
WHERE SANAME LIKE '%비';
--==>>
/*
진윤비	9710012234567	99/08/16	5000
권홍비	9504102234567	97/11/05	4000
*/

--○ TBL_SAWON 테이블에서 이름의 마지막 글자가 『이』로 
--   끝나는 사원의 사원명, 주민번호, 입사일, 급여 항목을 조회한다.
SELECT SANAME, JUBUN, HIREDATE, SAL
FROM TBL_SAWON
WHERE SANAME LIKE '%이';
--==>>
/*
이하이	0405064234567	10/07/15	1000
남이	6912121234567	87/10/10	4000
*/

--○ 데이터 추가 입력
INSERT INTO TBL_SAWON(SANO, SANAME, JUBUN, HIREDATE, SAL)
VALUES(1015, '이이경', '8410141234567', TO_DATE('1997-10-10', 'YYYY-MM-DD'), 5000);
--==>> 1 행 이(가) 삽입되었습니다.

--○ 커밋
COMMIT;
--==>> 커밋 완료.


--○ TBL_SAWON 테이블에서 사원 이름 안에 『이』라는 글자가
--   하나라도 포함되어 있으면 그 사원의
--   사원번호, 사원명, 입사일, 급여 항목을 조회한다.
SELECT SANO, SANAME, HIREDATE, SAL
FROM TBL_SAWON
WHERE SANAME LIKE '%이%';
--==>>
/*
1001	이원영	01/01/03	3000
1005	이비승	98/02/02	2000
1007	이하이	10/07/15	1000
1008	소이현	10/07/15	1000
1014	남이	87/10/10	4000
1015	이이경	97/10/10	5000
*/


--○ TBL_SAWON 테이블에서 사원 이름 안에 『이』라는 글자가
--   두 번 포함되어 있으면 그 사원의
--   사원번호, 사원명, 입사일, 급여 항목을 조회한다.
SELECT SANO, SANAME, HIREDATE, SAL
FROM TBL_SAWON
WHERE SANAME LIKE '%이%이%';
--==>> 
/*
1007	이하이	10/07/15	1000
1015	이이경	97/10/10	5000
*/


--○ TBL_SAWON 테이블에서 성씨가 남씨인 사원의
--   사원명, 주민번호, 급여 항목을 조회한다.
SELECT SANAME, JUBUN, SAL
FROM TBL_SAWON
WHERE SANAME LIKE '남%';
--==>>
/*
남상현	9302131234567	3000
남궁선	7202021234567	2000
남이	6912121234567	4000
*/


--※ 데이터베이스 설계 시 성과 이름을 분리해서 처리해야 함
--   업무 계획이 있다면(지금 당장은 아니더라도) 테이블에서 성 컬럼과
--   이름 컬럼을 분리하여 구성해야한다.


--○ TBL_SAWON 테이블에서 여직원들의 사원명, 주민번호, 급여 항목을 조회한다.
SELECT SANAME, JUBUN, SAL
FROM TBL_SAWON
WHERE JUBUN LIKE '______2%' OR JUBUN LIKE '______4%';
--==>>
/*
나주영	    9405022234567	2000
진윤비	    9710012234567	5000
권홍비	    9504102234567	4000
이하이	    0405064234567	1000
소이현	    0506074234567	1000
선우선	    9505052234567	4000
선우용녀	7512122234567	5000
*/


--○ 테이블 생성(TBL_WATCH)
CREATE TABLE TBL_WATCH
( WATCH_NAME    VARCHAR(20)
, BIGO          VARCHAR(100)
);
--==>> Table TBL_WATCH이(가) 생성되었습니다.

--○ 데이터 입력
INSERT INTO TBL_WATCH VALUES('금시계', '순금 99.99% 함유된 최고급 시계');
INSERT INTO TBL_WATCH VALUES('은시계', '고객 만족도 99.99점을 획득한 시계');
--==>> 1 행 이(가) 삽입되었습니다. *2

--○ 커밋
COMMIT;
--==>> 커밋 완료.


--○ 확인
SELECT *
FROM TBL_WATCH;
--==>>
/*
금시계	순금 99.99% 함유된 최고급 시계
은시계	고객 만족도 99.99점을 획득한 시계
*/

--○ TBL_WATCH 테이블의 BIGO 컬럼에
--   『99.99%』 라는 글자가 들어있는 행(레코드)의 정보를 조회한다.
SELECT *
FROM TBL_WATCH
WHERE BIGO LIKE '99.99%';
--==>> 조회 결과 없음

SELECT *
FROM TBL_WATCH
WHERE BIGO LIKE '%99.99%%';
--==>>
/*
금시계	순금 99.99% 함유된 최고급 시계
은시계	고객 만족도 99.99점을 획득한 시계
*/

SELECT *
FROM TBL_WATCH
WHERE BIGO LIKE '%99.99%';
--==>>
/*
금시계	순금 99.99% 함유된 최고급 시계
은시계	고객 만족도 99.99점을 획득한 시계
*/

SELECT *
FROM TBL_WATCH
WHERE BIGO LIKE '%99.99\%%' ESCAPE '\';
--==>> 금시계	순금 99.99% 함유된 최고급 시계

--※ ESCAPE 로 정한 문자의 다음 한 글자는 와일드캐릭터에서 탈출시켜라
--   『ESCAPE '\'』
--   일반적으로 사용빈도가 낮은 특수문자(특수기호)를 사용한다.


-----------------------------------------------------------------------------------------------------------------

--■■■ COMMIT / ROLLBACK ■■■--

SELECT *
FROM TBL_DEPT;
--==>>
/*
10	ACCOUNTING	NEW YORK
20	RESEARCH	DALLAS
30	SALES	    CHICAGO
40	OPERATIONS	BOSTON
*/

--○ 데이터 입력
INSERT INTO TBL_DEPT VALUES(50, '개발부', '서울');
--==>> 1 행 이(가) 삽입되었습니다.
-- 50번 개발부 서울
-- 이 데이터는 TBL_DEPT 테이블에 저장되어 있는
-- 하드디스크상에 물리적으로 적용되어 저장된 것이 아니라
-- 메모리(RAM)상에 입력된 것이다.

--○ 확인
SELECT *
FROM TBL_DEPT;

--○ 롤백
ROLLBACK;
--==>> 롤백 완료.

--○ 다시 확인
SELECT *
FROM TBL_DEPT;
--==>>
/*
10	ACCOUNTING	NEW YORK
20	RESEARCH	DALLAS
30	SALES	    CHICAGO
40	OPERATIONS	BOSTON
*/
--> 50번 개발부 서울 에 대한 데이터가 소실되었음을 확인(존재하지 않음)


--○ 다시 입력
INSERT INTO TBL_DEPT VALUES(50, '개발부', '서울');
--==>> 1 행 이(가) 삽입되었습니다.
--> 메모리상에 입력된 이 데이터를 실제 하드디스크상에 물리적으로 저장하기 위해서는
--  COMMIT 을 수행해야 한다.

--○ 확인
SELECT *
FROM TBL_DEPT;
--==>>
/*
10	ACCOUNTING	NEW YORK
20	RESEARCH	DALLAS
30	SALES	    CHICAGO
40	OPERATIONS	BOSTON
50	개발부	    서울
*/

--○ 커밋
COMMIT;
--==>> 커밋 완료.

--○ 커밋 이후 다시 확인
SELECT *
FROM TBL_DEPT;
--==>>
/*
10	ACCOUNTING	NEW YORK
20	RESEARCH	DALLAS
30	SALES	    CHICAGO
40	OPERATIONS	BOSTON
50	개발부	    서울
*/

--○ 롤백
ROLLBACK;
--==>> 롤백 완료.

--○ 롤백 이후 다시 확인
SELECT *
FROM TBL_DEPT;
--==>>
/*
10	ACCOUNTING	NEW YORK
20	RESEARCH	DALLAS
30	SALES	    CHICAGO
40	OPERATIONS	BOSTON
50	개발부	    서울
*/
--> 롤백(ROLLBACK)을 수행했음에도 불구하고
--  50번 개발부 서울 의 데이터는 소실되지 않았음을 확인

--※ COMMIT 을 실행한 이후로 DML 구문(INSERT, UPDATE, DELETE) 을 통해
--   변경된 데이터만 취소할 수 있는 것일 뿐
--   DML 명령을 사용한 후 COMMIT 하고 나서 ROLLBACK 을 실행해봐야
--   이전 상태로 되돌릴 수 없다. (아무런 소용이 없다.)

--○ 데이터 수정(TBL_DEPT)
UPDATE TBL_DEPT
SET DNAME='연구부', LOC='인천'
WHERE DEPTNO=50;
--==>> 1 행 이(가) 업데이트되었습니다.

--○ 확인
SELECT *
FROM TBL_DEPT;
--==>>
/*
10	ACCOUNTING	NEW YORK
20	RESEARCH	DALLAS
30	SALES	    CHICAGO
40	OPERATIONS	BOSTON
50	연구부 	    인천
*/

--○ 롤백
ROLLBACK;
--==>> 롤백 완료.

--○ 확인
SELECT *
FROM TBL_DEPT;
--==>>
/*
10	ACCOUNTING	NEW YORK
20	RESEARCH	DALLAS
30	SALES	    CHICAGO
40	OPERATIONS	BOSTON
50	개발부	    서울
*/
--> 수정(UPDATE)을 수행하기 이전 상태로 복원되었음을 확인

--○ 데이터 삭제(DELETE)
SELECT *
FROM TBL_DEPT
WHERE DEPTNO=50;
--==>> 50	개발부	서울

DELETE
FROM TBL_DEPT
WHERE DEPTNO=50;
--==>> 1 행 이(가) 삭제되었습니다.

--○ 확인
SELECT *
FROM TBL_DEPT;
--==>>
/*
10	ACCOUNTING	NEW YORK
20	RESEARCH	DALLAS
30	SALES	    CHICAGO
40	OPERATIONS	BOSTON
*/

--○ 롤백
ROLLBACK;
--==>> 롤백 완료.

--○ 다시 확인
SELECT *
FROM TBL_DEPT;
--==>>
/*
10	ACCOUNTING	NEW YORK
20	RESEARCH	DALLAS
30	SALES	    CHICAGO
40	OPERATIONS	BOSTON
50	개발부	    서울
*/
--> 삭제 구문을 수행하기 이전 상태로 복원되었음을 확인


----------------------------------------------------------------------------------------------------------

--■■■ 정렬(ORDER BY) 절 ■■■--
SELECT ENAME"사원명", DEPTNO"부서번호", JOB"직종명", SAL"급여", SAL*12+NVL(COMM, 0)"연봉"
FROM TBL_EMP;
--==>>
/*
SMITH	20	CLERK	     800	 9600
ALLEN	30	SALESMAN	1600	19500
WARD	30	SALESMAN	1250	15500
JONES	20	MANAGER	    2975	35700
MARTIN	30	SALESMAN	1250	16400
BLAKE	30	MANAGER	    2850	34200
CLARK	10	MANAGER	    2450	29400
SCOTT	20	ANALYST	    3000	36000
KING	10	PRESIDENT	5000	60000
TURNER	30	SALESMAN	1500	18000
ADAMS	20	CLERK	    1100	13200
JAMES	30	CLERK	     950	11400
FORD	20	ANALYST	    3000	36000
MILLER	10	CLERK	    1300	15600
*/

SELECT ENAME"사원명", DEPTNO"부서번호", JOB"직종명", SAL"급여", SAL*12+NVL(COMM, 0)"연봉", COMM"커미션"
FROM TBL_EMP
ORDER BY DEPTNO;    -- ASC → 오름차순 생략 가능
--==>>
/*
CLARK	10	MANAGER	    2450	29400	
KING	10	PRESIDENT	5000	60000	
MILLER	10	CLERK	    1300	15600	
JONES	20	MANAGER	    2975	35700	
FORD	20	ANALYST	    3000	36000	
ADAMS	20	CLERK	    1100	13200	
SMITH	20	CLERK	     800	 9600	
SCOTT	20	ANALYST	    3000	36000	
WARD	30	SALESMAN	1250	15500	500
TURNER	30	SALESMAN	1500	18000	0
*/


SELECT ENAME"사원명", DEPTNO"부서번호", JOB"직종명", SAL"급여", SAL*12+NVL(COMM, 0)"연봉", COMM"커미션"
FROM TBL_EMP
ORDER BY DEPTNO DESC;   -- DESC → 내림차순 생략 불가
--==>>
/*
BLAKE	30	MANAGER	    2850	34200	
TURNER	30	SALESMAN	1500	18000	   0
ALLEN	30	SALESMAN	1600	19500	 300
MARTIN	30	SALESMAN	1250	16400	1400
WARD	30	SALESMAN	1250	15500	 500
JAMES	30	CLERK	     950	11400	
SCOTT	20	ANALYST	    3000	36000	
JONES	20	MANAGER	    2975	35700	
SMITH	20	CLERK	     800	9600	
ADAMS	20	CLERK	    1100	13200	
FORD	20	ANALYST	    3000	36000	
KING	10	PRESIDENT	5000	60000	
MILLER	10	CLERK	    1300	15600	
CLARK	10	MANAGER	    2450	29400	
*/

SELECT ENAME"사원명", DEPTNO"부서번호", JOB"직종명", SAL"급여", SAL*12+NVL(COMM, 0)"연봉"
FROM TBL_EMP
ORDER BY 연봉 DESC;
--==>>
/*
KING	10	PRESIDENT	5000	60000
FORD	20	ANALYST	    3000	36000
SCOTT	20	ANALYST	    3000	36000
JONES	20	MANAGER	    2975	35700
BLAKE	30	MANAGER	    2850	34200
CLARK	10	MANAGER	    2450	29400
ALLEN	30	SALESMAN	1600	19500
TURNER	30	SALESMAN	1500	18000
MARTIN	30	SALESMAN	1250	16400
MILLER	10	CLERK	    1300	15600
WARD	30	SALESMAN	1250	15500
ADAMS	20	CLERK	    1100	13200
JAMES	30	CLERK	     950	11400
SMITH	20	CLERK	     800	 9600
*/
--> ORDER BY 절보다 SELECT 절이 먼저 처리되기 때문에
--  컬럼명 대신 SELECT 절에서 사용한 ALIAS(별칭)을
--  ORDER BY 절에서 사용해도 문제가 발생하지 않는다. (가능하다.)

SELECT ENAME"사원명", DEPTNO"부서 번호", JOB"직종명", SAL"급여", SAL*12+NVL(COMM, 0)"연봉"
FROM TBL_EMP
ORDER BY 부서 번호 DESC;
--==>> 에러 발생

SELECT ENAME"사원명", DEPTNO"부서 번호", JOB"직종명", SAL"급여", SAL*12+NVL(COMM, 0)"연봉"
FROM TBL_EMP
ORDER BY "부서 번호" DESC;
--==>>
/*
BLAKE	30	MANAGER	    2850	34200
TURNER	30	SALESMAN	1500	18000
ALLEN	30	SALESMAN	1600	19500
MARTIN	30	SALESMAN	1250	16400
WARD	30	SALESMAN	1250	15500
JAMES	30	CLERK	     950	11400
SCOTT	20	ANALYST	    3000	36000
JONES	20	MANAGER	    2975	35700
SMITH	20	CLERK	     800	 9600
ADAMS	20	CLERK	    1100	13200
FORD	20	ANALYST	    3000	36000
KING	10	PRESIDENT	5000	60000
MILLER	10	CLERK	    1300	15600
*/

SELECT ENAME"사원명", DEPTNO"부서 번호", JOB"직종명", SAL"급여", SAL*12+NVL(COMM, 0)"연봉"
FROM TBL_EMP
ORDER BY 2;
--==>>
/*
CLARK	10	MANAGER 	2450	29400
KING	10	PRESIDENT	5000	60000
MILLER	10	CLERK	    1300	15600
JONES	20	MANAGER	    2975	35700
FORD	20	ANALYST	    3000	36000
ADAMS	20	CLERK	    1100	13200
SMITH	20	CLERK	     800	9600
SCOTT	20	ANALYST	    3000	36000
WARD	30	SALESMAN	1250	15500
TURNER	30	SALESMAN	1500	18000
ALLEN	30	SALESMAN	1600	19500
JAMES	30	CLERK	     950	11400
BLAKE	30	MANAGER	    2850	34200
MARTIN	30	SALESMAN	1250	16400
*/
--> TBL_EMP 테이블이 갖고 있는 테이블의 고유한 컬럼의 순서가 아니라
--  SELECT 처리 되는 두 번째 컬럼 (즉, DEPTNO)을 기준으로 정렬되는 것을 확인
--  ASC 생략된 상태 → 오름차순 정렬되는 것을 확인

SELECT ENAME, DEPTNO, JOB, SAL
FROM TBL_EMP
ORDER BY 2, 4;  -- DETPNO 기준 1차 정렬, SAL 기준 2차 정렬 (ASC)
--==>>
/*
MILLER	10	CLERK	    1300
CLARK	10	MANAGER	    2450
KING	10	PRESIDENT	5000
SMITH	20	CLERK	     800
ADAMS	20	CLERK	    1100
JONES	20	MANAGER	    2975
SCOTT	20	ANALYST	    3000
FORD	20	ANALYST	    3000
JAMES	30	CLERK	     950
MARTIN	30	SALESMAN	1250
WARD	30	SALESMAN	1250
TURNER	30	SALESMAN	1500
ALLEN	30	SALESMAN	1600
BLAKE	30	MANAGER	    2850
*/


SELECT ENAME, DEPTNO, JOB, SAL
FROM TBL_EMP
ORDER BY 2, 3, 4 DESC;
--==>>
/*
MILLER	10	CLERK	    1300
CLARK	10	MANAGER	    2450
KING	10	PRESIDENT	5000
SCOTT	20	ANALYST	    3000
FORD	20	ANALYST	    3000
ADAMS	20	CLERK	    1100
SMITH	20	CLERK	     800
JONES	20	MANAGER	    2975
JAMES	30	CLERK	     950
BLAKE	30	MANAGER	    2850
ALLEN	30	SALESMAN	1600
TURNER	30	SALESMAN	1500
MARTIN	30	SALESMAN	1250
WARD	30	SALESMAN	1250
*/
--> ① DETPNO(부서번호) 기준 오름차순 정렬
--  ② JOB(직종명) 기준 오름차순 정렬
--  ③ SAL(급여) 기준 내림차순 정렬
--  (3차 정렬 수행)


----------------------------------------------------------------------------------------------------------------

--○ CONCAT() → 문자열 결합 함수
SELECT '전훈의' || '이지혜' "①", CONCAT('전훈의', '이지혜') "②"
FROM DUAL;
--==>> 전훈의이지혜	전훈의이지혜

SELECT ENAME||JOB"①", CONCAT(ENAME, JOB)"②"
FROM TBL_EMP;
--==>>
/*
SMITHCLERK	    SMITHCLERK
ALLENSALESMAN	ALLENSALESMAN
WARDSALESMAN	WARDSALESMAN
JONESMANAGER	JONESMANAGER
MARTINSALESMAN	MARTINSALESMAN
BLAKEMANAGER	BLAKEMANAGER
CLARKMANAGER	CLARKMANAGER
SCOTTANALYST	SCOTTANALYST
KINGPRESIDENT	KINGPRESIDENT
TURNERSALESMAN	TURNERSALESMAN
ADAMSCLERK	    ADAMSCLERK
JAMESCLERK	    JAMESCLERK
*/

SELECT ENAME || JOB || DEPTNO"①", CONCAT(ENAME, JOB, DEPTNO)"②"
FROM TBL_EMP;
--==>> 에러 발생
--> 2개의 문자열을 결합시켜주는 기능을 가진 함수.
--  오로지 2개만 결합시킬 수 있다.

SELECT ENAME || JOB || DEPTNO"①", CONCAT(CONCAT(ENAME, JOB), DEPTNO)"②"
FROM TBL_EMP;
--==>>
/*
SMITHCLERK20	    SMITHCLERK20
ALLENSALESMAN30	    ALLENSALESMAN30
WARDSALESMAN30	    WARDSALESMAN30
JONESMANAGER20	    JONESMANAGER20
MARTINSALESMAN30	MARTINSALESMAN30
BLAKEMANAGER30	    BLAKEMANAGER30
CLARKMANAGER10	    CLARKMANAGER10
SCOTTANALYST20	    SCOTTANALYST20
KINGPRESIDENT10	    KINGPRESIDENT10
TURNERSALESMAN30	TURNERSALESMAN30
ADAMSCLERK20	    ADAMSCLERK20
JAMESCLERK30	    JAMESCLERK30
FORDANALYST20	    FORDANALYST20
MILLERCLERK10	    MILLERCLERK10
*/

--> 내부적인 형 변환이 일어나며 결합을 수행하게 된다.
--  CONCAT()은 문자열과 문자열을 결합시켜주는 함수이지만
--  내부적으로는 숫자나 날짜를 문자타입으로 바꾸어주는 과정이 포함되어 있다.

/* JAVA SUBSTRING
/*
obj.substring()
---
→ 문자열.substring(n, m);
                    n부터 m-1까지 (0부터 시작하는 인덱스 기준)
*/

--○ SUBSTR() 갯수 기반 / SUBSTRB() 바이트 기반    → 문자열 추출 함수
SELECT ENAME"①"
    , SUBSTR(ENAME, 1, 2)"②"
    , SUBSTR(ENAME, 2, 2)"③"
    , SUBSTR(ENAME, 3, 2)"④"
    , SUBSTR(ENAME, 2)"⑤"
FROM TBL_EMP;
--> 문자열을 추출하는 기능을 가진 함수
--  첫 번째 파라미터 값은 대상 문자열(추출의 대상)
--  두 번째 파라미터 값은 추출을 시작하는 위치(단, 인덱스는 1부터 시작)
--  세 번째 파라미터 값은 추출할 문자열의 갯수(생략 시 시작위치 부터 끝까지)
/*
SMITH	SM	MI	IT	MITH
ALLEN	AL	LL	LE	LLEN
WARD	WA	AR	RD	ARD
JONES	JO	ON	NE	ONES
MARTIN	MA	AR	RT	ARTIN
BLAKE	BL	LA	AK	LAKE
CLARK	CL	LA	AR	LARK
SCOTT	SC	CO	OT	COTT
KING	KI	IN	NG	ING
TURNER	TU	UR	RN	URNER
*/

--○ TBL_SAWON 테이블에서 성별이 남성인 사원만
--   사원번호, 사원명, 주민번호, 급여 항목을 조회한다.
--   단, SUBSTR() 함수를 사용할 수 있도록 하며
--   급여 기준으로 내림차순 정렬을 수행하도록 한다.
SELECT SANO, SANAME, JUBUN, SAL
FROM TBL_SAWON
WHERE SUBSTR(JUBUN, 7, 1) IN ('1', '3')     -- JUBUN 문자타입 ' '  check
ORDER BY SAL DESC;
--==>>
/*
1015	이이경	8410141234567	5000
1014	남이	6912121234567	4000
1001	이원영	8706241234567	3000
1009	선동열	0505053234567	3000
1012	남상현	9302131234567	3000
1013	남궁선	7202021234567	2000
1005	이비승	7210101234567	2000
1006	조영우	8004271234567	2000
*/

SELECT *
FROM TBL_SAWON;


--○ LENGTH()/ LENGTHB()
SELECT ENAME"①"
    , LENGTH(ENAME)"②"
    , LENGTHB(ENAME)"③"
FROM TBL_EMP;
--> LENGTH()는 글자 수를 반환, LENGTHB() 는 바이트 수를 반환
--==>>
/*
SMITH	5	5
ALLEN	5	5
WARD	4	4
JONES	5	5
MARTIN	6	6
BLAKE	5	5
CLARK	5	5
SCOTT	5	5
KING	4	4
TURNER	6	6
ADAMS	5	5
JAMES	5	5
FORD	4	4
MILLER	6	6
*/

SELECT '이원영'"①"
     , LENGTH('이원영')"②"
     , LENGTHB('이원영')"③"
FROM DUAL;
--==>> 이원영	3	9

SELECT *
FROM NLS_DATABASE_PARAMETERS;


--○ INSTR()
SELECT 'ORACLE ORAHOME BIORA'"①"
     , INSTR('ORACLE ORAHOME BIORA', 'ORA', 1, 1)"②"
     , INSTR('ORACLE ORAHOME BIORA', 'ORA', 1, 2)"③"
     , INSTR('ORACLE ORAHOME BIORA', 'ORA', 2, 1)"④"
     , INSTR('ORACLE ORAHOME BIORA', 'ORA', 2)"⑤"
     , INSTR('ORACLE ORAHOME BIORA', 'ORA', 2, 2)"⑥"
FROM DUAL;
--> 첫 번째 파라미터 값에 해당하는 문자열에서 (대상 문자열)
--  두 번째 파라미터 값을 통해 넘겨준 문자열이 등장하는 위치를 찾아라
--  세 번째 파라미터 값은 찾기 시작하는 (즉, 스캔을 시작하는) 위치
--  네 번째 파라미터 값은 몇 번째 등장하는 값을 찾을 것인지에 대한 설정(1은 생략 가능)
--==>> ORACLE ORAHOME BIORA	1	8	8	8	18

SELECT '나의오라클 집으로오라 합니다'"①"
     , INSTR('나의오라클 집으로오라 합니다', '오라', 1)"②"
     , INSTR('나의오라클 집으로오라 합니다', '오라', 2)"③"
     , INSTR('나의오라클 집으로오라 합니다', '오라', 10)"④"
     , INSTR('나의오라클 집으로오라 합니다', '오라', 11)"⑤"
FROM DUAL;
-- 마지막 파라미터(네 번째 파라미터) 값을 생략한 경태로 사용 → 1
--==>> 나의오라클 집으로오라 합니다	3	3	10	0


--○ REVERSE()
SELECT 'ORACLE'"①"
     , REVERSE('ORACLE')"②"
     , REVERSE('오라클')"③"
FROM DUAL;
--> 대상 문자열을 거꾸로 반환한다. (단, 한글은 제외)
--==>> ORACLE	ELCARO	???


--○ 실습 대상 테이블 생성(TBL_FILES)
CREATE TABLE TBL_FILES
( FILENO    NUMBER(3)
, FILENAME  VARCHAR2(100)
);
--==>> Table TBL_FILES이(가) 생성되었습니다.

--○ 실습 데이터 입력
INSERT INTO TBL_FILES VALUES(1, 'C:\AAA\BBB\CCC\SALES.DOC');
INSERT INTO TBL_FILES VALUES(2, 'C:\AAA\PANMAE.XXLS');
INSERT INTO TBL_FILES VALUES(3, 'D:\RESEARCH.PPT');
INSERT INTO TBL_FILES VALUES(4, 'C:\DOCUMENTS\STUDY.HWP');
INSERT INTO TBL_FILES VALUES(5, 'C:\DOCUMENTS\TEMP\SQL.TXT');
INSERT INTO TBL_FILES VALUES(6, 'D:\SHARE\F\TEST.PNG');
INSERT INTO TBL_FILES VALUES(7, 'C:\USER\GUILDONG\PICTURE\PHOTO\SPRING.JPG');
INSERT INTO TBL_FILES VALUES(8, 'C:\ORACLESTUDY\20190328_01_SCOTT.SQL');
--==>> 1 행 이(가) 삽입되었습니다. * 8

--○ 확인
SELECT *
FROM TBL_FILES;
--==>>
/*
1	C:\AAA\BBB\CCC\SALES.DOC
2	C:\AAA\PANMAE.XXLS
3	D:\RESEARCH.PPT
4	C:\DOCUMENTS\STUDY.HWP
5	C:\DOCUMENTS\TEMP\SQL.TXT
6	D:\SHARE\F\TEST.PNG
7	C:\USER\GUILDONG\PICTURE\PHOTO\SPRING.JPG
8	C:\ORACLESTUDY\20190328_01_SCOTT.SQL
*/

--○ 커밋
COMMIT;
--==>> 커밋 완료.


SELECT FILENO"파일번호", FILENAME"파일명"
FROM TBL_FILES;
--==>>
/*
      파일번호 파일명                                                                                                 
---------- ----------------------------------------------------------------------------------------------------
         1 C:\AAA\BBB\CCC\SALES.DOC                                                                            
         2 C:\AAA\PANMAE.XXLS                                                                                  
         3 D:\RESEARCH.PPT                                                                                     
         4 C:\DOCUMENTS\STUDY.HWP                                                                              
         5 C:\DOCUMENTS\TEMP\SQL.TXT                                                                           
         6 D:\SHARE\F\TEST.PNG                                                                                 
         7 C:\USER\GUILDONG\PICTURE\PHOTO\SPRING.JPG                                                           
         8 C:\ORACLESTUDY\20190328_01_SCOTT.SQL  
*/

--○ TBL_FILES 테이블 대상으로 위와 같이 조회될 수 있도록 
--   쿼리문을 구성한다.
SELECT FILENO"파일번호"
    , SUBSTR(FILENAME, LENGTH(FILENAME)-INSTR(REVERSE(FILENAME), '\')+2)"파일명"
FROM TBL_FILES;
--==>>
/*
  파일번호 파일명                                                                                                 
---------- -------------------------------
         1 SALES.DOC                                                                                           
         2 PANMAE.XXLS                                                                                         
         3 RESEARCH.PPT                                                                                        
         4 STUDY.HWP                                                                                           
         5 SQL.TXT                                                                                             
         6 TEST.PNG                                                                                            
         7 SPRING.JPG                                                                                          
         8 20190328_01_SCOTT.SQL
*/

--선생님 풀이
SELECT FILENO"파일번호", FILENAME"경로포함파일명"
     , SUBSTR(FILENAME, 16, 9)"파일명"
FROM TBL_FILES
WHERE FILENO=1;
--==>>1   C:\AAA\BBB\CCC\SALES.DOC   SALES.DOC

SELECT FILENO"파일번호", FILENAME"경로포함파일명"
     , REVERSE(FILENAME)"거꾸로된파일명"
FROM TBL_FILES;

SELECT FILENO"파일번호", FILENAME"경로포함파일명"
     , SUBSTR(REVERSE(FILENAME),1,최초'\'가 등장하는위치-1)"거꾸로된파일명"
FROM TBL_FILES;

--최초'\'가 등장하는위치
INSTR(REVERSE(FILENAME),'\',1)  -- 마지막 매개변수 1생략

SELECT FILENO"파일번호"
     , SUBSTR(REVERSE(FILENAME),1,INSTR(REVERSE(FILENAME),'\',1)-1)"거꾸로된파일명"
FROM TBL_FILES;

SELECT FILENO"파일번호"
     , REVERSE(SUBSTR(REVERSE(FILENAME),1,INSTR(REVERSE(FILENAME),'\',1)-1))"파일명"
FROM TBL_FILES;
--==>>
/*
1   SALES.DOC
2   PANMAE.XXLS
3   RESEARCH.PPT
4   STUDY.HWP
5   SQL.TXT
6   TEST.PNG
7   SPRING.JPG
8   20190328_01_SCOTT.SQL
*/


--○ LPAD()
--> Byte 공간을 확보하여 왼쪽부터 문자로 채우는 기능을 가진 함수
SELECT 'ORACLE'"①"
     , LPAD('ORACLE', 10, '*')"②"
FROM DUAL;
--==>> ORACLE	****ORACLE
--> ① 10Byte 공간을 확보한다.                  → 두 번째 파라미터 값에 의해
--  ② 확보한 공간에 'ORACLE' 문자열을 담는다.  → 첫 번째 파라미터 값에 의해
--  ③ 남아있는 Byte 공간을 왼쪽부터 세 번 파라미터 값으로 채운다.
--  ④ 이렇게 구성된 최종 결과값을 반환한다.


--○ RPAD()
SELECT 'ORACLE'"①"
     , RPAD('ORACLE', 10, '*')"②"
FROM DUAL;
--==>> ORACLE	ORACLE****
--> ① 10Byte 공간을 확보한다.                  → 두 번째 파라미터 값에 의해
--  ② 확보한 공간에 'ORACLE' 문자열을 담는다.  → 첫 번째 파라미터 값에 의해
--  ③ 남아있는 Byte 공간을 오른쪽부터 세 번 파라미터 값으로 채운다.
--  ④ 이렇게 구성된 최종 결과값을 반환한다.


--○ LTRIM()
SELECT 'ORAORAORACLEORACLE'"①"
     , LTRIM('ORAORAORACLEORACLE', 'ORA')"②"
     , LTRIM('AAAORAORAORACLEORACLE', 'ORA')"③"
     , LTRIM('ORAoRAORACLEORACLE', 'ORA')"④"
     , LTRIM('ORA ORAORACLEORACLE', 'ORA')"⑤"
     , LTRIM('              ORACLE')"⑥" -- 왼쪽 공백 제거 함수로 활용(두 번째 파라미터 생략)
FROM DUAL;
--==>> 
/*
ORAORAORACLEORACLE	
CLEORACLE	
CLEORACLE	
oRAORACLEORACLE	 
 ORAORACLEORACLE
ORACLE
*/
--> 첫 번째 파라미터 값에 해당하는 문자열을 대상으로
--  왼쪽부터 연속적으로 두 번째 파라미터 값에서 지정한 글자와 같은 글자가 등장할 경우
--  이를 제거한 결과값을 반환한다.
--  단, 완성형으로 처리되지 않는다.
SELECT LTRIM('이김신이김신이이신신김이신이이김김이신박이김신', '이김신')"TEST"
FROM DUAL;
--==>> 박이김신

--○ RTRIM
SELECT 'ORAORAORACLEORACLE'"①"
     , RTRIM('ORAORAORACLEORACLE', 'ORA')"②"
     , RTRIM('AAAORAORAORACLEORACLE', 'ORA')"③"
     , RTRIM('ORAoRAORACLEORACLE', 'ORA')"④"
     , RTRIM('ORA ORAORACLEORACLE', 'ORA')"⑤"
     , RTRIM('ORACLE              ')"⑥" -- 오른쪽 공백 제거 함수로 활용(두 번째 파라미터 생략)
FROM DUAL;
--==>>
/*
ORAORAORACLEORACLE	
ORAORAORACLEORACLE	
AAAORAORAORACLEORACLE	
ORAoRAORACLEORACLE	
ORA ORAORACLEORACLE	
ORACLE
*/
--> 첫 번째 파라미터 값에 해당하는 문자열을 대상으로
--  오른쪽부터 연속적으로 두 번째 파라미터 값에서 지정한 글자와 같은 글자가 등장할 경우
--  이를 제거한 결과값을 반환한다.
--  단, 완성형으로 처리되지 않는다.


--○ TRANSLATE()
--> 1:1 로 바꾸어준다.
SELECT TRANSLATE('MY ORACLE SERVER', 'ABCDEFGHIJKLMNOPQRSTUVWXYZ', 'abcdefghijklmnopqrstuvwxyz')
FROM DUAL;

SELECT TRANSLATE('010-6575-2297', '0123456789', '영일이삼사오육칠팔구')
FROM DUAL;
--==>> 영일영-육오칠오-이이구칠


--○ REPLACE()
SELECT REPLACE('MY ORACLE ORAHOME', 'ORA', '오라')
FROM DUAL;
--==>> MY 오라CLE 오라HOME




=== 20190329_01_scott.sql === 

SELECT USER
FROM DUAL;
--==>> SCOTT

--○ ROUND() 반올림을 처리해주는 함수
SELECT 48.678 "①"
     , ROUND(48.678, 2) "②"     -- 소수점 이하 둘째자리까지 표현(셋째자리에서 반올림)
     , ROUND(48.674, 2) "③"
     , ROUND(48.674, 1) "④"
     , ROUND(48.674, 0) "⑤"
     , ROUND(48.674) "⑥"        -- 두 번째 파라미터 값이 0일 경우 생략 가능
     , ROUND(48.674, -1) "⑦"
     , ROUND(48.674, -2) "⑧"
     , ROUND(48.674, -3) "⑨"
FROM DUAL;
--==>> 48.678	48.68	48.67	48.7	49	49	50	0	0


--○ TRUNC() 절삭을 처리해주는 함수
SELECT 48.678 "①"
     , TRUNC(48.678, 2) "②"     -- 소수점 이하 둘째자리까지 표현
     , TRUNC(48.674, 2) "③"
     , TRUNC(48.678, 1) "④"
     , TRUNC(48.678, 0) "⑤"
     , TRUNC(48.678) "⑥"
     , TRUNC(48.678, -1) "⑦"
     , TRUNC(48.678, -2) "⑧"
     , TRUNC(48.678, -3) "⑨"
FROM DUAL;
--==>> 48.678	48.67	48.67	48.6	48	48	40	0	0


--○ MOD() 나머지를 반환하는 함수
SELECT MOD(5, 2)
FROM DUAL;
--> 5를 2로 나눈 나머지 결과값 반환
--==>> 1


--○ POWER() 제곱의 결과를 반환하는 함수
SELECT POWER(5, 3)
FROM DUAL;
--==>> 125
--> 5의 3승을 결과값으로 반환


--○ SQRT() 루트 결과값을 반환하는 함수
SELECT SQRT(2)
FROM DUAL;
--==>> 1.41421356237309504880168872420969807857
--> 루트 2 에 대한 결과값


--○ LOG() 로그 함수
--   (※ 오라클은 상용로그만 지원하는 반면, MYSQL 은 상용로그, 자연로그 모두 지원한다.
SELECT LOG(10, 100), LOG(10, 20)
FROM DUAL;
--==>> 2	1.30102999566398119521373889472449302677


--○ 삼각 함수
--   싸인, 코싸인, 탄젠트 결과값을 반환한다.
SELECT SIN(1), COS(1), TAN(1)
FROM DUAL;
--==>> 
/*
0.8414709848078965066525023216302989996233	
0.5403023058681397174009366074429766037354	
1.55740772465490223050697480745836017308
*/


--○ 삼각함수의 역함수 (범위 : -1 ~ 1)
--   어싸인, 어코싸인, 어탄젠트 결과값을 반환한다.
SELECT ASIN(0.5), ACOS(0.5), ATAN(0.5)
FROM DUAL;
--==>> 
/*
0.52359877559829887307710723054658381405	
1.04719755119659774615421446109316762805	
0.4636476090008061162142562314612144020295
*/


--○ SIGN()      서명, 부호, 특징
-->  연산 결과가 양수이면 1, 0이면 0, 음수이면 -1을 반환한다.
SELECT SIGN(5-2), SIGN(5-5), SIGN(5-7)
FROM DUAL;
--==>> 1	0	-1
--> 매출이나 수지와 관련하여 적자 및 흑자의 개념을 나타낼  주로 사용한다.


--○ ASCII(), CHR() → 서로 상응하는 개념의 함수
SELECT ASCII('A'), CHR(65)
FROM DUAL;
--==>> 65	A
--> ASCII() : 매개변수로 넘겨받은 문자의 아스키코드 값을 반환한다.
--  CHR()   : 매개변수로 넘겨받은 숫자를 아스키코드 값으로 취하는 문자를 반환한다.


---------------------------------------------------------------------------------------------------------------------------

--※ 날짜 관련 세선 설정 변셩
ALTER SESSION SET NLS_DATE_FORMAT = 'YYYY-MM-DD HH24:MI:SS';
--==>> Session이(가) 변경되었습니다.


--※ 날짜 연산의 기본 단위는 DAY(일수)이다!!
SELECT SYSDATE, SYSDATE+1, SYSDATE-2, SYSDATE-29
FROM DUAL;
--==>> 
/*
2019-03-29 09:28:54     -- 현재
2019-03-30 09:28:54	    -- 1일 후
2019-03-27 09:28:54	    -- 2일 전
2019-02-28 09:28:54     -- 29일 전
*/


--○ 시간 단위 연산
SELECT SYSDATE, SYSDATE + 1/24, SYSDATE - 2/24
FROM DUAL;
--==>>
/*
2019-03-29 09:31:00	    -- 현재
2019-03-29 10:31:00	    -- 1시간 후
2019-03-29 07:31:00     -- 2시간 전
*/


--○ 현재 시간과 현재 시간 기준 1일 2시간 3분 4초 후를 조회한다.
SELECT SYSDATE"현재 시간", SYSDATE +1 +2/24 + 3/24/60 + 4/24/60/60"연산 후 시간"
FROM DUAL;
/*
현재 시간               연산 후 시간            
------------------- -------------------
2019-03-29 09:37:46 2019-03-30 11:40:50
*/

-- 방법1.
SELECT SYSDATE"현재 시간"
     , SYSDATE + 1 + (2/24) + (3/(24*60)) + (4/(24*60*60))"연산 후 시간"
FROM DUAL;
--==>> 2019-03-29 09:40:59	2019-03-30 11:44:03

-- 방법2.
SELECT SYSDATE"현재 시간"
     , SYSDATE + ((24*60*60) + (2*60*60) + (3*60) +4) / (24*60*60)"연산 후 시간"
     --             1일          2시간       3분   4초
FROM DUAL;
--==>> 2019-03-29 09:44:32	2019-03-30 11:47:36


--○ 날짜 - 날짜 = 일수
-- ex) (2019-07-18) - (2019-03-29)
--        수료일         현재일
SELECT TO_DATE('2019-07-18', 'YYYY-MM-DD') - TO_DATE('2019-03-29', 'YYYY-MM-DD')
FROM DUAL;
-==>> 111


--○ 데이터 타입의 변환
SELECT TO_DATE('2019-03-29', 'YYYY-MM-DD')
FROM DUAL;

SELECT TO_DATE('2019-02-29', 'YYYY-MM-DD')
FROM DUAL;
--==>> 에러 발생
/*
ORA-01839: date not valid for month specified
01839. 00000 -  "date not valid for month specified"
*Cause:    
*Action:
*/
--> 지정한 월의 날짜 부적합

SELECT TO_DATE('2019-13-29', 'YYYY-MM-DD')
FROM DUAL;
--==>> 에러 발생
/*
ORA-01843: not a valid month
01843. 00000 -  "not a valid month"
*Cause:    
*Action:
*/
--> 지정한 월에 대한 부적합 에러

--※ TO_DATE() 함수를 통해 문자 타입을 날짜 타입으로 변환을 진행할 때
--   내부적으로 해당 날짜에 대한 유효성 검사가 이루어진다.


--○ ADD_MONTHS() 개월 수를 더해주는 함수
SELECT SYSDATE "1"
     , ADD_MONTHS(SYSDATE, 2) "2"
     , ADD_MONTHS(SYSDATE, 3) "3"
     , ADD_MONTHS(SYSDATE, -2) "4"
     , ADD_MONTHS(SYSDATE, -3) "5"
FROM DUAL;
--==>>
/*
2019-03-29 10:05:22	    → 현재
2019-05-29 10:05:22	    → 2개월 후
2019-06-29 10:05:22	    → 3개월 후
2019-01-29 10:05:22	    → 2개월 전
2018-12-29 10:05:22     → 3개월 전
*/
--> 월을 더하고 빼기


--※ 날짜 세션 설정 변경
ALTER SESSION SET NLS_DATE_FORMAT = 'YYYY-MM-DD';
--==>> Session이(가) 변경되었습니다.


--○ MONTHS_BETWEEN()
-- 첫 번째 인자값에서 두 번째 인자값을 뺀 개월 수를 반환
SELECT MONTHS_BETWEEN(SYSDATE, TO_DATE('2002-05-31', 'YYYY-MM-DD'))
FROM DUAL;
--==>> 201.949145385304659498207885304659498208

--> 개월 수의 차이를 반환하는 함수
--  ※ 결과값의 부호가 『-』로 반환되었을 경우에는
--     첫 번째 인자값에 해당하는 날짜보다
--     두 번째 인자값에 해당하는 날짜가 『미래』라는 의미로 확인할 수 있다.

SELECT MONTHS_BETWEEN(SYSDATE, TO_DATE('2019-07-18', 'YYYY-MM-DD'))
FROM DUAL;
--==>> -3.63145198626045400238948626045400238949


--○ NEXT_DAY()
-- 첫 번째 인자값을 기준 날짜로 돌아오는 가장 빠른 요일 반환
SELECT NEXT_DAY(SYSDATE,'토'), NEXT_DAY(SYSDATE, '월')
FROM DUAL;
--==>> 2019-03-30	2019-04-01


--※ 추가 세션 설정 변경 
ALTER SESSION SET NLS_DATE_LANGUAGE = 'ENGLISH';
--==>> Session이(가) 변경되었습니다.

--○ 세션 설정 변경한 이후 위의 퀴리문을 다시 한 번 조회
SELECT NEXT_DAY(SYSDATE,'토'), NEXT_DAY(SYSDATE, '월')
FROM DUAL;
--==>> 에러 발생
/*
ORA-01846: not a valid day of the week
01846. 00000 -  "not a valid day of the week"
*Cause:    
*Action:
*/

SELECT NEXT_DAY(SYSDATE, 'SAT'), NEXT_DAY(SYSDATE, 'MON')
FROM DUAL;
--==>> 2019-03-30	2019-04-01


--○ 추가 세션 설정 변경
ALTER SESSION SET NLS_DATE_LANGUAGE='KOREAN';
--==>> Session이(가) 변경되었습니다.


--○ LAST_DAY()
-- 해당 날짜가 포함되어 있는 그 달의 마지막 날을 반환한다.
SELECT LAST_DAY(SYSDATE)
FROM DUAL;
--==>> 2019-03-31

SELECT LAST_DAY(TO_DATE('2019-02-01', 'YYYY-MM-DD'))
FROM DUAL;
--==>> 2019-02-28


--○ 오늘 부로 김정규 님이 군대에 또 끌려(?)간다.
--   복무 기간은 22개월로 한다.

-- 1. 전역 일자를 구한다.
SELECT ADD_MONTHS(SYSDATE, 22)"전역 일자"
FROM DUAL;
--==>> 2021-01-29

-- 2. 하루 꼬박꼬박 3끼 식사를 해야 한다고 가정하면
--    정규가 몇끼를 먹어야 집에 보내줄까.

--    복무기간 * 3
--    --------
--    (전역일자 - 현재일자)

--    (전역일자 - 현재일자) * 3

SELECT (ADD_MONTHS(SYSDATE, 22) - SYSDATE) * 3
FROM DUAL;
--==>> 2016


--○ 현재 날짜 및 시각으로부터 수료일(2019-07-18 18:00:00) 까지
--   남은 기간을 다음과 같은 형태로 조회할 수 있도록 한다.
ALTER SESSION SET NLS_DATE_FORMAT = 'YYYY-MM-DD HH24:MI:SS';
--==>> Session이(가) 변경되었습니다.

SELECT SYSDATE"현재 시각", TO_DATE('2019-07-18 18:00:00')"수료일"
     , TRUNC(TO_DATE('2019-07-18 18:00:00', 'YYYY-MM-DD HH24:MI:SS') - TO_DATE(SYSDATE), 0)"일"
     , TRUNC((TO_DATE('2019-07-18 18:00:00', 'YYYY-MM-DD HH24:MI:SS') - SYSDATE - TRUNC(TO_DATE('2019-07-18 18:00:00', 'YYYY-MM-DD HH24:MI:SS') - SYSDATE))*24)"시간"
     , TRUNC(((TO_DATE('2019-07-18 18:00:00', 'YYYY-MM-DD HH24:MI:SS') - SYSDATE - TRUNC(TO_DATE('2019-07-18 18:00:00', 'YYYY-MM-DD HH24:MI:SS') - SYSDATE))*24 
        - TRUNC((TO_DATE('2019-07-18 18:00:00', 'YYYY-MM-DD HH24:MI:SS') - SYSDATE - TRUNC(TO_DATE('2019-07-18 18:00:00', 'YYYY-MM-DD HH24:MI:SS') - SYSDATE))*24))*60)"분" 
     ,TRUNC(((((TO_DATE('2019-07-18 18:00:00', 'YYYY-MM-DD HH24:MI:SS') - SYSDATE - TRUNC(TO_DATE('2019-07-18 18:00:00', 'YYYY-MM-DD HH24:MI:SS') - SYSDATE))*24 
        - TRUNC((TO_DATE('2019-07-18 18:00:00', 'YYYY-MM-DD HH24:MI:SS') - SYSDATE - TRUNC(TO_DATE('2019-07-18 18:00:00', 'YYYY-MM-DD HH24:MI:SS') - SYSDATE))*24))*60)
        - (TRUNC(((TO_DATE('2019-07-18 18:00:00', 'YYYY-MM-DD HH24:MI:SS') - SYSDATE - TRUNC(TO_DATE('2019-07-18 18:00:00', 'YYYY-MM-DD HH24:MI:SS') - SYSDATE))*24 
        - TRUNC((TO_DATE('2019-07-18 18:00:00', 'YYYY-MM-DD HH24:MI:SS') - SYSDATE - TRUNC(TO_DATE('2019-07-18 18:00:00', 'YYYY-MM-DD HH24:MI:SS') - SYSDATE))*24))*60)))*60)"초"
FROM DUAL;


-- 『1일 2시간 3분 4초』 를 『초』로 환산
SELECT (1*24*60*60) + (2*60*60) + (3*60) +(4)
FROM DUAL;
--==>> 93784


-- 『93784』초를 다시 일, 시간, 분, 초로 환산하면
SELECT MOD(93784, 60)
FROM DUAL;
--==>> 4

SELECT TRUNC(TRUNC(TRUNC(93784/60)/60)/24)
     , MOD(TRUNC(TRUNC(93784/60)/60), 24)
     , MOD(TRUNC(93784/60), 60)
     , MOD(93784, 60)
FROM DUAL;
--==>> 1	2	3	4


-- 수료일까지 남은 기간 확인(날짜 기준) → 단위 : 일수
SELECT 수료일자 - 현재일자
FROM DUAL;

-- 수료일자
SELECT TO_DATE('2019-07-18 18:00:00', 'YYYY-MM-DD HH24:MI:SS')
FROM DUAL;
--==>> 2019-07-18 18:00:00 → 날짜 형식


SELECT TO_DATE('2019-07-18 18:00:00', 'YYYY-MM-DD HH24:MI:SS') - SYSDATE
FROM DUAL;
--==>> 111.238287037037037037037037037037037037 일
--> 수료일까지 남은 일수


-- 수료일까지 남은 기간 확인(날짜 기준) → 단위 : 초
SELECT (수료일까지 남은 일수) * (하루를 구성하는 전체 초)
FROM DUAL;

SELECT (수료일까지 남은 일수) * (24*60*60)
FROM DUAL;

SELECT (TO_DATE('2019-07-18 18:00:00', 'YYYY-MM-DD HH24:MI:SS') - SYSDATE) * (24*60*60)
FROM DUAL;
--==>> 9610790.99999999999999999999999999999996


SELECT TRUNC(TRUNC(TRUNC((TO_DATE('2019-07-18 18:00:00', 'YYYY-MM-DD HH24:MI:SS') - SYSDATE) * (24*60*60)/60)/60)/24)"일"
     , MOD(TRUNC(TRUNC((TO_DATE('2019-07-18 18:00:00', 'YYYY-MM-DD HH24:MI:SS') - SYSDATE) * (24*60*60)/60)/60), 24)"시"
     , MOD(TRUNC((TO_DATE('2019-07-18 18:00:00', 'YYYY-MM-DD HH24:MI:SS') - SYSDATE) * (24*60*60)/60), 60)"분"
     , TRUNC(MOD((TO_DATE('2019-07-18 18:00:00', 'YYYY-MM-DD HH24:MI:SS') - SYSDATE) * (24*60*60), 60))"초"
FROM DUAL;


--○ 문제
-- 본인이 태어나서 현재까지 얼마만큼의 일, 시간, 분, 초를 살았는지 (살고있는지)
-- 조회한다. (1996-10-01 17:00:00)
SELECT SYSDATE"현재 시각", TO_DATE('1996-10-01 17:00:00', 'YYYY-MM-DD HH24:MI:SS')"태어난 시각"
     , TRUNC(TRUNC(TRUNC(TRUNC((SYSDATE - TO_DATE('1996-10-01 17:00:00', 'YYYY-MM-DD HH24:MI:SS')) * (24*60*60)/60)/60)/24)/365)"년"
     , MOD(TRUNC(TRUNC(TRUNC((SYSDATE - TO_DATE('1996-10-01 17:00:00', 'YYYY-MM-DD HH24:MI:SS')) * (24*60*60)/60)/60)/24), 365)"일"
     , MOD(TRUNC(TRUNC((SYSDATE - TO_DATE('1996-10-01 17:00:00', 'YYYY-MM-DD HH24:MI:SS')) * (24*60*60)/60)/60), 24)"시"
     , MOD(TRUNC(((SYSDATE - TO_DATE('1996-10-01 17:00:00', 'YYYY-MM-DD HH24:MI:SS')) * (24*60*60)/60)), 60)"분"
     , MOD((SYSDATE - TO_DATE('1996-10-01 17:00:00', 'YYYY-MM-DD HH24:MI:SS')) * (24*60*60), 60)"초"
FROM DUAL;
--==>>
/*
    현재 시각           태어난 시각             년         일         시         분         초
------------------- ------------------- ---------- ---------- ---------- ---------- ----------
2019-03-29 12:42:12 1996-10-01 17:00:00         22        183         19         42         12
*/


--○ 날짜 형식 세션 설정 변경
ALTER SESSION SET NLS_DATE_FORMAT = 'YYYY-MM-DD';
--==>> Session이(가) 변경되었습니다.


--※ 날짜 데이터를 대상으로 반올림, 절삭을 수행할 수 있다.

--○ 날짜 반올림
SELECT SYSDATE "1"                      -- 2019-03-29   → 기본 현재 날짜
     , ROUND(SYSDATE, 'YEAR') "2"       -- 2019-01-01   → 년도까지 유효한 데이터 (상반기, 하반기 기준)
     , ROUND(SYSDATE, 'MONTH') "3"      -- 2019-04-01   → 월까지 유효한 데이터 (15일 기준)
     , ROUND(SYSDATE, 'DD') "4"         -- 2019-03-30   → 날짜까지 유효한 데이터 (정오 기준)
     , ROUND(SYSDATE, 'DAY') "5"        -- 2019-03-31   → 날짜까지 유효한 데이터 (수요일 기준(수→목) 무조건 일요일)
FROM DUAL;


--○ 날짜 절삭
SELECT SYSDATE "1"                      -- 2019-03-29   → 기본 현재 날짜
     , TRUNC(SYSDATE, 'YEAR') "2"       -- 2019-01-01   → 년도까지 유효한 데이터
     , TRUNC(SYSDATE, 'MONTH') "3"      -- 2019-03-01   → 월까지 유효한 데이터
     , TRUNC(SYSDATE, 'DD') "4"         -- 2019-03-29   → 날짜까지 유효한 데이터
     , TRUNC(SYSDATE, 'DAY') "5"        -- 2019-03-24   → 날짜까지 유효한 데이터
FROM DUAL;


---------------------------------------------------------------------------------------------------------------------------

--■■■ 변환 함수 ■■■--

-- TO_CHAR()    : 숫자나 날짜 데이터를 문자 타입으로 변환시켜주는 함수
-- TO_DATE()    : 문자 데이터(날짜 형식)를 날짜 타입으로 변환시켜주는 함수
-- TO_NUMBER()  : 문자 데이터(숫자 형식)를 숫자 타입으로 변환시켜주는 함수

--※ 날짜나 통화 형식이 맞지 않을 경우
--   세션 설정값을 통해 설정할 수 있도록 한다.

ALTER SESSION SET NLS_LANGUAGE = 'KOREAN';
--==>> Session이(가) 변경되었습니다.

ALTER SESSION SET NLS_DATE_LANGUAGE = 'KOREAN';
--==>> Session이(가) 변경되었습니다.

ALTER SESSION SET NLS_CURRENCY = '\';   -- 원
--==>> Session이(가) 변경되었습니다.

ALTER SESSION SET NLS_DATE_FORMAT = 'YYYY-MM-DD';
--==>> Session이(가) 변경되었습니다.

SELECT TO_CHAR(SYSDATE, 'YYYY-MM-DD')   -- 2019-03-29
     , TO_CHAR(SYSDATE, 'YYYY')         -- 2019             → 문자타입
     , TO_CHAR(SYSDATE, 'YEAR')         -- TWENTY NINETEEN
     , TO_CHAR(SYSDATE, 'MM')           -- 03
     , TO_CHAR(SYSDATE, 'MONTH')        -- 3월 
     , TO_CHAR(SYSDATE, 'MON')          -- 3월 
     , TO_CHAR(SYSDATE, 'DD')           -- 29
     , TO_CHAR(SYSDATE, 'DAY')          -- 금요일
     , TO_CHAR(SYSDATE, 'DY')           -- 금
     , TO_CHAR(SYSDATE, 'HH24')         -- 14
     , TO_CHAR(SYSDATE, 'HH')           -- 02
     , TO_CHAR(SYSDATE, 'HH AM')        -- 02 오후
     , TO_CHAR(SYSDATE, 'HH PM')        -- 02 오후
     , TO_CHAR(SYSDATE, 'MI')           -- 20
     , TO_CHAR(SYSDATE, 'SS')           -- 27
     , TO_CHAR(SYSDATE, 'SSSSS')        -- 51627            → 자정12시부터 지금까지의 흘러온 전체 초
     , TO_CHAR(SYSDATE, 'Q')            -- 1                → 분기
FROM DUAL;


SELECT TO_CHAR(4), '4'
FROM DUAL;
--==>> 4	4   (우측정렬, 숫자타입)


SELECT '04', TO_NUMBER('04')
FROM DUAL;
--==>> 04	4   (좌측정렬, 문자타입)

SELECT TO_NUMBER(TO_CHAR(SYSDATE, 'YYYY'))
FROM DUAL;
--==>> 2019 (우측정렬, 숫자타입)


--○ EXTRACT()
SELECT TO_CHAR(SYSDATE, 'YYYY')     -- 2019 (좌측)    → 연도를 추출하여 문자타입으로
     , TO_CHAR(SYSDATE, 'MM')       -- 03   (좌측)    → 월을 추출하여 문자타입으로
     , TO_CHAR(SYSDATE, 'DD')       -- 29   (좌측)    → 일을 추출하여 문자타입으로
     , EXTRACT(YEAR FROM SYSDATE)   -- 2019 (우측)    → 연도를 추출하여 숫자타입으로
     , EXTRACT(MONTH FROM SYSDATE)  -- 3    (우측)    → 월을 추출하여 숫자타입으로
     , EXTRACT(DAY FROM SYSDATE)    -- 29   (우측)    → 일을 추출하여 숫자타입으로
FROM DUAL;
--> 년, 월, 일 이하 다른 것은 불가


--○ TO_CHAR() 활용 → 형식 맞춤 표기 결과값 반환
SELECT 60000                            -- 60000
     , TO_CHAR(60000)                   -- 60000    (숫자 → 문자)
     , TO_CHAR(60000, '99,999')         -- 60,000
     , TO_CHAR(60000, '$99,999')        -- $60,000
     , TO_CHAR(60000, 'L99,999')        --           \60,000  (원)
     , LTRIM(TO_CHAR(60000, 'L99,999')) -- \60,000  (공백제거)
FROM DUAL;

--○ 날짜 세션 설정 변경
ALTER SESSION SET NLS_DATE_FORMAT = 'YYYY-MM-DD HH24:MI:SS';
-==>> Session이(가) 변경되었습니다.


--○ 현재 시간을 기준으로 1일 2시간 3분 4초 후를 조회한다.
SELECT SYSDATE"현재 시각"
     , SYSDATE +1 + (2/24) + (3/(24*60)) + (4/(24*60*60)) "1일 2시간 3분 4초 후"
FROM DUAL;
--==>> 
/*
2019-03-29 14:47:00	
2019-03-30 16:50:04
*/

--○ 현재 시간을 기준으로 1년 2개월 3일 4시간 5분 6초 후를 조회한다.
-- TO_YMINTERVAL(), TO_DSINTERVAL()
SELECT SYSDATE"현재시각"
    , SYSDATE + TO_YMINTERVAL('01-02') + TO_DSINTERVAL('003 04:05:06')"연산결과"
FROM DUAL;
--==>>
/*
2019-03-29 14:51:00	
2020-06-01 18:56:06
*/


-------------------------------------------------------------------------------------------------------------------

--○ CASE 구문 (조건문, 분기문)
/*
CASE
WHEN
THEN
ELSE
END
*/

SELECT CASE 5+2 WHEN 7 THEN '5+2=7' ELSE '5+2=?' END "결과 확인"
FROM DUAL;
--==>> 5+2=7

SELECT CASE 5+2 WHEN 9 THEN '5+2=9' ELSE '5+2=?' END"결과 확인"
FROM DUAL;
--==>> 5+2=?

SELECT CASE 1+1 WHEN 2 THEN '1+1=2' 
                WHEN 3 THEN '1+1=3'
                WHEN 4 THEN '1+1=4'
                ELSE '?'
        END "결과 확인"
FROM DUAL;
--==>> 1+1=2


--○ DECODE()
SELECT DECODE(5-2, 1, '5-2=1', 2, '5-2=2', 3, '5-2=3', '5-2=?') "결과 확인"
FROM DUAL;
--==>> 5-2=3


--○ CASE WHEN THEN ELSE END 구문 활용
SELECT CASE WHEN 5<2 THEN '5<2'
            WHEN 5>2 THEN '5>2'     
            ELSE '5와 2는 비교불가'           -- 모두 TRUE 일 경우 처음 연산만 수행
       END "결과 확인"
FROM DUAL;
--==>> 5>2

SELECT CASE WHEN 5<2 OR 3>1 AND 2=2 THEN '지혜만세'
            WHEN 5>2 OR 2=3 THEN '기승만세'
            ELSE '희진만세'
       END "결과 확인"
FROM DUAL;
--==>> 지혜만세

SELECT CASE WHEN 3<1 AND 5<2 OR 3>1 AND 2=2 THEN '훈의만세'
            WHEN 5<2 AND 2=3 THEN '진석만세'
            ELSE '보라만세'
       END "결과 확인"
FROM DUAL;
--==>> 훈의만세

SELECT CASE WHEN 3<1 AND (5<2 OR 3>1) AND 2=2 THEN '훈의만세'
            WHEN 5<2 AND 2=3 THEN '진석만세'
            ELSE '보라만세'
       END "결과 확인"
FROM DUAL;
--==>> 보라만세


SELECT *
FROM TBL_SAWON;

--○ 문제
-- TBL_SAWON 테이블을 활용하여 다음과 같은 항목들을 조회한다.
-- 사원번호, 사원명, 주민번호, 성별, 현재나이, 입사일
-- , 정년퇴직일, 근무일수, 남은일수, 급여, 보너스

-- 단, 현재 나이는 한국나이 계산법에 따라 연산을 수행한다.
-- 또한, 정년퇴직일은 해당 직원의 나이가 한국나이로 60세가 되는 해(년도)의 
-- 그 직원의 입사, 월, 일로 연산을 수행한다.
-- 그리고 보너스는 1000일 이상 2000일 미만 근무한 사원은
-- 그 사원의 원래 급여 기준 30% 지급,
-- 2000일 이상 근무한 사원은 그 사원의 원래 급여 기준 50% 지급을 할 수 있도록 처리한다.

ALTER SESSION SET NLS_DATE_FORMAT = 'YYYY-MM-DD';
--==>> Session이(가) 변경되었습니다.

SELECT SANO"사원번호", SANAME"사원명", JUBUN"주민번호"
     , CASE SUBSTR(JUBUN, 7, 1) WHEN '1' THEN '남자' WHEN '2' THEN '여자' WHEN '3' THEN '남자' WHEN '4' THEN '여자' END "성별"
     
     , CASE WHEN SUBSTR(JUBUN, 1, 2)>0 AND SUBSTR(JUBUN, 1, 2)<10 THEN TO_CHAR(SYSDATE, 'YY')-SUBSTR(JUBUN, 1, 2) +1
        ELSE TO_CHAR(SYSDATE, 'YY') - SUBSTR(JUBUN, 1, 2) +100 +1
        END "현재 나이"
        
     , HIREDATE"입사일"
     
     , CASE WHEN SUBSTR(JUBUN, 1, 2)>0 AND SUBSTR(JUBUN, 1, 2)<10 THEN ADD_MONTHS(HIREDATE, (60 - (TO_CHAR(SYSDATE, 'YY')-SUBSTR(JUBUN, 1, 2) +1))*12 + (2019-EXTRACT(YEAR FROM HIREDATE))*12)
        ELSE ADD_MONTHS(HIREDATE, (60-(TO_CHAR(SYSDATE, 'YY') - SUBSTR(JUBUN, 1, 2) +100 +1))*12 + (2019-EXTRACT(YEAR FROM HIREDATE))*12)
        END "정년퇴직일"
        
     , TRUNC(SYSDATE - HIREDATE)"근무일수"
     
     , CASE WHEN SUBSTR(JUBUN, 1, 2)>0 AND SUBSTR(JUBUN, 1, 2)<10 THEN TRUNC(ADD_MONTHS(HIREDATE, (60 - (TO_CHAR(SYSDATE, 'YY')-SUBSTR(JUBUN, 1, 2) +1))*12 + (2019-EXTRACT(YEAR FROM HIREDATE))*12) - SYSDATE)
        ELSE TRUNC(ADD_MONTHS(HIREDATE, (60-(TO_CHAR(SYSDATE, 'YY') - SUBSTR(JUBUN, 1, 2) +100 +1))*12 + (2019-EXTRACT(YEAR FROM HIREDATE))*12)-SYSDATE)
        END "남은일수"
        
     , SAL "급여"
     
     , CASE WHEN TRUNC(SYSDATE-HIREDATE)<1000 THEN 0
             WHEN TRUNC(SYSDATE-HIREDATE)>=1000 AND TRUNC(SYSDATE-HIREDATE)<2000 THEN SAL*0.3
            ELSE SAL*0.5
        END "보너스"
FROM TBL_SAWON;


-- 정년퇴직일
SELECT CASE WHEN SUBSTR(JUBUN, 1, 2)>0 AND SUBSTR(JUBUN, 1, 2)<10 THEN ADD_MONTHS(HIREDATE, (60 - (TO_CHAR(SYSDATE, 'YY')-SUBSTR(JUBUN, 1, 2) +1))*12 + (2019-EXTRACT(YEAR FROM HIREDATE))*12)
        ELSE ADD_MONTHS(HIREDATE, (60-(TO_CHAR(SYSDATE, 'YY') - SUBSTR(JUBUN, 1, 2) +100 +1))*12 + (2019-EXTRACT(YEAR FROM HIREDATE))*12)
        END "정년퇴직일"
FROM TBL_SAWON;

-- 근무일수
SELECT TRUNC(SYSDATE - HIREDATE)
FROM TBL_SAWON;

-- 남은일수
SELECT CASE WHEN SUBSTR(JUBUN, 1, 2)>0 AND SUBSTR(JUBUN, 1, 2)<10 THEN TRUNC(ADD_MONTHS(HIREDATE, ((60 - (TO_CHAR(SYSDATE, 'YY')-SUBSTR(JUBUN, 1, 2) +1))*12) + (2019-EXTRACT(YEAR FROM HIREDATE))*12) - SYSDATE)
        ELSE TRUNC(ADD_MONTHS(HIREDATE, ((60-(TO_CHAR(SYSDATE, 'YY') - SUBSTR(JUBUN, 1, 2) +100 +1))*12) + (2019-EXTRACT(YEAR FROM HIREDATE))*12)-SYSDATE)
        END "남은일수"
FROM TBL_SAWON;

-- 보너스
-- 그리고 보너스는 1000일 이상 2000일 미만 근무한 사원은
-- 그 사원의 원래 급여 기준 30% 지급,
-- 2000일 이상 근무한 사원은 그 사원의 원래 급여 기준 50% 지급을 할 수 있도록 처리한다.
SELECT  CASE WHEN TRUNC(SYSDATE-HIREDATE)<1000 THEN 0
             WHEN TRUNC(SYSDATE-HIREDATE)>=1000 AND TRUNC(SYSDATE-HIREDATE)<2000 THEN SAL*0.3
            ELSE SAL*0.5
        END "보너스"
FROM TBL_SAWON;


-- TBL_SAWON 테이블에 존재하는 사원들의
-- 입사일(HIREDATE) 컬럼에서 월, 일만 조회하기
SELECT SANAME, HIREDATE, TO_CHAR(HIREDATE, 'MM-DD')
FROM TBL_SAWON;
--==>>
/*
이원영	    2001-01-03	01-03
나주영	    2001-11-05	11-05
진윤비	    1999-08-16	08-16
권홍비	    1997-11-05	11-05
이비승	    1998-02-02	02-02
조영우	    1998-02-02	02-02
이하이	    2010-07-15	07-15
소이현	    2010-07-15	07-15
선동열	    2011-07-15	07-15
선우선	    1999-11-11	11-11
선우용녀	1999-11-11	11-11
남상현	    2010-11-11	11-11
남궁선	    1992-10-10	10-10
남이	    1987-10-10	10-10
이이경	    1997-10-10	10-10
*/


-- 사원번호, 사원명, 주민번호, 성별
SELECT SANO"사원번호", SANAME"사원명", JUBUN"주민번호"
     , CASE WHEN SUBSTR(JUBUN, 7, 1) IN ('1', '3') THEN '남자'
            WHEN SUBSTR(JUBUN, 7, 1) IN ('2', '4') THEN '여자'
            ELSE '성별확인불가'
       END
FROM TBL_SAWON;
--==>>
/*
1001	이원영	    8706241234567	남자
1002	나주영	    9405022234567	여자
1003	진윤비	    9710012234567	여자
1004	권홍비	    9504102234567	여자
1005	이비승	    7210101234567	남자
1006	조영우	    8004271234567	남자
1007	이하이	    0405064234567	여자
1008	소이현	    0506074234567	여자
1009	선동열	    0505053234567	남자
1010	선우선	    9505052234567	여자
1011	선우용녀	7512122234567	여자
1012	남상현	    9302131234567	남자
1013	남궁선	    7202021234567	남자
1014	남이	    6912121234567	남자
1015	이이경	    8410141234567	남자
*/


-- 사원번호, 사원명, 주민번호, 성별, 현재나이, 입사일
SELECT SANO"사원번호", SANAME"사원명", JUBUN"주민번호"
     , CASE WHEN SUBSTR(JUBUN, 7, 1) IN ('1', '3') THEN '남자'
            WHEN SUBSTR(JUBUN, 7, 1) IN ('2', '4') THEN '여자'
            ELSE '성별확인불가'
       END
       
    -- 현재나이 = 현재년도 - 태어난년도 + 1 (1900년대 생 / 2000년대 생)
     , CASE WHEN SUBSTR(JUBUN, 7, 1) IN ('1', '2') 
            THEN EXTRACT(YEAR FROM SYSDATE) - (TO_NUMBER(SUBSTR(JUBUN, 1, 2)) + 1899)
            WHEN SUBSTR(JUBUN, 7, 1) IN ('3', '4') 
            THEN EXTRACT(YEAR FROM SYSDATE) - (TO_NUMBER(SUBSTR(JUBUN, 1, 2)) + 1999)
            ELSE 0
       END"현재나이"
FROM TBL_SAWON;
--==>>
/*
1001	이원영	    8706241234567	남자	33
1002	나주영	    9405022234567	여자	26
1003	진윤비	    9710012234567	여자	23
1004	권홍비	    9504102234567	여자	25
1005	이비승	    7210101234567	남자	48
1006	조영우	    8004271234567	남자	40
1007	이하이	    0405064234567	여자	16
1008	소이현	    0506074234567	여자	15
1009	선동열	    0505053234567	남자	15
1010	선우선	    9505052234567	여자	25
1011	선우용녀	7512122234567	여자	45
1012	남상현	    9302131234567	남자	27
1013	남궁선	    7202021234567	남자	48
1014	남이	    6912121234567	남자	51
1015	이이경	    8410141234567	남자	36
*/




=== 20190401_01_scott.sql ===

SELECT USER
FROM DUAL;

ALTER SESSION SET NLS_DATE_FORMAT = 'YYYY-MM-DD';
--==>> Session이(가) 변경되었습니다.


--○ 문제
-- TBL_SAWON 테이블을 활용하여 다음과 같은 항목들을 조회한다.
-- 사원번호, 사원명, 주민번호, 성별, 현재나이, 입사일
-- 정년퇴직일, 근무일수, 남은일수, 급여, 보너스

-- 단, 현재 나이는 한국나이 계산법에 따라 연산을 수행한다.
-- 또한, 정년퇴직일은 해당 직원의 나이가 한국나이로 60세가 되는 해(년도)의 
-- 그 직원의 입사, 월, 일로 연산을 수행한다.
-- 그리고 보너스는 1000일 이상 2000일 미만 근무한 사원은
-- 그 사원의 원래 급여 기준 30% 지급,
-- 2000일 이상 근무한 사원은 그 사원의 원래 급여 기준 50% 지급을 할 수 있도록 처리한다.

-- 사원번호, 사원명, 주민번호, 성별, 현재나이, 입사일, 급여
SELECT SANO"사원번호", SANAME"사원명", JUBUN"주민번호"
     , CASE WHEN SUBSTR(JUBUN, 7, 1) IN ('1', '3') THEN '남자'
            WHEN SUBSTR(JUBUN, 7, 1) IN ('2', '4') THEN '여자'
            ELSE '성별확인불가'
       END"성별"
       
    -- 현재나이 = 현재년도 - 태어난년도 + 1 (1900년대 생 / 2000년대 생)
     , CASE WHEN SUBSTR(JUBUN, 7, 1) IN ('1', '2') 
            THEN EXTRACT(YEAR FROM SYSDATE) - (TO_NUMBER(SUBSTR(JUBUN, 1, 2)) + 1899)
            WHEN SUBSTR(JUBUN, 7, 1) IN ('3', '4') 
            THEN EXTRACT(YEAR FROM SYSDATE) - (TO_NUMBER(SUBSTR(JUBUN, 1, 2)) + 1999)
            ELSE 0
       END"현재나이"
     , HIREDATE"입사일"
     , SAL"급여"
FROM TBL_SAWON;
--==>>
/*
1001	이원영	    8706241234567	남자	33	01/01/03	3000
1002	나주영	    9405022234567	여자	26	01/11/05	2000
1003	진윤비	    9710012234567	여자	23	99/08/16	5000
1004	권홍비	    9504102234567	여자	25	97/11/05	4000
1005	이비승	    7210101234567	남자	48	98/02/02	2000
1006	조영우	    8004271234567	남자	40	98/02/02	2000
1007	이하이	    0405064234567	여자	16	10/07/15	1000
1008	소이현	    0506074234567	여자	15	10/07/15	1000
1009	선동열	    0505053234567	남자	15	11/07/15	3000
1010	선우선	    9505052234567	여자	25	99/11/11	4000
1011	선우용녀	7512122234567	여자	45	99/11/11	5000
1012	남상현	    9302131234567	남자	27	10/11/11	3000
1013	남궁선	    7202021234567	남자	48	92/10/10	2000
1014	남이	    6912121234567	남자	51	87/10/10	4000
1015	이이경	    8410141234567	남자	36	97/10/10	5000
*/


SELECT SANAME"사원명", SAL*12"연봉", SAL*12*2"두배연봉"
FROM TBL_SAWON;

SELECT 사원명, 연봉*2"두배연봉"
FROM
(
    SELECT SANAME"사원명", SAL*12"연봉"      -- 하나의 가상테이블 취급(서브 쿼리)
    FROM TBL_SAWON
);


SELECT T.사원명, T.연봉*2"두배연봉"
FROM
(
    SELECT SANAME"사원명", SAL*12"연봉"     
    FROM TBL_SAWON
) T;                                         -- IN LINE VIEW


-- 사원번호, 사원명, 주민번호, 성별, 현재나이, 입사일
-- 정년퇴직일, 근무일수, 남은일수, 급여, 보너스
SELECT T.사원번호, T.사원명, T.주민번호, T.성별, T.현재나이, T.입사일
     -- 정년퇴직일
     -- 정년퇴직년도 → 해당 직원의 나이가 한국나이로 60세가 되는 해
     -- 현재나이가 58세  2년 후 → 2019 2021
     -- 현재나이가 35세 25년 후 → 2019 2044
     -- ADD_MONTHS(SYSDATE, 남은년수*12)
     --                     --------
     --                     60 - 현재나이
     -- ADD_MONTHS(SYSDATE, (60-현재나이)*12)
     -- TO_CHAR(ADD_MONTHS(SYSDATE, (60-현재나이)*12), 'YYYY') → 정년퇴직 년도만 추출
     -- TO_CHAR(HIREDATE, 'MM-DD')                             → 입사일   월일만 추출
     -- TO_CHAR(ADD_MONTHS(SYSDATE, (60-현재나이)*12), 'YYYY') || '-' || TO_CHAR(HIREDATE, 'MM-DD')"정년퇴직일"
     , TO_CHAR(ADD_MONTHS(SYSDATE, (60 - T.현재나이)*12), 'YYYY') || '-' || TO_CHAR(T.입사일, 'MM-DD')"정년퇴직일"
     
     -- 근무일수
     -- = 현재일 - 입사일
     , TRUNC(SYSDATE - T.입사일)"근무일수"
     
     -- 남은일수
     -- = 정년퇴직일 - 현재일
     -- TO_DATE(정년퇴직문자열, 'YYYY-MM-DD')
     , TRUNC(TO_DATE(TO_CHAR(ADD_MONTHS(SYSDATE, (60 - T.현재나이)*12), 'YYYY') || '-' || TO_CHAR(T.입사일, 'MM-DD'), 'YYYY-MM-DD') - SYSDATE)"남은일수"
     
     , T.급여
     
     -- 보너스
     -- 근무일수가 1000일 이상 2000일 미만 → 원래 급여 기준 30% 지급, 근무일수가 2000일 이상 → 원래 급여 기준 50% 지급, 나머지 0
     , CASE WHEN TRUNC(SYSDATE - T.입사일)>=2000
            THEN T.급여 * 0.5
            WHEN TRUNC(SYSDATE - T.입사일)>=1000
            THEN T.급여 * 0.3
            ELSE 0
        END"보너스"
     
FROM 
(
    SELECT SANO"사원번호", SANAME"사원명", JUBUN"주민번호"
         , CASE WHEN SUBSTR(JUBUN, 7, 1) IN ('1', '3') THEN '남자'
                WHEN SUBSTR(JUBUN, 7, 1) IN ('2', '4') THEN '여자'
                ELSE '성별확인불가'
           END"성별"
           
        -- 현재나이 = 현재년도 - 태어난년도 + 1 (1900년대 생 / 2000년대 생)
         , CASE WHEN SUBSTR(JUBUN, 7, 1) IN ('1', '2') 
                THEN EXTRACT(YEAR FROM SYSDATE) - (TO_NUMBER(SUBSTR(JUBUN, 1, 2)) + 1899)
                WHEN SUBSTR(JUBUN, 7, 1) IN ('3', '4') 
                THEN EXTRACT(YEAR FROM SYSDATE) - (TO_NUMBER(SUBSTR(JUBUN, 1, 2)) + 1999)
                ELSE 0
           END"현재나이"
         , HIREDATE"입사일"
         , SAL"급여"
    FROM TBL_SAWON
) T;
--==>>
/*
1001	이원영	    8706241234567	남자	33	2001-01-03	2046-01-03	 6662	 9773	3000	1500
1002	나주영	    9405022234567	여자	26	2001-11-05	2053-11-05	 6356	12636	2000	1000
1003	진윤비	    9710012234567	여자	23	1999-08-16	2056-08-16	 7168	13651	5000	2500
1004	권홍비	    9504102234567	여자	25	1997-11-05	2054-11-05	 7817	13001	4000	2000
1005	이비승	    7210101234567	남자	48	1998-02-02	2031-02-02	 7728	 4324	2000	1000
1006	조영우	    8004271234567	남자	40	1998-02-02	2039-02-02	 7728	 7246	2000	1000
1007	이하이	    0405064234567	여자	16	2010-07-15	2063-07-15	 3182	16175	1000	 500
1008	소이현	    0506074234567	여자	15	2010-07-15	2064-07-15	 3182	16541	1000	 500
1009	선동열	    0505053234567	남자	15	2011-07-15	2064-07-15	 2817	16541	3000	1500
1010	선우선	    9505052234567	여자	25	1999-11-11	2054-11-11	 7081	13007	4000	2000
1011	선우용녀	7512122234567	여자	45	1999-11-11	2034-11-11	 7081	 5702	5000	2500
1012	남상현	    9302131234567	남자	27	2010-11-11	2052-11-11	 3063	12277	3000	1500
1013	남궁선	    7202021234567	남자	48	1992-10-10	2031-10-10	 9669	 4574	2000	1000
1014	남이	    6912121234567	남자	51	1987-10-10	2028-10-10	11496	 3479	4000	2000
1015	이이경	    8410141234567	남자	36	1997-10-10	2043-10-10	 7843	 8957	5000	2500
*/

-- 상기 내용에서 특정 근무일수의 사원을 확인해야 한다거나,
-- 특정 보너스 금액을 받는 사원을 확인해야 할 경우가 생길 수 있다.
-- 이와 같은 경우 해당 쿼리문을 다시 구성하는 번거로움을 줄일 수 있도록
-- 뷰(VIEW)를 만들어 저장해 둘 수 있다.


CREATE OR REPLACE VIEW VIEW_SAWON
AS
SELECT T.사원번호, T.사원명, T.주민번호, T.성별, T.현재나이, T.입사일
     , TO_CHAR(ADD_MONTHS(SYSDATE, (60 - T.현재나이)*12), 'YYYY') || '-' || TO_CHAR(T.입사일, 'MM-DD')"정년퇴직일"
     
     , TRUNC(SYSDATE - T.입사일)"근무일수"
     
     , TRUNC(TO_DATE(TO_CHAR(ADD_MONTHS(SYSDATE, (60 - T.현재나이)*12), 'YYYY') || '-' || TO_CHAR(T.입사일, 'MM-DD'), 'YYYY-MM-DD') - SYSDATE)"남은일수"
     
     , T.급여

     , CASE WHEN TRUNC(SYSDATE - T.입사일)>=2000
            THEN T.급여 * 0.5
            WHEN TRUNC(SYSDATE - T.입사일)>=1000
            THEN T.급여 * 0.3
            ELSE 0
        END"보너스"
     
FROM 
(
    SELECT SANO"사원번호", SANAME"사원명", JUBUN"주민번호"
         , CASE WHEN SUBSTR(JUBUN, 7, 1) IN ('1', '3') THEN '남자'
                WHEN SUBSTR(JUBUN, 7, 1) IN ('2', '4') THEN '여자'
                ELSE '성별확인불가'
           END"성별"
           
         , CASE WHEN SUBSTR(JUBUN, 7, 1) IN ('1', '2') 
                THEN EXTRACT(YEAR FROM SYSDATE) - (TO_NUMBER(SUBSTR(JUBUN, 1, 2)) + 1899)
                WHEN SUBSTR(JUBUN, 7, 1) IN ('3', '4') 
                THEN EXTRACT(YEAR FROM SYSDATE) - (TO_NUMBER(SUBSTR(JUBUN, 1, 2)) + 1999)
                ELSE 0
           END"현재나이"
         , HIREDATE"입사일"
         , SAL"급여"
    FROM TBL_SAWON
) T;
--==>> View VIEW_SAWON이(가) 생성되었습니다.


--○ TBL_SAWON 테이블의 이원영 입사일 및 급여 데이터 변경
-- 현재 : 1001	이원영	8706241234567	남자	33	2001-01-03	2046-01-03	6662	9773	3000	1500

UPDATE TBL_SAWON
SET HIREDATE=SYSDATE, SAL=100
WHERE SANO=1001;
--==>> 1 행 이(가) 업데이트되었습니다.

COMMIT;
-- 커밋 완료

SELECT *
FROM TBL_SAWON;
--==>> 1001	이원영	8706241234567	2019-04-01	100

SELECT *
FROM VIEW_SAWON;
--==>> 1001	이원영	8706241234567	남자	33	2019-04-01	2046-04-01	0	9861	100	0

INSERT INTO TBL_SAWON(SANO, SANAME, SAL, HIREDATE)
VALUES(2000, '김선아', 5000, SYSDATE);
--==>> 1 행 이(가) 삽입되었습니다.

COMMIT;
-- 커밋 완료


--○ 문제
-- 서브 쿼리를 활용하여 TBL_SAWON 테이블을 다음과 같이 조회할 수 있도록 한다.
/*
------------------------------------------
  사원명 성별 현재나이 급여 나이보너스
  
단, 나이보너스는 현재 나이가 40세 이상이면 급여의 70%
    30세 이상 40세 미만이면 급여의 50%
    20세 이상 30세 미만이면 급여의 30%

또한, 완성된 조회 구문을 기반으로
VIEW_SAWON2 라는 이름의 뷰(VIEW)를 생성한다. 
*/


CREATE OR REPLACE VIEW VIEW_SAWON2
AS
SELECT T.*
    
     -- 나이보너스
     , CASE WHEN T.현재나이 >=40 THEN T.급여 * 0.7
            WHEN T.현재나이 >=30 THEN T.급여 * 0.5
            WHEN T.현재나이 >=20 THEN T.급여 * 0.3
            ELSE 0
        END"나이보너스"
     
FROM 
(
    SELECT SANAME"사원명"
         , CASE WHEN SUBSTR(JUBUN, 7, 1) IN ('1', '3') THEN '남성'
                WHEN SUBSTR(JUBUN, 7, 1) IN ('2', '4') THEN '여성'
                ELSE '성별확인불가'
           END"성별"
           
         , CASE WHEN SUBSTR(JUBUN, 7, 1) IN ('1', '2') 
                THEN EXTRACT(YEAR FROM SYSDATE) - (TO_NUMBER(SUBSTR(JUBUN, 1, 2)) + 1899)
                WHEN SUBSTR(JUBUN, 7, 1) IN ('3', '4') 
                THEN EXTRACT(YEAR FROM SYSDATE) - (TO_NUMBER(SUBSTR(JUBUN, 1, 2)) + 1999)
                ELSE 0
           END"현재나이"
           
         , SAL"급여"
    FROM TBL_SAWON
) T;
--==>> View VIEW_SAWON2이(가) 생성되었습니다.

SELECT *
FROM VIEW_SAWON2;
--==>> 
/*
이원영	    남성	        33	 100	  50
나주영	    여성	        26	2000	 600
진윤비	    여성	        23	5000	1500
권홍비	    여성	        25	4000	1200
이비승	    남성	        48	2000	1400
조영우	    남성	        40	2000	1400
이하이	    여성	        16	1000	   0
소이현	    여성	        15	1000	   0
선동열	    남성	        15	3000	   0
선우선	    여성	        25	4000	1200
선우용녀	여성	        45	5000	3500
남상현	    남성	        27	3000	 900
남궁선	    남성	        48	2000	1400
남이	    남성	        51	4000	2800
이이경	    남성	        36	5000	2500
김선아	    성별확인불가	 0	5000	   0
*/


--------------------------------------------------------------------------------------------------------------

--○ RANK() → 등수(순위)를 반환하는 함수
SELECT EMPNO"사원번호", ENAME"사원명", DEPTNO"부서번호", SAL"급여"
     , RANK() OVER(ORDER BY SAL DESC)"전체급여순위"
FROM EMP;
--==>>
/*
7839	KING	10	5000	 1
7902	FORD	20	3000	 2
7788	SCOTT	20	3000	 2
7566	JONES	20	2975	 4
7698	BLAKE	30	2850	 5
7782	CLARK	10	2450	 6
7499	ALLEN	30	1600	 7
7844	TURNER	30	1500	 8
7934	MILLER	10	1300	 9
7521	WARD	30	1250	10
7654	MARTIN	30	1250	10
7876	ADAMS	20	1100	12
7900	JAMES	30	 950	13
7369	SMITH	20	 800	14
*/


SELECT EMPNO"사원번호", ENAME"사원명", DEPTNO"부서번호", SAL"급여"
     , RANK() OVER(PARTITION BY DEPTNO ORDER BY SAL DESC)"부서내 급여순위"
     , RANK() OVER(ORDER BY SAL DESC)"전체급여순위"
FROM EMP;
--==>>
/*
7839	KING	10	5000	1	 1
7902	FORD	20	3000	1	 2
7788	SCOTT	20	3000	1	 2
7566	JONES	20	2975	3	 4
7698	BLAKE	30	2850	1	 5
7782	CLARK	10	2450	2	 6
7499	ALLEN	30	1600	2	 7
7844	TURNER	30	1500	3	 8
7934	MILLER	10	1300	3	 9
7521	WARD	30	1250	4	10
7654	MARTIN	30	1250	4	10
7876	ADAMS	20	1100	4	12
7900	JAMES	30	 950	6	13
7369	SMITH	20	 800	5	14
*/


SELECT EMPNO"사원번호", ENAME"사원명", DEPTNO"부서번호", SAL"급여"
     , RANK() OVER(PARTITION BY DEPTNO ORDER BY SAL DESC)"부서내 급여순위"
     , RANK() OVER(ORDER BY SAL DESC)"전체급여순위"
FROM EMP
ORDER BY 3, 4 DESC;
--==>>
/*
7839	KING	10	5000	1	 1
7782	CLARK	10	2450	2	 6
7934	MILLER	10	1300	3	 9
7902	FORD	20	3000	1	 2
7788	SCOTT	20	3000	1	 2
7566	JONES	20	2975	3	 4
7876	ADAMS	20	1100	4	12
7369	SMITH	20	 800	5	14
7698	BLAKE	30	2850	1	 5
7499	ALLEN	30	1600	2	 7
7844	TURNER	30	1500	3	 8
7654	MARTIN	30	1250	4	10
7521	WARD	30	1250	4	10
7900	JAMES	30	 950	6	13
*/


--○ DENSE_RANK() → 서열을 반환하는 함수
SELECT EMPNO"사원번호", ENAME"사원명", DEPTNO"부서번호", SAL"급여"
     , DENSE_RANK() OVER(PARTITION BY DEPTNO ORDER BY SAL DESC)"부서내 급여순위"
     , DENSE_RANK() OVER(ORDER BY SAL DESC)"전체 급여서열"
FROM EMP
ORDER BY 3, 4 DESC;
--==>> 
/*
7839	KING	10	5000	1	 1
7782	CLARK	10	2450	2	 5
7934	MILLER	10	1300	3	 8
7902	FORD	20	3000	1	 2
7788	SCOTT	20	3000	1	 2
7566	JONES	20	2975	2	 3
7876	ADAMS	20	1100	3	10
7369	SMITH	20	 800	4	12
7698	BLAKE	30	2850	1	 4
7499	ALLEN	30	1600	2	 6
7844	TURNER	30	1500	3	 7
7654	MARTIN	30	1250	4	 9
7521	WARD	30	1250	4	 9
7900	JAMES	30	 950	5	11
*/


--○ EMP 테이블의 사원 정보를
--   사원명, 부서번호, 연봉, 부서내 연봉순위, 전체 연봉순위 항목으로 조회한다.
SELECT ENAME"사원명", DEPTNO"부서번호", SAL*12+NVL(COMM,0)"연봉"
     , DENSE_RANK() OVER(PARTITION BY DEPTNO ORDER BY SAL*12+NVL(COMM,0) DESC)"부서내 연봉순위"
     , RANK() OVER(ORDER BY SAL*12+NVL(COMM,0) DESC)"전체 연봉순위"
FROM TBL_EMP
ORDER BY 2 ASC;
--==>>
/*
KING	10	60000	1	 1
CLARK	10	29400	2	 6
MILLER	10	15600	3	 9
FORD	20	36000	1	 2
SCOTT	20	36000	1	 2
JONES	20	35700	2	 4
ADAMS	20	13200	3	12
SMITH	20	 9600	4	14
BLAKE	30	34200	1	 5
ALLEN	30	19200	2	 7
TURNER	30	18000	3	 8 
MARTIN	30	15000	4	10
WARD	30	15000	4	10
JAMES	30	11400	5	13
*/


SELECT T.*
     , RANK() OVER(PARTITION BY T.부서번호 ORDER BY T.연봉 DESC)"부서내 연봉순위"
     , RANK() OVER(ORDER BY T.연봉 DESC)"전체 연봉순위"
FROM
(
    SELECT ENAME"사원명", DEPTNO"부서번호"
         , SAL*12+NVL(COMM,0)"연봉"
    FROM EMP
)T
ORDER BY 2, 3 DESC;

--==>>
/*
KING	10	60000	1	 1
CLARK	10	29400	2	 6
MILLER	10	15600	3	10
FORD	20	36000	1	 2
SCOTT	20	36000	1	 2
JONES	20	35700	3	 4
ADAMS	20	13200	4	12
SMITH	20	 9600	5	14
BLAKE	30	34200	1	 5
ALLEN	30	19500	2	 7
TURNER	30	18000	3	 8
MARTIN	30	16400	4	 9
WARD	30	15500	5	11
JAMES	30	11400	6	13
*/


--○ EMP 테이블에서 전체 연봉 순위가 1등부터 5등 까지만
--   사원명, 부서번호 , 연봉, 전체연봉순위 항목으로 조회한다.
SELECT T.*
FROM
(
    SELECT ENAME"사원명", DEPTNO"부서번호"
         , SAL*12+NVL(COMM,0)"연봉"
         , RANK() OVER(ORDER BY SAL*12+NVL(COMM,0) DESC)"전체연봉순위"
    FROM EMP
)T
WHERE T.전체연봉순위 <= 5;


SELECT ENAME"사원명", DEPTNO"부서번호"
      , SAL*12+NVL(COMM,0)"연봉"
      , RANK() OVER(ORDER BY SAL*12+NVL(COMM,0) DESC)"전체연봉순위"
FROM RANK() OVER(ORDER BY SAL*12+NVL(COMM,0) DESC) <= 5;
--==>>
/*
ORA-00933: SQL command not properly ended
00933. 00000 -  "SQL command not properly ended"
*Cause:    
*Action:
463행, 40열에서 오류 발생
*/

--※ 위의 내용은 RANK() OVER() 함수를 WHERE 조건절에서 사용한 경우이며
--   이 함수는 WHERE 조건절에서 사용할 수 없기 때문에 발생하는 에러이다.
--   이 경우, 우리는 INLINE VIEW 를 활용하여 풀이해야 한다.


--○ EMP 테이블에서 각 부서별로 연봉 등수가 1등 부터 2등 까지만 조회한다.
--   사원명, 부서번호, 연봉, 부서내연봉등수, 전체연봉등수
SELECT T.*
FROM
(
    SELECT ENAME"사원명", DEPTNO"부서번호"
         , SAL*12+NVL(COMM,0)"연봉"
         , RANK() OVER(PARTITION BY DEPTNO ORDER BY SAL*12+NVL(COMM,0) DESC)"부서내연봉등수"
         , RANK() OVER(ORDER BY SAL*12+NVL(COMM,0) DESC)"전체연봉등수"
    FROM EMP
)T
WHERE T.부서내연봉등수 <= 2;


------------------------------------------------------------------------------------------------------------------

--■■■ 그룹 함수 ■■■--

-- SUM() 합, AVG() 평균, COUNT() 카운트, MAX() 최대값, MIN() 최소값
-- VARIANCE() 분산, STDDEV() 표준편차

--※ 그룹 함수의 가장 큰 특징은
--   처리해야 할 데이터들 중 NULL 이 존재하면
--   이 NULL 은 제외하고 연산을 수행한다는 것이다.

-- SUM()
-- EMP 테이블을 대상으로 전체 사원들의 급여 총합을 조회한다.
SELECT SUM(SAL)     -- 800+1600+1250+2975+1250+...+1300
FROM EMP;   
--==>> 29025

SELECT SUM(COMM)    -- 300+500+1400+0
FROM EMP;
--==>> 2200


-- COUNT()
-- 행의 갯수 조회하여 결과값 반환
SELECT COUNT(ENAME)
FROM EMP;
--==>> 14

SELECT COUNT(SAL)
FROM EMP;
--==>> 14

SELECT COUNT(COMM)  -- COMM 컬럼의 행의 갯수 조회 → NULL 은 제외!!
FROM EMP;
--==>> 4

SELECT COUNT(*)     -- 전체 행의 갯수 조회
FROM EMP;
--==>> 14


-- AVG()
-- 평균 반환
SELECT SUM(SAL) / COUNT(SAL), AVG(SAL)
FROM EMP;
--==>> 
/*
2073.214285714285714285714285714285714286	
2073.214285714285714285714285714285714286
*/

SELECT AVG(COMM)
FROM EMP;
--==>> 550

SELECT SUM(COMM) / COUNT(*)
FROM EMP;
--==>> 157.142857142857142857142857142857142857

SELECT SUM(COMM) / COUNT(COMM), AVG(COMM)
FROM EMP;
--==>>
/*
550	
550
*/


--※ 표준편차의 제곱이 분산
--   분산의 제곱근이 표준편차
SELECT AVG(SAL), VARIANCE(SAL), STDDEV(SAL)
FROM EMP;
--==>>
/*
2073.214285714285714285714285714285714286	
1398313.87362637362637362637362637362637	
1182.503223516271699458653359613061928508
*/

SELECT POWER(STDDEV(SAL), 2), VARIANCE(SAL)
FROM EMP;
--==>>
/*
1398313.87362637362637362637362637362637	
1398313.87362637362637362637362637362637
*/

SELECT SQRT(VARIANCE(SAL)), STDDEV(SAL)
FROM EMP;
--==>>
/*
1182.503223516271699458653359613061928508	
1182.503223516271699458653359613061928508
*/


-- MAX() / MIN()
-- 최대값 / 최소값 반환
SELECT MAX(SAL), MIN(SAL)
FROM EMP;
--==>> 5000	800


--※ 주의
SELECT ENAME, SUM(SAL)  -- 레코드값 14개 1개
FROM EMP;
--==>> 에러 발생
/*
ORA-00937: not a single-group group function
00937. 00000 -  "not a single-group group function"
*Cause:    
*Action:
593행, 8열에서 오류 발생
*/

SELECT DEPTNO, SUM(SAL)
FROM EMP;
--==>> 에러 발생
/*
ORA-00937: not a single-group group function
00937. 00000 -  "not a single-group group function"
*Cause:    
*Action:
604행, 8열에서 오류 발생
*/


--○ 부서별 급여합 조회
SELECT DEPTNO"부서번호", SUM(SAL)"급여합"
FROM EMP
GROUP BY DEPTNO
ORDER BY DEPTNO;
--==>>
/*
10	 8750
20	10875
30	 9400
*/

SELECT DEPTNO"부서번호", SUM(SAL)"급여함"
FROM EMP
GROUP BY ROLLUP(DEPTNO);
--==> 
/*
10	 8750
20	10875
30	 9400
	29025
*/

--○ 데이터 입력
INSERT INTO TBL_EMP VALUES (8001, '조인성', 'CLERK', 7566, SYSDATE, 1500, 10, NULL);
INSERT INTO TBL_EMP VALUES (8002, '강동원', 'CLERK', 7566, SYSDATE, 1000, 0, NULL);
INSERT INTO TBL_EMP VALUES (8003, '공유', 'SALESMAN', 7698, SYSDATE, 2000, NULL, NULL);
INSERT INTO TBL_EMP VALUES (8004, '장동건', 'SALESMAN', 7698, SYSDATE, 2500, NULL, NULL);
INSERT INTO TBL_EMP VALUES (8005, '원빈', 'SALESMAN', 7698, SYSDATE, 1000, NULL, NULL);
--==>> 1 행 이(가) 삽입되었습니다. * 5


--○ 확인
SELECT *
FROM TBL_EMP;
--==>>
/*
7369	SMITH	CLERK	    7902	1980-12-17	 800		    20
7499	ALLEN	SALESMAN	7698	1981-02-20	1600	 300	30
7521	WARD	SALESMAN	7698	1981-02-22	1250	 500	30
7566	JONES	MANAGER	    7839	1981-04-02	2975		    20
7654	MARTIN	SALESMAN	7698	1981-09-28	1250	1400	30
7698	BLAKE	MANAGER	    7839	1981-05-01	2850		    30
7782	CLARK	MANAGER	    7839	1981-06-09	2450		    10
7788	SCOTT	ANALYST	    7566	1987-07-13	3000		    20
7839	KING	PRESIDENT		    1981-11-17	5000		    10
7844	TURNER	SALESMAN	7698	1981-09-08	1500	   0	30
7876	ADAMS	CLERK	    7788	1987-07-13	1100		    20
7900	JAMES	CLERK	    7698	1981-12-03	 950		    30
7902	FORD	ANALYST	    7566	1981-12-03	3000		    20
7934	MILLER	CLERK	    7782	1982-01-23	1300		    10
8001	조인성	CLERK	    7566	2019-04-01	1500	  10	
8002	강동원	CLERK	    7566	2019-04-01	1000	   0	
8003	공유	SALESMAN	7698	2019-04-01	2000		
8004	장동건	SALESMAN	7698	2019-04-01	2500		
8005	원빈	SALESMAN	7698	2019-04-01	1000		
*/


--○ 커밋
COMMIT;
--==>> 커밋 완료.


SELECT DEPTNO"부서번호", SUM(SAL)"급여합"
FROM TBL_EMP
GROUP BY ROLLUP(DEPTNO);
--==>>
/*
10	     8750
20	    10875
30	     9400
(null)	 8000   → 부서번호가 NULL 인 데이터들끼리의 급여 합
(null)	37025   → 모든 부서의 급여 총 합계
*/

-- 위에서 조회한 내용을
/*
10	         8750
20	        10875
30	         9400
인턴	     8000   → 부서번호가 NULL 인 데이터들끼리의 급여 합
모든부서	37025   → 모든 부서의 급여 총 합계
*/


SELECT CASE DEPTNO WHEN NULL
            THEN '인턴'
            ELSE DEPTNO
       END"부서번호"
FROM TBL_EMP;
--==>> 에러 발생
/*
ORA-00932: inconsistent datatypes: expected CHAR got NUMBER
00932. 00000 -  "inconsistent datatypes: expected %s got %s"
*Cause:    
*Action:
704행, 22열에서 오류 발생
*/

SELECT CASE DEPTNO WHEN NULL
            THEN '인턴'
            ELSE TO_CHAR(DEPTNO)
       END"부서번호"
FROM TBL_EMP;
--==>>
/*
20
30
30
20
30
30
10
20
10
30
20
30
20
10
(null)
(null)
(null)
(null)
(null)
*/

SELECT CASE WHEN DEPTNO IS NULL
            THEN '인턴'
            ELSE TO_CHAR(DEPTNO)
       END"부서번호"
FROM TBL_EMP;
--==>>
/*
20
30
30
20
30
30
10
20
10
30
20
30
20
10
인턴
인턴
인턴
인턴
인턴
*/

SELECT CASE WHEN DEPTNO IS NULL
            THEN '인턴'
            ELSE TO_CHAR(DEPTNO)
       END"부서번호"
     , SUM(SAL)"급여합"
FROM TBL_EMP
GROUP BY ROLLUP(DEPTNO);
--==>>
/*
10	     8750
20	    10875
30	     9400
인턴	 8000
인턴	37025
*/

SELECT CASE WHEN DEPTNO IS NULL
            THEN '인턴'
            ELSE TO_CHAR(DEPTNO)
       END"부서번호"
     , SUM(SAL)"급여합"
FROM TBL_EMP
GROUP BY DEPTNO
ORDER BY DEPTNO;
--==>>
/*
10	     8750
20	    10875
30	     9400
인턴	 8000
*/

SELECT T.*
FROM
(
    SELECT CASE WHEN DEPTNO IS NULL
                THEN '인턴'
                ELSE TO_CHAR(DEPTNO)
           END"부서번호"
         , SUM(SAL)"급여합"
    FROM TBL_EMP
    GROUP BY DEPTNO
    ORDER BY DEPTNO
)T
GROUP BY ROLLUP(T.부서번호);
--==>> 에러 발생
/*
ORA-00979: not a GROUP BY expression
00979. 00000 -  "not a GROUP BY expression"
*Cause:    
*Action:
804행, 10열에서 오류 발생
*/


--※ GROUPING()
SELECT DEPTNO"부서번호", SUM(SAL)"급여합", GROUPING(DEPTNO)
FROM TBL_EMP
GROUP BY ROLLUP(DEPTNO);
--==>>
/*
10	     8750	0
20	    10875	0
30	     9400	0
(null)	 8000	0
(null)	37025	1
*/



SELECT CASE GROUPING(DEPTNO) WHEN 0 THEN NVL(TO_CHAR(DEPTNO), '인턴')
            ELSE '모든부서' END"부서번호"
     , SUM(SAL)"급여합"
FROM TBL_EMP
GROUP BY ROLLUP(DEPTNO);
--==>>
/*
10	         8750
20	        10875
30	         9400
인턴	     8000
모든부서	37025
*/


--○ TBL_SAWON 테이블을 다음과 같이 조회될 수 있도록 쿼리문을 구성한다.
/*
------------------------
    성별      급여합
------------------------
    남         XXXXX
    여         XXXXX
    확인불가
    모든사원 XXXXXXX
*/

SELECT * 
FROM TBL_SAWON;

SELECT CASE GROUPING(T.성별) WHEN 0 THEN T.성별
           ELSE '모든사원' 
       END"성별"
     , SUM(T.급여)"급여합"
FROM
(
    SELECT CASE WHEN SUBSTR(JUBUN, 7, 1) IN ('1', '3') THEN '남'
                WHEN SUBSTR(JUBUN, 7, 1) IN ('2', '4') THEN '여'
                ELSE '확인불가'
        END"성별"
        , SAL"급여"
    FROM TBL_SAWON
)T
GROUP BY ROLLUP(T.성별);
--==>>
/*
남	        21100
여	        22000
확인불가	 5000
모든사원	48100
*/


--○ TBL_SAWON 테이블을 다음과 같이 연령대별 인원수 형태로
--   조회할 수 있도록 쿼리문을 구성한다.
/*
------------------------------
    연령대     인원수
------------------------------
    0           X
    10          X
    20          X
    30          X
    40          X          
    50          X
    전체        X
------------------------------
*/

SELECT *
FROM TBL_SAWON;

SELECT CASE GROUPING(T2.연령대) WHEN 0 THEN TO_CHAR(T2.연령대)
           ELSE '전체' 
       END"연령대"
    , COUNT(*)"인원수"
FROM(
    SELECT
        CASE WHEN T.현재나이<10 THEN 0
             WHEN T.현재나이<20 THEN 10
             WHEN T.현재나이<30 THEN 20
             WHEN T.현재나이<40 THEN 30
             WHEN T.현재나이<50 THEN 40
             WHEN T.현재나이<60 THEN 50
             ELSE NULL
          END "연령대"
        
    FROM
    (
        SELECT CASE WHEN SUBSTR(JUBUN, 7, 1) IN ('1', '2')
                    THEN EXTRACT(YEAR FROM SYSDATE) - TO_NUMBER(SUBSTR(JUBUN, 1, 2) + 1899) 
                    WHEN SUBSTR(JUBUN, 7, 1) IN ('3', '4')
                    THEN EXTRACT(YEAR FROM SYSDATE) - TO_NUMBER(SUBSTR(JUBUN, 1, 2) + 1999)
                    ELSE NULL
                END"현재나이"
        FROM TBL_SAWON
    )T
)T2
GROUP BY ROLLUP(T2.연령대);
--==>>
/*
연령대        인원수
----------- ----------
10              3
20              5
30              2
40              4
50              1
(null)          1
전체           16
*/


-- 방법1. (INLINE VIEW 를 두 번 중첩)
SELECT CASE GROUPING(Q.연령대) WHEN 0 THEN TO_CHAR(Q.연령대)
           ELSE '전체' 
       END"연령대"
    , COUNT(Q.연령대)"인원수"
FROM
(   
    SELECT CASE WHEN T.나이>=50 THEN 50
                WHEN T.나이>=40 THEN 40
                WHEN T.나이>=30 THEN 30
                WHEN T.나이>=20 THEN 20
                WHEN T.나이>=10 THEN 10
                ELSE 0
            END "연령대"
    FROM
    (
        -- 나이
        SELECT CASE WHEN SUBSTR(JUBUN, 7, 1) IN ('1', '2')
                    THEN EXTRACT(YEAR FROM SYSDATE) - TO_NUMBER(SUBSTR(JUBUN, 1, 2) + 1899) 
                    WHEN SUBSTR(JUBUN, 7, 1) IN ('3', '4')
                    THEN EXTRACT(YEAR FROM SYSDATE) - TO_NUMBER(SUBSTR(JUBUN, 1, 2) + 1999)
                    ELSE 0
                END"나이"
        FROM TBL_SAWON
    )T
)Q
GROUP BY ROLLUP(Q.연령대);
--==>>
/*
연령대       인원수
---------- ----------
0              1
10             3
20             5
30             2
40             4
50             1
전체          16
*/


-- 방법2. (INLINE VIEW 를 한 번만 사용)
SELECT CASE GROUPING(T.연령대) WHEN 0 THEN TO_CHAR(T.연령대)
           ELSE '전체' 
       END"연령대"
    , COUNT(T.연령대)"인원수"
FROM
(
    SELECT TRUNC(CASE WHEN SUBSTR(JUBUN, 7, 1) IN ('1', '2')
            THEN EXTRACT(YEAR FROM SYSDATE) - TO_NUMBER(SUBSTR(JUBUN, 1, 2) + 1899) 
            WHEN SUBSTR(JUBUN, 7, 1) IN ('3', '4')
            THEN EXTRACT(YEAR FROM SYSDATE) - TO_NUMBER(SUBSTR(JUBUN, 1, 2) + 1999)
            ELSE 0
       END, -1)"연령대"
    FROM TBL_SAWON
)T
GROUP BY ROLLUP(T.연령대);
--==>>
/*
연령대            인원수
--------------- ----------
0                   1
10                  3
20                  5
30                  2
40                  4
50                  1
전체               16
*/

SELECT TRUNC(23, -1)"확인"
FROM DUAL;


--○ ROLLUP 활용 및 CUBE
SELECT DEPTNO, JOB, SUM(SAL)
FROM EMP
GROUP BY ROLLUP(DEPTNO, JOB)
ORDER BY 1, 2;
--==>>
/*
10	    CLERK	     1300
10	    MANAGER	     2450
10	    PRESIDENT	 5000
10	    (null)       8750       -- 10번 부서 모든 직종의 급여합
20	    ANALYST	     6000
20	    CLERK	     1900
20	    MANAGER	     2975
20	    (null)	    10875       -- 20번 부서 모든 직종의 급여합
30	    CLERK	      950
30	    MANAGER	     2850
30	    SALESMAN	 5600
30	    (null)	     9400       -- 30번 부서 모든 직종의 급여합
(null)  (null)      29025       -- 모든 부서 모든 직종의 급여합
*/


--○ CUBE() → ROLLUP() 보다 좀 더 자세한 결과를 반환받을 수 있다.
SELECT DEPTNO, JOB, SUM(SAL)
FROM EMP
GROUP BY CUBE(DEPTNO, JOB)
ORDER BY 1, 2;
--==>>
/*
10	    CLERK	     1300
10	    MANAGER	     2450
10	    PRESIDENT	 5000
10	    (null)	     8750       -- 10번 부서 모든 직종의 급여합
20	    ANALYST	     6000
20	    CLERK	     1900
20	    MANAGER	     2975
20	    (null)	    10875       -- 20번 부서 모든 직종의 급여합
30	    CLERK	      950
30	    MANAGER	     2850
30	    SALESMAN  	 5600
30	    (null)	     9400       -- 30번 부서 모든 직종의 급여합
(null)	ANALYST	     6000       -- 모든 부서 ANALYST 직종의 급여합
(null)	CLERK	     4150       -- 모든 부서 CLERK 직종의 급여합
(null)	MANAGER	     8275       -- 모든 부서 MANAGER 직종의 급여합
(null)	PRESIDENT	 5000       -- 모든 부서 PRESIDENT 직종의 급여합
(null)	SALESMAN	 5600       -- 모든 부서 SALESMAN 직종의 급여합
(null)	(null)	    29025       -- 모든 부서 모든 직종의 급여합
*/

--※ ROLLUP() 과 CUBE() 는
--   그룹을 묶어주는 방식이 다르다. (차이)

-- ROLLUP(A, B, C)
-- → (A, B, C) / (A, B) / (A) / ()

-- CUBE(A, B, C)
-- → (A, B, C) / (A, B)/ (A, C) / (B / C) / (A) / (B) / (C) / ()

--==>> 위의 처리 내용은 너무 많은 결과물이 출력되기 때문에
--     다음의 쿼리 형태를 더 많이 사용한다.
--     다음 작성하는 쿼리는 조회하고자 하는 그룹만 『GROUPING SETS』를
--     이용하여 묶어주는 방법이다.

SELECT CASE GROUPING(DEPTNO) WHEN 0 THEN NVL(TO_CHAR(DEPTNO), '인턴')
            ELSE '전체부서'
       END"부서번호"
     , CASE GROUPING(JOB) WHEN 0 THEN JOB 
            ELSE '전체직종'
       END"직종"
     , SUM(SAL)"급여합"
FROM TBL_EMP
GROUP BY ROLLUP(DEPTNO, JOB)
ORDER BY 1, 2;
--==>>
/*
10	        CLERK	     1300
10	        MANAGER	     2450
10	        PRESIDENT	 5000
10	        전체직종	 8750
20	        ANALYST	     6000
20	        CLERK	     1900
20	        MANAGER	     2975
20	        전체직종	10875
30	        CLERK	      950
30	        MANAGER	     2850
30	        SALESMAN	 5600
30	        전체직종	 9400
인턴	    CLERK	     2500
인턴	    SALESMAN	 5500
인턴	    전체직종	 8000
전체부서	전체직종	37025
*/


SELECT CASE GROUPING(DEPTNO) WHEN 0 THEN NVL(TO_CHAR(DEPTNO), '인턴')
            ELSE '전체부서'
       END"부서번호"
     , CASE GROUPING(JOB) WHEN 0 THEN JOB 
            ELSE '전체직종'
       END"직종"
     , SUM(SAL)"급여합"
FROM TBL_EMP
GROUP BY CUBE(DEPTNO, JOB)
ORDER BY 1, 2;
--==>>
/*
10	        CLERK	     1300
10	        MANAGER	     2450
10	        PRESIDENT	 5000
10	        전체직종	 8750
20	        ANALYST	     6000
20	        CLERK	     1900
20	        MANAGER	     2975
20	        전체직종	10875
30	        CLERK	      950
30	        MANAGER	     2850
30	        SALESMAN	 5600
30	        전체직종	 9400
인턴	    CLERK	     2500
인턴	    SALESMAN	 5500
인턴	    전체직종	 8000
전체부서	ANALYST	     6000
전체부서	CLERK	     6650
전체부서	MANAGER	     8275
전체부서	PRESIDENT	 5000
전체부서	SALESMAN	11100
전체부서	전체직종	37025
*/


SELECT CASE GROUPING(DEPTNO) WHEN 0 THEN NVL(TO_CHAR(DEPTNO), '인턴')
            ELSE '전체부서'
       END"부서번호"
     , CASE GROUPING(JOB) WHEN 0 THEN JOB 
            ELSE '전체직종'
       END"직종"
     , SUM(SAL)"급여합"
FROM TBL_EMP
GROUP BY GROUPING SETS((DEPTNO,JOB), (DEPTNO), ())      -- ROLLUP() 과 같은 결과
ORDER BY 1, 2;


SELECT CASE GROUPING(DEPTNO) WHEN 0 THEN NVL(TO_CHAR(DEPTNO), '인턴')
            ELSE '전체부서'
       END"부서번호"
     , CASE GROUPING(JOB) WHEN 0 THEN JOB 
            ELSE '전체직종'
       END"직종"
     , SUM(SAL)"급여합"
FROM TBL_EMP
GROUP BY GROUPING SETS((DEPTNO,JOB), (DEPTNO), (JOB), ())      -- CUBE() 과 같은 결과
ORDER BY 1, 2;


--○ TBL_EMP 테이블에서 입사년도별 인원수를 조회한다,
SELECT *
FROM TBL_EMP
ORDER BY HIREDATE;

/*
----------------------------
    입사년도       인원수
----------------------------
     1980           1
     1981          10
     1982           1
     1987           2
     2019           5
     전체          19
----------------------------
*/
SELECT CASE GROUPING(T.입사년도) WHEN 0 THEN TO_CHAR(T.입사년도)
           ELSE '전체' 
       END"입사년도"
    , COUNT(T.입사년도)"인원수"
FROM(
    SELECT  EXTRACT(YEAR FROM HIREDATE)"입사년도"
    FROM TBL_EMP
    ORDER BY HIREDATE
)T
GROUP BY ROLLUP(T.입사년도)
ORDER BY 1, 2;


SELECT EXTRACT(YEAR FROM HIREDATE)"입사년도"
     , COUNT(*)"인원수"
FROM TBL_EMP
GROUP BY ROLLUP(EXTRACT(YEAR FROM HIREDATE))
ORDER BY 1;

SELECT EXTRACT(YEAR FROM HIREDATE)"입사년도"
     , COUNT(*)"인원수"
FROM TBL_EMP
GROUP BY CUBE(EXTRACT(YEAR FROM HIREDATE))
ORDER BY 1;

SELECT EXTRACT(YEAR FROM HIREDATE)"입사년도"
     , COUNT(*)"인원수"
FROM TBL_EMP
GROUP BY GROUPING SETS(EXTRACT(YEAR FROM HIREDATE), ())
ORDER BY 1;

SELECT EXTRACT(YEAR FROM HIREDATE)"입사년도"
     , COUNT(*)"인원수"
FROM TBL_EMP
GROUP BY ROLLUP(TO_CHAR(HIREDATE, 'YYYY'))
ORDER BY 1;
--==>> 에러 발생
/*
ORA-00979: not a GROUP BY expression
00979. 00000 -  "not a GROUP BY expression"
*Cause:    
*Action:
1,231행, 26열에서 오류 발생
*/

SELECT TO_CHAR(HIREDATE, 'YYYY')"입사년도"
     , COUNT(*)"인원수"
FROM TBL_EMP
GROUP BY ROLLUP(EXTRACT(YEAR FROM HIREDATE))
ORDER BY 1;
--==>> 에러 발생
/*
ORA-00979: not a GROUP BY expression
00979. 00000 -  "not a GROUP BY expression"
*Cause:    
*Action:
1,245행, 16열에서 오류 발생
*/



=== 20190401_02_sys.sql ===

SELECT USER
FROM DUAL;
--==>> SYS


--○ SCOTT 계정에 VIEW 를 생성할 수 있는 권한 부여
GRANT CREATE VIEW TO SCOTT;
--==>> Grant을(를) 성공했습니다.




=== 20190402_01_scott.sql ===

SELECT USER
FROM DUAL;
--==>> SCOTT

--■■■ HAVING ■■■--

--○ EMP 테이블에서 부서번호가 20, 30인 부서를 대상으로
--   부서의 총 급여가 10000 보다 적을 경우만 부서별 총 급여를 조회한다.
SELECT DEPTNO, SUM(SAL)
FROM EMP
WHERE DEPTNO IN (20, 30)
GROUP BY DEPTNO;

SELECT DEPTNO, SUM(SAL)
FROM EMP
WHERE DEPTNO IN (20, 30)
  AND SUM(SAL) < 10000
GROUP BY DEPTNO;
--==>> 에러 발생
/*
ORA-00934: group function is not allowed here
00934. 00000 -  "group function is not allowed here"
*Cause:    
*Action:
17행, 7열에서 오류 발생
*/

SELECT DEPTNO, SUM(SAL)
FROM EMP
WHERE DEPTNO IN (20, 30)
GROUP BY DEPTNO
HAVING SUM(SAL) < 10000;
--==>> 30	9400

SELECT DEPTNO, SUM(SAL)
FROM EMP
GROUP BY DEPTNO
HAVING DEPTNO IN (20, 30)           -- 일반 조건문은 WHERE에 사용할 것을 권장
   AND SUM(SAL) < 10000;
--==>> 30	9400


----------------------------------------------------------------------------------------------------------------

--■■■ 중첩 그룹함수 / 분석함수 ■■■--

-- 그룹 함수 2 LEVEL 까지 중첩해서 사용할 수 있다.
-- 이마저도 MSSQL 은 불가능하다.
SELECT MAX(SUM(SAL))
FROM EMP
GROUP BY DEPTNO;
--==>> 10875

-- RANK()
-- DENSE_RANK()
--> ORACLE 9i 부터 적용 MSSQL 2005 부터 적용

-- 하위 버전에서는 RANK() 나 DENSE_RANK() 를 사용할 수 없기 때문에
-- 이를 대체하여 연산을 수행할 수 있는 방법을 강구해야 한다.

-- 예를 들어, 급여의 순위를 구하고자 한다면
-- 해당 사원의 급여보다 더 큰 값이 몇 개인지 확인한 후
-- 확인한 숫자에 +1 을 추가 연산해주면 그것이 곧 등수가 된다.

SELECT ENAME, SAL
FROM EMP;

SELECT COUNT(*) + 1
FROM EMP
WHERE SAL > 800;
--==>> 14 → SMITH 의 급여 등수

SELECT COUNT(*) + 1
FROM EMP
WHERE SAL > 1600;
--==>> 7 → ALLEN 의 급여 등수


--※ 서브 상관 쿼리 (상관 서브 쿼리)
--   메인 쿼리에 있는 테이블의 컬럼이
--   서브 쿼리의 조건절(WHERE절, HAVING절)에 사용되는 경우
--   우리는 이 쿼리문을 서브 상관 쿼리 라고 부른다.

SELECT ENAME"사원명", SAL"급여", 1"급여등수"
FROM EMP;

SELECT ENAME"사원명", SAL"급여"
     , (SELECT COUNT(*) + 1
        FROM EMP
        WHERE SAL > E1.SAL)"급여등수"
FROM EMP E1;
--==>>
/*
SMITH	 800	14
ALLEN	1600	 7
WARD	1250	10
JONES	2975	 4
MARTIN	1250	10
BLAKE	2850	 5
CLARK	2450	 6
SCOTT	3000	 2
KING	5000	 1
TURNER	1500	 8
ADAMS	1100	12
JAMES	 950	13
FORD	3000	 2
MILLER	1300	 9
*/


SELECT ENAME"사원명", SAL"급여"
     , (SELECT COUNT(*) + 1
        FROM EMP
        WHERE SAL > E1.SAL)"급여등수"
FROM EMP E1
ORDER BY 3;
--==>>
/*
KING	5000	 1
FORD	3000	 2
SCOTT	3000	 2
JONES	2975	 4
BLAKE	2850	 5
CLARK	2450	 6
ALLEN	1600	 7
TURNER	1500	 8
MILLER	1300	 9
WARD	1250	10
MARTIN	1250	10
ADAMS	1100	12
JAMES	 950	13
SMITH	 800	14
*/


--○ EMP 테이블을 대상으로 
--   사원명, 급여, 부서번호, 부서내급여등수, 전체급여등수 항목을 조회한다.
--   단, RANK() 함수를 사용하지 않고, 상관 서브 쿼리를 활용할 수 있도록 한다.



SELECT ENAME"사원명", SAL"급여"
     , (SELECT COUNT(*) + 1
        FROM EMP
        WHERE DEPTNO = E1.DEPTNO AND SAL > E1.SAL)"부서내급여등수"
     , (SELECT COUNT(*) + 1
        FROM EMP
        WHERE SAL > E1.SAL)"전체급여등수"
FROM EMP E1
ORDER BY E1.DEPTNO, SAL DESC;
--==>>
/*
KING	5000	1	 1
CLARK	2450	2	 6
MILLER	1300	3	 9
SCOTT	3000	1	 2
FORD	3000	1	 2
JONES	2975	3	 4
ADAMS	1100	4	12
SMITH	 800	5	14
BLAKE	2850	1	 5
ALLEN	1600	2	 7
TURNER	1500	3	 8
MARTIN	1250	4	10
WARD	1250	4	10
JAMES	 950	6	13
*/

ALTER SESSION SET NLS_DATE_FORMAT = 'YYYY-MM-DD';
--==>> Session이(가) 변경되었습니다.

--○ EMP 테이블을 대상으로 다음과 같이 조회할 수 있도록 한다.
/*
----------------------------------------------------------------------------
  사원명   부서번호    입사일       급여      부서내입사별급여누적
  CLARK	     10	    1981-06-09	    2450            2450
  KING	     10	    1981-11-17	    5000            7450
  MILLER     10	    1982-01-23	    1300            8750
  SMITH	     20	    1980-12-17	     800             800
  JONES	     20	    1981-04-02	    2975            3775
  FORD	     20	    1981-12-03	    3000
  SCOTT	     20	    1987-07-13	    3000
  ADAMS	     20	    1987-07-13	    1100
  ALLEN	     30	    1981-02-20	    1600
  WARD	     30	    1981-02-22	    1250
  BLAKE	     30	    1981-05-01	    2850
  TURNER     30	    1981-09-08	    1500
  MARTIN     30	    1981-09-28	    1250
  JAMES	     30	    1981-12-03	     950
----------------------------------------------------------------------------
*/

SELECT ENAME"사원명", DEPTNO"부서번호", HIREDATE"입사일", SAL"급여"
     , (SELECT SUM(SAL)
        FROM EMP
        WHERE DEPTNO = E1.DEPTNO AND HIREDATE <= E1.HIREDATE)"부서내입사별급여누적"
FROM EMP E1
ORDER BY 2, 3;
--==>>
/*
CLARK	10	1981-06-09	2450	 2450
KING	10	1981-11-17	5000	 7450
MILLER	10	1982-01-23	1300	 8750
SMITH	20	1980-12-17	 800	  800
JONES	20	1981-04-02	2975	 3775
FORD	20	1981-12-03	3000	 6775
SCOTT	20	1987-07-13	3000	10875
ADAMS	20	1987-07-13	1100	10875
ALLEN	30	1981-02-20	1600	 1600
WARD	30	1981-02-22	1250	 2850
BLAKE	30	1981-05-01	2850	 5700
TURNER	30	1981-09-08	1500	 7200
MARTIN	30	1981-09-28	1250	 8450
JAMES	30	1981-12-03	 950	 9400
*/


--○ TBL_EMP를 기반으로 입사한 사원수가 제일 많았을 때의
--   입사년월과 인원수를 조회할 수 있는 쿼리문을 구성한다.
/*
-------------------------------------
    입사년월        인원수
-------------------------------------
    2019-04           5 
-------------------------------------
*/
SELECT *
FROM(
    SELECT TO_CHAR(HIREDATE, 'YYYY-MM')"입사년월", COUNT(*)"인원수"
    FROM TBL_EMP
    GROUP BY TO_CHAR(HIREDATE, 'YYYY-MM')
)T
WHERE T.인원수 = (SELECT MAX(COUNT(*))
                  FROM TBL_EMP
                  GROUP BY TO_CHAR(HIREDATE, 'YYYY-MM'));
--==>>
/*
입사년월  인원수
------- ----------
2019-04     5
*/


SELECT TO_CHAR(HIREDATE, 'YYYY-MM')"입사년월", COUNT(*)"인원수"
FROM EMP
GROUP BY TO_CHAR(HIREDATE, 'YYYY-MM')
HAVING COUNT(*) = (SELECT MAX(COUNT(*))
                  FROM EMP
                  GROUP BY TO_CHAR(HIREDATE, 'YYYY-MM'));
--==>>
/*
1981-12	2
1981-09	2
1981-02	2
1987-07	2
*/


-------------------------------------------------------------------------------------------------------

--■■■ ROW_NUMBER() ■■■--

SELECT ROW_NUMBER() OVER(ORDER BY SAL DESC) "테스트"
     , ENAME"사원명", SAL"급여", HIREDATE"입사일"
FROM EMP
ORDER BY ENAME;


--※ 게시판의 게시물 번호를 SEQUENCE 나 IDENTITY 를 사용하게 되면
--   게시물을 삭제했을 경우, 삭제한 게시물의 자리에 다음 번호를 가진
--   게시물이 등록되는 상황이 발생하게 된다.
--   이는 보안 측면에서나 미관상 바람직하지 않은 상황일 수 있기 때문에
--   ROW_NUMBER() 의 사용을 고려해볼 수 있다.
--   관리의 목적으로 사용할 때에는 SEQUENCE 나 IDENTITY 를 사용하지만
--   단순히 게시물을 목록화하여 사용자에게 리스트 형식으로 보여줄 때에는
--   사용하지 않는 것이 좋다.

CREATE TABLE TBL_AAA
( NO        NUMBER
, NAME      VARCHAR2(30)
, GRADE     CHAR(10)
);
--==>> Table TBL_AAA이(가) 생성되었습니다.

INSERT INTO TBL_AAA(NO, NAME, GRADE) VALUES(1, '이지혜', 'A');
INSERT INTO TBL_AAA(NO, NAME, GRADE) VALUES(2, '이기승', 'B');
INSERT INTO TBL_AAA(NO, NAME, GRADE) VALUES(3, '윤희진', 'A');
INSERT INTO TBL_AAA(NO, NAME, GRADE) VALUES(4, '권홍비', 'C');
INSERT INTO TBL_AAA(NO, NAME, GRADE) VALUES(5, '권홍비', 'A');
INSERT INTO TBL_AAA(NO, NAME, GRADE) VALUES(6, '이기승', 'A');
INSERT INTO TBL_AAA(NO, NAME, GRADE) VALUES(7, '이기승', 'A');
--==>> 1 행 이(가) 삽입되었습니다. * 7

COMMIT;
--==>> 커밋 완료.

SELECT *
FROM TBL_AAA;
--==>>
/*
1	이지혜	A         
2	이기승	B         
3	윤희진	A         
4	권홍비	C         
5	권홍비	A         
6	이기승	A         
7	이기승	A         
*/

UPDATE TBL_AAA
SET GRADE = 'C'
WHERE NO=6;


SELECT *
FROM TBL_AAA
WHERE NO=6;
--==>> 6	이기승	A         


--○ SEQUENCE (시퀀스 : 주문번호) 생성
--   → 사전적인 의미 : 1.(일련의) 연속적인 사건들  2.(사건, 행동 등의) 순서

CREATE SEQUENCE SEQ_BOARD   -- 시퀀스 생성 기본 구문(MSSQL 의 IDENTITY 와 동일한 개념)
START WITH 1                -- 시작값
INCREMENT BY 1              -- 증가값
NOMAXVALUE                  -- 최대값 제한 없음
NOCACHE;                    -- 캐시 사용 안함(없음)
--==>> Sequence SEQ_BOARD이(가) 생성되었습니다.


--○ 테이블 생성(TBL_BOARD)
CREATE TABLE TBL_BOARD              -- TBL_BOARD 이름의 테이블 생성 → 게시판
( NO        NUMBER                  -- 게시물 번호       Ⅹ
, TITLE     VARCHAR2(50)            -- 게시물 제목       ○
, CONTENTS  VARCHAR2(2000)          -- 게시물 내용       ○
, NAME      VARCHAR2(20)            -- 게시물 작성자     △
, PW        VARCHAR2(20)            -- 게시물 패스워드   △
, CREATED   DATE DEFAULT SYSDATE    -- 게시물 작성일     Ⅹ
);
--==>> Table TBL_BOARD이(가) 생성되었습니다.


--○ 데이터 입력 → 게시판에 게시물 작성
INSERT INTO TBL_BOARD VALUES(SEQ_BOARD.NEXTVAL, '앗싸~1등', '내가 1등이지롱', '전훈의', 'JAVA006$', DEFAULT);
--==>> 1 행 이(가) 삽입되었습니다.

INSERT INTO TBL_BOARD VALUES(SEQ_BOARD.NEXTVAL, '건강관리', '다들 건강 챙깁시당', '유진석', 'JAVA006$', DEFAULT);
--==>> 1 행 이(가) 삽입되었습니다.

INSERT INTO TBL_BOARD VALUES(SEQ_BOARD.NEXTVAL, '오늘은', '점심 뭐먹지...', '최보라', 'JAVA006$', DEFAULT);
--==>> 1 행 이(가) 삽입되었습니다.

INSERT INTO TBL_BOARD VALUES(SEQ_BOARD.NEXTVAL, '오늘은', '미세먼지 없나?', '정임혜', 'JAVA006$', DEFAULT);
--==>> 1 행 이(가) 삽입되었습니다.

INSERT INTO TBL_BOARD VALUES(SEQ_BOARD.NEXTVAL, '공부히고싶은데', '뒤에서 잘 안보여요', '조현우', 'JAVA006$', DEFAULT);
--==>> 1 행 이(가) 삽입되었습니다.

INSERT INTO TBL_BOARD VALUES(SEQ_BOARD.NEXTVAL, '질문있습니다', '쉬었다 한면 안되나요', '남상현', 'JAVA006$', DEFAULT);
--==>> 1 행 이(가) 삽입되었습니다.

INSERT INTO TBL_BOARD VALUES(SEQ_BOARD.NEXTVAL, '질문있습니다', '생각나면 다시 질문할께요', '한승원', 'JAVA006$', DEFAULT);
--==>> 1 행 이(가) 삽입되었습니다.

--○ 확인
SELECT *
FROM TBL_BOARD;

--○ 커밋
COMMIT;
--==>> 커밋 완료.

--○ 게시물 삭제
DELETE
FROM TBL_BOARD
WHERE NO=4;
--==>> 1 행 이(가) 삭제되었습니다.

--○ 게시물 작성
INSERT INTO TBL_BOARD VALUES (SEQ_BOARD.NEXTVAL, '졸려요', '전 그냥 잘래요', '윤희진', 'JAVA006$', DEFAULT);
--==>> 1 행 이(가) 삽입되었습니다.

SELECT *
FROM TBL_BOARD;

--○ 게시물 삭제
DELETE
FROM TBL_BOARD
WHERE NO=2;
--==>> 1 행 이(가) 삭제되었습니다.

DELETE
FROM TBL_BOARD
WHERE NO=8;
--==>> 1 행 이(가) 삭제되었습니다.

--○ 게시물 작성
INSERT INTO TBL_BOARD VALUES (SEQ_BOARD.NEXTVAL, '저는요', '잘 지내고 있습니다.', '이원영', 'JAVA006$', DEFAULT);
--==>> 1 행 이(가) 삽입되었습니다.

--○ 커밋
COMMIT;
--==>> 커밋 완료.

SELECT *
FROM TBL_BOARD;
--==>>
/*
1	앗싸~1등	    내가 1등이지롱	            전훈의	JAVA006$	2019-04-02
3	오늘은	        점심 뭐먹지...	            최보라	JAVA006$	2019-04-02
5	공부히고싶은데	뒤에서 잘 안보여요	        조현우	JAVA006$	2019-04-02
6	질문있습니다	쉬었다 한면 안되나요	    남상현	JAVA006$	2019-04-02
7	질문있습니다	생각나면 다시 질문할께요	한승원	JAVA006$	2019-04-02
9	저는요	        잘 지내고 있습니다.	        이원영	JAVA006$	2019-04-02
*/

SELECT ROW_NUMBER() OVER(ORDER BY CREATED) "글번호"
     , TITLE "제목", NAME "작성자", CREATED "작성일"
FROM TBL_BOARD
ORDER BY 4 DESC;
--==>>
/*
6	저는요	        이원영	2019-04-02
5	질문있습니다	한승원	2019-04-02
4	질문있습니다	남상현	2019-04-02
3	공부히고싶은데	조현우	2019-04-02
2	오늘은	        최보라	2019-04-02
1	앗싸~1등	    전훈의	2019-04-02
*/

--○ 게시물 작성
INSERT INTO TBL_BOARD VALUES (SEQ_BOARD.NEXTVAL, '오빠', '저 맘에 안들죠', '김선아', 'JAVA006$', DEFAULT);
--==>> 1 행 이(가) 삽입되었습니다.

SELECT ROW_NUMBER() OVER(ORDER BY CREATED) "글번호"
     , TITLE "제목", NAME "작성자", CREATED "작성일"
FROM TBL_BOARD
ORDER BY 4 DESC;

--○ 게시물 삭제
DELETE
FROM TBL_BOARD
WHERE NO=7;
--==>> 1 행 이(가) 삭제되었습니다.

--○ 커밋
COMMIT;
--==>> 커밋 완료.


SELECT ROW_NUMBER() OVER(ORDER BY CREATED) "글번호"
     , TITLE "제목", NAME "작성자", CREATED "작성일"
FROM TBL_BOARD
ORDER BY 4 DESC;
--==>>
/*
6	오빠	        김선아	2019-04-02
5	저는요	        이원영	2019-04-02
4	질문있습니다	남상현	2019-04-02
3	공부히고싶은데	조현우	2019-04-02
2	오늘은	        최보라	2019-04-02
1	앗싸~1등	    전훈의	2019-04-02
*/


------------------------------------------------------------------------------------------------------

--■■■ JOIN(조인) ■■■--        ★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★

-- 1. SQL 1992 CODE
SELECT *
FROM EMP, DEPT;
--> 수학에서 말하는 데카르트 곱(Catersian Product)
--  두 테이블을 합친(결합한) 모든 경우의 수

-- Equi join : 서로 정확히 일치하는 데이터들끼리 연결시키는 결합
SELECT *
FROM EMP, DEPT
WHERE EMP.DEPTNO = DEPT.DEPTNO;

SELECT *
FROM EMP E, DEPT D
WHERE E.DEPTNO = D.DEPTNO;


-- Non Equi join : 범위 안에 적합한 데이터들끼리 연결시키는 결합
SELECT *
FROM SALGRADE;
SELECT *
FROM EMP;

SELECT *
FROM EMP E, SALGRADE S
WHERE E.SAL BETWEEN S.LOSAL AND S.HISAL;


-- Equi Join 시 『(+)』 를 활용한 결합 방법
SELECT *
FROM TBL_EMP E, TBL_DEPT D
WHERE E.DEPTNO = D.DEPTNO;
--> 총 14건의 데이터가 결합되어 조회된 상황
--  즉, 부서번호를 갖지 못한 사원들(5)은 모두 나락!!

SELECT *
FROM TBL_EMP E, TBL_DEPT D
WHERE E.DEPTNO = D.DEPTNO(+);       
--> 총 19 건의 데이터가 결합되어 조회된 상황
--  즉, 부서번호를 갖지 못한 사원들도 모두 조회된 상황

SELECT *
FROM TBL_EMP E, TBL_DEPT D
WHERE E.DEPTNO(+) = D.DEPTNO; 
--> 총 16 건의 데이터가 결합되어 조회된 상황
--  즉, 부서에 소속된 사원이 아무도 없는 부서도 모두 조회된 상황

--※ (+)가 없는 쪽 데이블의 데이터를 모두 메모리에 적재한 후
--   (+)가 있는 쪽 테이블의 데이터를 하나한 확인하여 결합시키는 형태로
--   JOIN 이 이루어진다.

SELECT *
FROM TBL_EMP E, TBL_DEPT D
WHERE E.DEPTNO(+) = D.DEPTNO(+);
--> 위와 같은 이유로 이러한 형식의 JOIN 구문은 존재하지 않는다.


-- 2. SQL 1999 CODE → 『JOIN』 키워드 등장 → JOIN 유형 명시
--                     결합 조건은 『WHERE』 대신 『ON』 사용

-- CROSS JOIN
SELECT *
FROM EMP CROSS JOIN DEPT;

-- INNER JOIN
SELECT *
FROM EMP E INNER JOIN DEPT D
ON E.DEPTNO = D.DEPTNO;

SELECT *
FROM EMP E INNER JOIN SALGRADE S
ON E.SAL BETWEEN S.LOSAL AND S.HISAL;

--※ INNER JOIN 시 INNER 는 생략 가능
SELECT *
FROM EMP E JOIN DEPT D
ON E.DEPTNO = D.DEPTNO;

SELECT *
FROM EMP E JOIN SALGRADE S
ON E.SAL BETWEEN S.LOSAL AND S.HISAL;


-- OUTER JOIN 
SELECT *
FROM TBL_EMP E LEFT OUTER JOIN TBL_DEPT D
ON E.DEPTNO = D.DEPTNO;

--※ 방향이 지정된 쪽 테이블(→ LEFT) 의 데이터를 모두 메모리에 적재한 후
--   방향이 지정되지 않은 쪽 테이블들의 데이터를 각각 확인하여 결합시키는 형태로
--   JOIN 이 이루어진다.

SELECT *
FROM TBL_EMP E RIGHT OUTER JOIN TBL_DEPT D
ON E.DEPTNO = D.DEPTNO;


SELECT *
FROM TBL_EMP E FULL OUTER JOIN TBL_DEPT D
ON E.DEPTNO = D.DEPTNO;

--※ OUTER JOIN 에서 OUTER 는 생략 가능

SELECT *
FROM TBL_EMP E LEFT JOIN TBL_DEPT D     -- OUTER JOIN
ON E.DEPTNO = D.DEPTNO;

SELECT *
FROM TBL_EMP E RIGHT JOIN TBL_DEPT D    -- OUTER JOIN
ON E.DEPTNO = D.DEPTNO;

SELECT *
FROM TBL_EMP E FULL JOIN TBL_DEPT D     -- OUTER JOIN
ON E.DEPTNO = D.DEPTNO;

SELECT *
FROM TBL_EMP E JOIN TBL_DEPT            -- INNER JOIN
ON E.DEPTNO = D.DEPTNO;

-------------------------------------------------------------------------------------------------------
SELECT *
FROM EMP E JOIN DEPT D
ON E.DEPTNO = D.DEPTNO;
-- 이 결과에서 직종이 CLERK 인 사원들만 조회

SELECT *
FROM EMP E JOIN DEPT D
ON E.DEPTNO = D.DEPTNO
AND JOB = 'CLERK';
-- 이렇게 쿼리문을 구성해도 조회하는 데는 문제가 없다.

SELECT *
FROM EMP E JOIN DEPT D
ON E.DEPTNO = D.DEPTNO
WHERE JOB = 'CLERK';
-- 하지만, 이와 같이 구성하여 조회할 수 있도록 권장한다.
-------------------------------------------------------------------------------------------------------

--○ EMP 테이블과 DEPT 테이블에서
--   직종이 MANAGER 와 CLERK 인 사원들만
--   부서번호, 부서명, 사원명, 직종명, 급여 항목을 조회한다.

SELECT D.DEPTNO"부서번호", D.DNAME"부서명", E.ENAME"사원명", E.JOB"직종명", E.SAL"급여"
FROM EMP E JOIN DEPT D
ON E.DEPTNO = D.DEPTNO
WHERE JOB = 'MANAGER' OR JOB = 'CLERK'
ORDER BY 4;
-- DEPTNO 는 EMP, DEPT 둘 다 해당되지만 부모자식을 구분하여 작성 (일 대 다수)
-->
SELECT DEPTNO           -- → EMP 테이블의 DEPTNO(다수)
FROM EMP;
--==>>
/*
20
30
30
20
30
30
10
20
10
30
20
30
20
10
*/

SELECT DEPTNO           -- → DEPT 테이블의 DEPTNO
FROM DEPT;
--==>>
/*
10
20
30
40
*/

SELECT DEPTNO, DNAME, ENAME, JOB, SAL
FROM EMP E, DEPT D
WHERE E.DEPTNO = D.DEPTNO;
--==>> 에러 발생
/*
ORA-00918: column ambiguously defined
00918. 00000 -  "column ambiguously defined"
*Cause:    
*Action:
649행, 8열에서 오류 발생
*/
--> 두 테이블 간 중복되는 컬럼에 대한 소속 테이블을
--  정해줘야(명시해 줘야)한다.

SELECT DNAME, ENAME, JOB, SAL
FROM EMP E, DEPT D
WHERE E.DEPTNO = D.DEPTNO;
--> 두 테이블 간 중복되는 컬럼이 존재하지 않는 조회 구문은
--  에러 발생하지 않는다.
--==>> 
/*
RESEARCH	SMITH	CLERK	     800
SALES	    ALLEN	SALESMAN	1600
SALES	    WARD	SALESMAN	1250
RESEARCH	JONES	MANAGER	    2975
SALES	    MARTIN	SALESMAN	1250
SALES	    BLAKE	MANAGER	    2850
ACCOUNTING	CLARK	MANAGER	    2450
RESEARCH	SCOTT	ANALYST	    3000
ACCOUNTING	KING	PRESIDENT	5000
SALES	    TURNER	SALESMAN	1500
RESEARCH	ADAMS	CLERK	    1100
SALES	    JAMES	CLERK	     950
RESEARCH	FORD	ANALYST	    3000
ACCOUNTING	MILLER	CLERK	    1300
*/


SELECT D.DEPTNO, DNAME, ENAME, JOB, SAL
-- SELECT E.DEPTNO, DNAME, ENAME, JOB, SAL
FROM EMP E, DEPT D
WHERE E.DEPTNO = D.DEPTNO;
--> 두 테이블 간 중복되는 컬럼에 대해 소속 테이블을 명시하는 경우
--  부서(DEPT), 사원(EMP) 중 어떤 테이블을 지정해도
--  쿼리문 수행에 대한 결과 반환에 문제가 없다.

--※ 하지만 두 테이블 간 중복되는 컬럼에 대해 소속 테이블을 명시하는 경우
--   부모 테이블의 컬럼을 참조할 수 있도록 해야 한다.

SELECT *
FROM DEPT;      -- 부모 테이블
SELECT *
FROM EMP;       -- 자식 테이블

--※ 부모 자식 테이블 관계를 명확히 정리할 수 있도록 한다. ★★★★★★

SELECT D.DEPTNO, D.DNAME, E.ENAME, E.JOB, E.SAL
FROM EMP E, DEPT D
WHERE E.DEPTNO = D.DEPTNO;
--> 두 테이블 간 중복된 컬럼이 아니더라도
--  소속 테이블을 명시할 수 있도록 권장한다.

SELECT D.DEPTNO, D.DNAME, E.ENAME, E.JOB, E.SAL
FROM EMP E LEFT JOIN DEPT D
ON E.DEPTNO = D.DEPTNO;

SELECT E.DEPTNO, D.DNAME, E.ENAME, E.JOB, E.SAL
FROM EMP E LEFT JOIN DEPT D
ON E.DEPTNO = D.DEPTNO;

---

SELECT D.DEPTNO, D.DNAME, E.ENAME, E.JOB, E.SAL
FROM EMP E RIGHT JOIN DEPT D
ON E.DEPTNO = D.DEPTNO;

SELECT E.DEPTNO, D.DNAME, E.ENAME, E.JOB, E.SAL
FROM EMP E RIGHT JOIN DEPT D
ON E.DEPTNO = D.DEPTNO;


--○ SELF JOIN (자기 조인)

-- EMP 테이블의 정보를 다음과 같이 조회할 수 있도록 한다.
/*
E         E       E       E           E         E
EMPNO     ENAME   JOB     MGR, EMPNO  ENAME     JOB
------------------------------------------------------------
사원번호  사원명  직종명  관리자번호  관리자명  관리자직종명
------------------------------------------------------------
7369      SMITH   CLERK   7902        FORD      ANALYST

EMP       EMP     EMP     EMP                                       --> ①
                          EMP         EMP       EMP                 --> ②
------------------------------------------------------------
*/

SELECT E1.EMPNO"사원번호", E1.ENAME"사원명", E1.JOB"직종명", E2.EMPNO"관리자번호", E2.ENAME"관리자명", E2.JOB"관리자직종명"
FROM EMP E1 LEFT JOIN EMP E2
ON E1.MGR = E2.EMPNO
ORDER BY 1;
/*
7369	SMITH	CLERK	    7902	FORD	ANALYST
7499	ALLEN	SALESMAN	7698	BLAKE	MANAGER
7521	WARD	SALESMAN	7698	BLAKE	MANAGER
7566	JONES	MANAGER	    7839	KING	PRESIDENT
7654	MARTIN	SALESMAN	7698	BLAKE	MANAGER
7698	BLAKE	MANAGER	    7839	KING	PRESIDENT
7782	CLARK	MANAGER	    7839	KING	PRESIDENT
7788	SCOTT	ANALYST	    7566	JONES	MANAGER
7839	KING	PRESIDENT			
7844	TURNER	SALESMAN	7698	BLAKE	MANAGER
7876	ADAMS	CLERK	    7788	SCOTT	ANALYST
7900	JAMES	CLERK	    7698	BLAKE	MANAGER
7902	FORD	ANALYST	    7566	JONES	MANAGER
7934	MILLER	CLERK	    7782	CLARK	MANAGER
*/

SELECT *
FROM EMP;


--○ 커밋
COMMIT;
--==>> 커밋 완료.




=== 20190402_02_hr.sql ===

SELECT USER
FROM DUAL;
--==>> HR


--○ 세 개 이상의 테이블 조인(JOIN)

-- 형식1(SQL 1992 CONE)
SELECT 테이블명1.컬럼명, 테이블명2.컬럼명, 테이블명3.컬럼명
FROM 테이블명1, 테이블명2, 테이블명3
WHERE 테이블명1.컬럼명1 = 테이블2.컬럼명1
  AND 테이블명2.컬럼명1 = 테이블3.컬럼명2;

-- 형식2(SQL 1999 CONE)
SELECT 테이블명1.컬럼명, 테이블명2.컬럼명, 테이블명3.컬럼명
FROM 테이블명1 JOIN 테이블명2
ON 테이블명1.컬럼명1 = 테이블명2.컬럼명1
        JOIN 테이블명3
        ON 테이블명2.컬럼명2 = 테이블3.컬럼명2;


--○ HR 계정 소유 테이블 또는 뷰 목록 조회
SELECT *
FROM TAB;
--==>>
/*
COUNTRIES	        TABLE	
DEPARTMENTS	        TABLE	
EMPLOYEES	        TABLE	
EMP_DETAILS_VIEW	 VIEW	
JOBS	            TABLE	
JOB_HISTORY	        TABLE	
LOCATIONS	        TABLE	
REGIONS	            TABLE	
*/


--○ HR.JOBS, HR.EMPLOYEES, HR.DEPARTMENTS 테이블을 대상으로
--   직원들의 정보를 FIRST_NAME, LAST_NAME, JOB_TITLE, DEPARTMENT_NAME     JOBS-JOB_TITLE EM-FI,LA DE-DEPANA
--   항목을 조회한다.


SELECT EMPLOYEES.FIRST_NAME, EMPLOYEES.LAST_NAME, JOBS.JOB_TITLE, DEPARTMENTS.DEPARTMENT_NAME
FROM JOBS, EMPLOYEES, DEPARTMENTS
WHERE JOBS.JOB_ID(+) = EMPLOYEES.JOB_ID
  AND EMPLOYEES.DEPARTMENT_ID = DEPARTMENTS.DEPARTMENT_ID(+);
  

SELECT EMPLOYEES.FIRST_NAME, EMPLOYEES.LAST_NAME, JOBS.JOB_TITLE, DEPARTMENTS.DEPARTMENT_NAME
FROM JOBS JOIN EMPLOYEES
ON JOBS.JOB_ID = EMPLOYEES.JOB_ID
        LEFT JOIN DEPARTMENTS
        ON EMPLOYEES.DEPARTMENT_ID = DEPARTMENTS.DEPARTMENT_ID;

SELECT *
FROM JOBS;

SELECT *
FROM EMPLOYEES;

SELECT *
FROM DEPARTMENTS;


--○ EMPLOYEES, DEPARTMENTS, JOBS, LOCATIONS,COUNTRIES, REGIONS 테이블을 대상으로
--   직원들의 정보를 다음과 같이 조회한다.
--   FIRST_NAME, LAST_NAME, JOB_TITLE, DEPARTMENT_NAME
--   , CITY, COUNTRY_NAME, REGION_NAME

SELECT *
FROM REGIONS;

SELECT EMPLOYEES.FIRST_NAME, EMPLOYEES.LAST_NAME, JOBS.JOB_TITLE, DEPARTMENTS.DEPARTMENT_NAME, LOCATIONS.CITY, COUNTRIES.COUNTRY_NAME, REGIONS.REGION_NAME
FROM JOBS, EMPLOYEES, DEPARTMENTS, LOCATIONS,COUNTRIES, REGIONS
WHERE JOBS.JOB_ID(+) = EMPLOYEES.JOB_ID
  AND EMPLOYEES.DEPARTMENT_ID = DEPARTMENTS.DEPARTMENT_ID(+)
  AND DEPARTMENTS.LOCATION_ID = LOCATIONS.LOCATION_ID(+)
  AND LOCATIONS.COUNTRY_ID = COUNTRIES.COUNTRY_ID(+)
  AND COUNTRIES.REGION_ID = REGIONS.REGION_ID(+);
  
  
SELECT EMPLOYEES.FIRST_NAME, EMPLOYEES.LAST_NAME, JOBS.JOB_TITLE, DEPARTMENTS.DEPARTMENT_NAME, LOCATIONS.CITY, COUNTRIES.COUNTRY_NAME, REGIONS.REGION_NAME
FROM JOBS JOIN EMPLOYEES
ON JOBS.JOB_ID = EMPLOYEES.JOB_ID
        LEFT JOIN DEPARTMENTS
        ON EMPLOYEES.DEPARTMENT_ID = DEPARTMENTS.DEPARTMENT_ID
        LEFT JOIN LOCATIONS
        ON DEPARTMENTS.LOCATION_ID = LOCATIONS.LOCATION_ID
        LEFT JOIN COUNTRIES
        ON LOCATIONS.COUNTRY_ID = COUNTRIES.COUNTRY_ID
        LEFT JOIN REGIONS
        ON COUNTRIES.REGION_ID = REGIONS.REGION_ID;




=== 20190403_01_scott.sql ===

SELECT USER
FROM DUAL;
--==>> SCOTT

--■■■ UNION / UNION ALL ■■■--

--○ 실습 테이블 생성 (TBL_JUMUN)
CREATE TABLE TBL_JUMUN              -- 주문 테이블 생성
( JUNO      NUMBER                  -- 주문 번호
, JECODE    VARCHAR2(30)            -- 주문된 제품 코드
, JUSU      NUMBER                  -- 주문 수량
, JUDAY     DATE DEFAULT SYSDATE    -- 주문 일자
);
--==>> Table TBL_JUMUN이(가) 생성되었습니다.
--> 고객의 주문이 발생했을 경우 주문 내용에 대한 데이터가
--  입력될 수 있는 테이블

--○ 데이터 입력 → 고객의 주문 발생 / 접수
INSERT INTO TBL_JUMUN VALUES (1, '홈런볼', 20, TO_DATE('2001-11-01 09:00:10', 'YYYY-MM-DD HH24:MI:SS'));
INSERT INTO TBL_JUMUN VALUES (2, '꼬깔콘', 10, TO_DATE('2001-11-01 09:23:24', 'YYYY-MM-DD HH24:MI:SS'));
INSERT INTO TBL_JUMUN VALUES (3, '나쵸', 30, TO_DATE('2001-11-02 12:00:11', 'YYYY-MM-DD HH24:MI:SS'));
INSERT INTO TBL_JUMUN VALUES (4, '포카칩', 10, TO_DATE('2001-11-02 15:16:17', 'YYYY-MM-DD HH24:MI:SS'));
INSERT INTO TBL_JUMUN VALUES (5, '웨하스', 10, TO_DATE('2001-11-03 10:22:33', 'YYYY-MM-DD HH24:MI:SS'));
INSERT INTO TBL_JUMUN VALUES (6, '웨하스', 12, TO_DATE('2001-11-04 16:00:00', 'YYYY-MM-DD HH24:MI:SS'));
INSERT INTO TBL_JUMUN VALUES (7, '홈런볼', 50, TO_DATE('2001-11-06 11:11:11', 'YYYY-MM-DD HH24:MI:SS'));
INSERT INTO TBL_JUMUN VALUES (8, '포카칩', 40, TO_DATE('2001-11-10 19:00:00', 'YYYY-MM-DD HH24:MI:SS'));
INSERT INTO TBL_JUMUN VALUES (9, '꼬깔콘', 10, TO_DATE('2001-11-13 09:14:03', 'YYYY-MM-DD HH24:MI:SS'));
INSERT INTO TBL_JUMUN VALUES (10, '꿀꽤배기', 20, TO_DATE('2001-11-13 14:20:00', 'YYYY-MM-DD HH24:MI:SS'));
--==>> 1 행 이(가) 삽입되었습니다. * 10

ALTER SESSION SET NLS_DATE_FORMAT = 'YYYY-MM-DD HH24:MI:SS';
--==>> Session이(가) 변경되었습니다.

--○ 확인
SELECT *
FROM TBL_JUMUN;
--==>>
/*
1	홈런볼	    20	2001-11-01 09:00:10
2	꼬칼콘	    10	2001-11-01 09:23:24
3	나쵸	    30	2001-11-02 12:00:11
4	포카칩	    10	2001-11-02 15:16:17
5	웨하스	    10	2001-11-03 10:22:33
6	웨하스	    12	2001-11-04 16:00:00
7	홈런볼	    50	2001-11-06 11:11:11
8	포카칩	    40	2001-11-10 19:00:00
9	꼬칼콘	    10	2001-11-13 09:14:03
10	꿀꽤배기	20	2001-11-13 14:20:00
*/

--○ 커밋
COMMIT;
--==>> 커밋 완료.


--○ 데이터 추가 입력 → 2001년 부터 시작된 주문이 현재(2019년)까지 계속 발생
INSERT INTO TBL_JUMUN VALUES (98765, '홈런볼', 10, SYSDATE);
--==>> 1 행 이(가) 삽입되었습니다.
INSERT INTO TBL_JUMUN VALUES (98766, '뽀빠이', 20, SYSDATE);
--==>> 1 행 이(가) 삽입되었습니다.
INSERT INTO TBL_JUMUN VALUES (98767, '포테토칩', 30, SYSDATE);
--==>> 1 행 이(가) 삽입되었습니다.
INSERT INTO TBL_JUMUN VALUES (98768, '웨하스', 10, SYSDATE);
--==>> 1 행 이(가) 삽입되었습니다.
INSERT INTO TBL_JUMUN VALUES (98769, '웨하스', 20, SYSDATE);
--==>> 1 행 이(가) 삽입되었습니다.
INSERT INTO TBL_JUMUN VALUES (98770, '꼬깔콘', 20, SYSDATE);
--==>> 1 행 이(가) 삽입되었습니다.
INSERT INTO TBL_JUMUN VALUES (98771, '홈런볼', 20, SYSDATE);
--==>> 1 행 이(가) 삽입되었습니다.
INSERT INTO TBL_JUMUN VALUES (98772, '초코송이', 10, SYSDATE);
--==>> 1 행 이(가) 삽입되었습니다.
INSERT INTO TBL_JUMUN VALUES (98773, '홈런볼', 30, SYSDATE);
--==>> 1 행 이(가) 삽입되었습니다.
INSERT INTO TBL_JUMUN VALUES (98774, '초코칩', 20, SYSDATE);
--==>> 1 행 이(가) 삽입되었습니다.


--○ 확인
SELECT *
FROM TBL_JUMUN;
--==>>
/*
1	    홈런볼	    20	2001-11-01 09:00:10
2	    꼬칼콘	    10	2001-11-01 09:23:24
3	    나쵸	    30	2001-11-02 12:00:11
4	    포카칩	    10	2001-11-02 15:16:17
5	    웨하스	    10	2001-11-03 10:22:33
6	    웨하스	    12	2001-11-04 16:00:00
7	    홈런볼	    50	2001-11-06 11:11:11
8	    포카칩	    40	2001-11-10 19:00:00
9	    꼬칼콘	    10	2001-11-13 09:14:03
10	    꿀꽤배기	20	2001-11-13 14:20:00
                    :
                    :
98765	홈런볼	    10	2019-04-03 09:25:09
98766	뽀빠이	    20	2019-04-03 09:25:47
98767	포테토칩	30	2019-04-03 09:26:45
98768	웨하스	    10	2019-04-03 09:27:02
98769	웨하스	    20	2019-04-03 09:27:47
98770	꼬깔콘	    20	2019-04-03 09:28:22
98771	홈런볼	    20	2019-04-03 09:29:14
98772	초코송이	10	2019-04-03 09:29:44
98773	홈런볼	    30	2019-04-03 09:30:29
98774	초코칩	    20	2019-04-03 09:31:19
*/

--※ 과자 쇼핑몰 운영중
--   TBL_JUMUN 테이블이 너무 무거워진 상황
--   어플리케이션과의 연동으로 인해 주문 내역을 다른 테이블에
--   저장될 수 있도록 만드는 것은 불가능한 상황
--   기존의 모든 데이터를 덮어놓고 지우는 것도 불가능한 상황
--   → 결과적으로 현재까지 누적된 주문 데이터 중
--      금일 발생한 주문 내역을 제외하고 나머지를 다른 테이블(TBL_JUMUNBACKUP)로
--      데이터 이관을 수행할 계획


SELECT *
FROM TBL_JUMUN
WHERE TO_CHAR(JUDAY, 'YYYY-MM-DD') != TO_CHAR(SYSDATE, 'YYYY-MM-DD');
--==>>
/*
1	홈런볼	20	2001-11-01 09:00:10
2	꼬칼콘	10	2001-11-01 09:23:24
3	나쵸	30	2001-11-02 12:00:11
4	포카칩	10	2001-11-02 15:16:17
5	웨하스	10	2001-11-03 10:22:33
6	웨하스	12	2001-11-04 16:00:00
7	홈런볼	50	2001-11-06 11:11:11
8	포카칩	40	2001-11-10 19:00:00
9	꼬칼콘	10	2001-11-13 09:14:03
10	꿀꽤배기	20	2001-11-13 14:20:00
*/


--○ 위의 조회 결과로 TBL_JUMUNBACKUP 테이블 생성
CREATE TABLE TBL_JUMUNBACKUP
AS
SELECT *
FROM TBL_JUMUN
WHERE TO_CHAR(JUDAY, 'YYYY-MM-DD') != TO_CHAR(SYSDATE, 'YYYY-MM-DD');
--==> Table TBL_JUMUNBACKUP이(가) 생성되었습니다.

--○ 확인
SELECT *
FROM TBL_JUMUNBACKUP;
--==>>
/*
1	홈런볼	    20	2001-11-01 09:00:10
2	꼬칼콘	    10	2001-11-01 09:23:24
3	나쵸	    30	2001-11-02 12:00:11
4	포카칩	    10	2001-11-02 15:16:17
5	웨하스	    10	2001-11-03 10:22:33
6	웨하스	    12	2001-11-04 16:00:00
7	홈런볼	    50	2001-11-06 11:11:11
8	포카칩	    40	2001-11-10 19:00:00
9	꼬칼콘	    10	2001-11-13 09:14:03
10	꿀꽤배기	20	2001-11-13 14:20:00
*/
--> TBL_JUMUN 테이블의 데이터들 중
--  금일 주문내역 이외의 데이터는 모두 TBL_JUMUNBACKUPP 에 백업을 마친 상태


--○ TBL_JUMUN 테이블의 데이터들 중
--   백업을 마친 데이터들 삭제 → 금일 주문이 아닌 데이터들 제거
DELETE
FROM TBL_JUMUN
WHERE TO_CHAR(JUDAY, 'YYYY-MM-DD') != TO_CHAR(SYSDATE, 'YYYY-MM-DD');
--==>> 10개 행 이(가) 삭제되었습니다.

-- 아직 제품 발송이 완료되지 않은 금일 주문 데이터를 제외하고
-- 이전의 모든 주문 데이터들이 삭제된 상황이므로
-- 테이블은 행(레코드)의 갯수가 줄어들어 배우 가벼워진 상황

--○ 확인
SELECT *
FROM TBL_JUMUN;
--==>>
/*
98765	홈런볼	    10	2019-04-03 09:25:09
98766	뽀빠이	    20	2019-04-03 09:25:47
98767	포테토칩	30	2019-04-03 09:26:45
98768	웨하스	    10	2019-04-03 09:27:02
98769	웨하스	    20	2019-04-03 09:27:47
98770	꼬깔콘	    20	2019-04-03 09:28:22
98771	홈런볼	    20	2019-04-03 09:29:14
98772	초코송이	10	2019-04-03 09:29:44
98773	홈런볼	    30	2019-04-03 09:30:29
98774	초코칩	    20	2019-04-03 09:31:19
*/

--○ 커밋
COMMIT;
--==>> 커밋 완료.

-- 그런데, 지금까지 주문받은 내역에 대한 정보를
-- 제품별 총 주문량으로 나타내야 할 상황이 발생하게 되었다.
-- 그렇다면 TBL_JUMUNBACKUP 테이블의 레코드(행)과
-- TBL_JUMUN 테이블의 레코드(행)을 합쳐서 하나의 테이블을
-- 조회하는 것과 같은 결과를 확인할 수 있도록 조회해야 한다.

-- 컬럼과 컬럼의 관계를 고려하여 테이블을 결합하고자 하는 경우 JOIN 을 사용하지만
-- 레코드(행)와 레코드(행)을 결합하고자 하는 경우 UNION / UNION ALL 을 사용할 수 있다.

SELECT *
FROM TBL_JUMUNBACKUP
UNION
SELECT *
FROM TBL_JUMUN;

SELECT *
FROM TBL_JUMUNBACKUP
UNION ALL
SELECT *
FROM TBL_JUMUN;


SELECT *
FROM TBL_JUMUN
UNION
SELECT *
FROM TBL_JUMUNBACKUP;
--==>> 
/*
1	    홈런볼	    20	2001-11-01 09:00:10
2	    꼬칼콘	    10	2001-11-01 09:23:24
3	    나쵸	    30	2001-11-02 12:00:11
4	    포카칩	    10	2001-11-02 15:16:17
5	    웨하스	    10	2001-11-03 10:22:33
6	    웨하스	    12	2001-11-04 16:00:00
7	    홈런볼	    50	2001-11-06 11:11:11
8	    포카칩	    40	2001-11-10 19:00:00
9	    꼬칼콘	    10	2001-11-13 09:14:03
10	    꿀꽤배기	20	2001-11-13 14:20:00
98765	홈런볼	    10	2019-04-03 09:25:09
98766	뽀빠이	    20	2019-04-03 09:25:47
98767	포테토칩	30	2019-04-03 09:26:45
98768	웨하스	    10	2019-04-03 09:27:02
98769	웨하스	    20	2019-04-03 09:27:47
98770	꼬깔콘	    20	2019-04-03 09:28:22
98771	홈런볼	    20	2019-04-03 09:29:14
98772	초코송이	10	2019-04-03 09:29:44
98773	홈런볼	    30	2019-04-03 09:30:29
98774	초코칩	    20	2019-04-03 09:31:19
*/

SELECT *
FROM TBL_JUMUN
UNION ALL
SELECT *
FROM TBL_JUMUNBACKUP;
--==>>
/*
98765	홈런볼	    10	2019-04-03 09:25:09
98766	뽀빠이	    20	2019-04-03 09:25:47
98767	포테토칩	30	2019-04-03 09:26:45
98768	웨하스	    10	2019-04-03 09:27:02
98769	웨하스	    20	2019-04-03 09:27:47
98770	꼬깔콘	    20	2019-04-03 09:28:22
98771	홈런볼	    20	2019-04-03 09:29:14
98772	초코송이	10	2019-04-03 09:29:44
98773	홈런볼	    30	2019-04-03 09:30:29
98774	초코칩	    20	2019-04-03 09:31:19
1	    홈런볼	    20	2001-11-01 09:00:10
2	    꼬칼콘	    10	2001-11-01 09:23:24
3	    나쵸	    30	2001-11-02 12:00:11
4	    포카칩	    10	2001-11-02 15:16:17
5	    웨하스	    10	2001-11-03 10:22:33
6	    웨하스	    12	2001-11-04 16:00:00
7	    홈런볼	    50	2001-11-06 11:11:11
8	    포카칩	    40	2001-11-10 19:00:00
9	    꼬칼콘	    10	2001-11-13 09:14:03
10	    꿀꽤배기	20	2001-11-13 14:20:00
*/

--※ UNION 은 항상 결과물이 첫 번째 컬럼을 기준으로
--   오름차순 정렬을 수행한다.
--   UNION ALL 은 결합된 순서대로 조회한 결과를 반환한다. (정렬 없음)
--   이로 인해 UNION 이 부하가 더 크다.
--   또한, UNION 은 결과물에서 중복된 행이 존재할 경우
--   중복을 제거하고 1개 행만 조회된 결과를 반환한다.


--○ 지금까지 주문받은 모든 데이터를 통해 
--   제품별 총 주문량을 조회하는 쿼리문을 구성한다.
/*
----------------------------------------------------
    제품코드        총 주문량
----------------------------------------------------
*/

SELECT T.제품코드, SUM(T.주문량)
FROM
(
    SELECT JECODE"제품코드", JUSU"주문량"
    FROM TBL_JUMUN
    UNION ALL
    SELECT JECODE"제품코드", JUSU"주문량"
    FROM TBL_JUMUNBACKUP
)T
GROUP BY T.제품코드;
--==>>
/*
꼬깔콘	    40
포테토칩	30
웨하스	    52
초코칩	    20
뽀빠이	    20
나쵸	    30
초코송이	10
포카칩	    50
꿀꽤배기	20
홈런볼	   130
*/
--> 이 문제를 해결하는 과정에서는 UNION 을 사용해서는 안된다.
--  → JECODE 와 JUSU 를 조회하는 과정에서 중복된 행을 제거하는 상황 발생!!


--○ INTERSECT / MINUS (→ 교집합 / 차집합)

-- TBL_JUMUNBACKUP 테이블과 TBL_JUMUN 테이블에서
-- 제품코드와 주문량의 값이 똑같은 행만 추출하고자 한다.
SELECT JECODE, JUSU
FROM TBL_JUMUNBACKUP
INTERSECT
SELECT JECODE, JUSU
FROM TBL_JUMUN;
--==>>
/*
웨하스	10
홈런볼	20
*/


--○ TBL_JUMUNBACKUP 테이블과 TBL_JUMUN 테이블에서
--   제품코드와 주문량의 값이 똑같은 행의 정보를
--   주문번호, 제품코드, 주문수량, 주문일자 항목으로 조회한다.

-- 방법1.
SELECT T2.JUNO"주문번호", T1.JECODE"제품코드", T1.JUSU"주문수량", T2.JUDAY"주문일자"
FROM 
(
    SELECT JUNO, JECODE, JUSU, JUDAY
    FROM TBL_JUMUN
    UNION ALL
    SELECT JUNO, JECODE, JUSU, JUDAY
    FROM TBL_JUMUNBACKUP
)T2
JOIN
(
    SELECT JECODE, JUSU
    FROM TBL_JUMUNBACKUP
    INTERSECT
    SELECT JECODE, JUSU
    FROM TBL_JUMUN
)T1
ON T1.JECODE = T2.JECODE
AND T1.JUSU = T2.JUSU;

-- 방법2
SELECT T.*
FROM 
(
    SELECT JUNO, JECODE, JUSU, JUDAY
    FROM TBL_JUMUN
    UNION ALL
    SELECT JUNO, JECODE, JUSU, JUDAY
    FROM TBL_JUMUNBACKUP
)T
--WHERE JECODE||JUSU IN ('홈런볼20','웨하스10');
--WHERE CONCAT(JECODE, JUSU) IN ('홈런볼20','웨하스10');
WHERE CONCAT(JECODE, JUSU) = ANY ('홈런볼20', '웨하스10');

SELECT JECODE, JUSU
FROM TBL_JUMUNBACKUP
INTERSECT
SELECT JECODE, JUSU
FROM TBL_JUMUN;
--> ('웨하스','10','홈런볼','20')

SELECT CONCAT(JECODE, JUSU)
FROM TBL_JUMUNBACKUP
INTERSECT
SELECT CONCAT(JECODE, JUSU)
FROM TBL_JUMUN;

SELECT T.*
FROM 
(
    SELECT JUNO, JECODE, JUSU, JUDAY
    FROM TBL_JUMUNBACKUP
    UNION ALL
    SELECT JUNO, JECODE, JUSU, JUDAY
    FROM TBL_JUMUN
)T
WHERE CONCAT(T.JECODE, T.JUSU) = ANY (SELECT CONCAT(JECODE, JUSU)
                                  FROM TBL_JUMUNBACKUP
                                  INTERSECT
                                  SELECT CONCAT(JECODE, JUSU)
                                  FROM TBL_JUMUN);
--==>>
/*
1	    홈런볼	20	2001-11-01 09:00:10
5	    웨하스	10	2001-11-03 10:22:33
98768	웨하스	10	2019-04-03 10:46:16
98771	홈런볼	20	2019-04-03 10:46:16
*/

SELECT *
FROM 
(
    SELECT *
    FROM TBL_JUMUN
    UNION ALL
    SELECT *
    FROM TBL_JUMUNBACKUP
)T,
(
    SELECT JECODE, JUSU
    FROM TBL_JUMUNBACKUP
    INTERSECT
    SELECT JECODE, JUSU
    FROM TBL_JUMUN
)Q
WHERE(T.JECODE = Q.JECODE AND T.JUSU = Q.JUSU);


--MINUS : 차집합

SELECT JECODE, JUSU
FROM TBL_JUMUNBACKUP
INTERSECT
SELECT JECODE, JUSU
FROM TBL_JUMUN;
--==>>
/*
웨하스	10
홈런볼	20
*/

SELECT JECODE, JUSU
FROM TBL_JUMUNBACKUP
MINUS
SELECT JECODE, JUSU
FROM TBL_JUMUN;
--==>>
/*
꼬깔콘	    10
꿀꽤배기	20
나쵸	    30
웨하스	    12
포카칩	    10
포카칩	    40
홈런볼	    50
*/

/*
    A = {10, 20, 30, 40, 50}
    B = {10, 20, 30}
    
    A - B = {40, 50}
*/


SELECT D.DEPTNO, D.DNAME, E.ENAME, E.SAL
FROM EMP E JOIN DEPT D
ON E.DEPTNO = D.DEPTNO;

-- CHECK!
SELECT DEPTNO, DNAME, ENAME, SAL
FROM EMP NATURAL JOIN DEPT;

SELECT DEPTNO, DNAME, ENAME, SAL
FROM EMP JOIN DEPT
USING(DEPTNO);
-- 권장하지않음




=== 20190403_02_hr.sql ===

SELECT USER
FROM DUAL;
--==>> HR


------------------------------------------------------------------------------------------------------------

--■■■ 정규화(Nomalization) ■■■--

--○ 정규화란?
--   한 마디로 데이터베이스 서버의 메모리 낭비를 막기 위해
--   어떤 하나의 테이블을 식별자를 가리는 여러 개의 테이블로
--   나누는 과정을 말한다.

-- ex) 진석이가 옥장판을 판매한다.
--     고객리스트 → 거래처직원 명단이 적혀있는 수첩의 정보를
--     데이터베이스화 하려고 한다.

-- 테이블명 : 거래처직원
/* 
   10Byte     10Byte     10Byte          10Byte    10Byte  10Byte     10Byte
---------------------------------------------------------------------------------
거래처회사명 회사주소    회사전화     거래처직원명  직급   이메일     휴대폰
---------------------------------------------------------------------------------
    LG       서울여의도  02-3456-7890    곽한얼     부장   khy@na...  010-...
    LG       서울여의도  02-3456-7890    권홍비     과장   khb@na...  010-...
    LG       서울여의도  02-3456-7890    김경환     대장   kkh@na...  010-...
    LG       서울여의도  02-3456-7890    김선아     부장   ksa@na...  010-...
    SK       서울소공동  02-1234-5678    김성희     대리   ksh@na...  010-...
    LG       부산동래구  051-9999-9999   남상현     대리   nsh@na...  010-...
                                    :
                                    :
---------------------------------------------------------------------------------
*/

/*
가정) 서울 여의도 LG 라는 회사에 근무하는 거래처 직원 명단이
      총 100만 명이라고 한다.
      (한 행(레코드)은 70Byte 이다.)
      
      어느날 『서울 여의도』에 위치한 『LG』 본사가
      『경기 분당』으로 사옥을 이전하게 되었다.
      이로 인해
      회사 주소는 『경기 분당』으로 바뀌고,
      회사 전화는 『031-1111-2222』로 바뀌게 되었다.
      
      그러면 100만 명의 회사주소와 회사전화를 변경해야 한다.
      
      - 이 때 수행되어야 할 쿼리문 → UPDATE 구문
      
        UPDATE 거래처직원
        SET 회사주소='경기분당', 회사전화='031-1111-2222'
        WHERE 거래처회사명='LG'
          AND 회사주소='서울여의도';
          
      --> 100만 개 행을 하드디스크상에서 읽어다가
          메모리에 로드시켜주어야 한다.
          즉, 100만 * 70Byte 를 모두
          하드디스크상에서 읽어다가 메모리에 로드시켜 주어야 한다는 말이다.
          
          --> 이는 테이블의 설계가 잘못되었으므로
              DB서버는 조만간 메모리 고갈로 인해 DOWN 될 것이다.
              
              --> 그러므로 정규화 과정을 수행해야 한다.
*/

--※ 테이블이 분할(분리)되기 이전 상태로 조회
SELECT A.거래처회사명 , A.회사주소, A.회사전화
     , B.거래처직원명, B.직급, B.이메일, B.휴대폰
FORM 회사 A.직원 B
WHERE A.회사ID = B.회사ID;


--○ 제 1 정규화
--> 어떤 하나의 테이블에 반복되어 컬럼 값들이 존재한다면
--  값들이 반복되어 나오는 컬럼을 분리하여
--  새로운 테이블을 만들어준다.

--> 제 1정규화를 수행하는 과정에서 분리된 테이블은
--  반드시 부모 테이블과 자식 테이블의 관계를 갖게 된다. 

--> 부모 테이블 → 참조받는 컬럼 → PRIMARY KEY 
--  자식 테이블 → 참조하는 컬럼 → FOREIGN KEY

--※ 참조받는 컬림이 갖는 특징(부모 테이블)
--   - 반드시 고유한 값(데이터)이 들어와야 한다.
--     즉, 중복된 값(데이터)이 없어야 한다.
--   - NULL 이 있어서는 안된다.(NOT NULL 이어야 한다.)

--> 제 1 정규화를 수행하는 과정에서 부모 테이블의 PRIMARY KEY 는
--  항상 자식 테이블의 FOREIGN KEY 로 전이된다.


/* 

테이블 명 : 회사 → 부모 테이블
10Byte      10Byte     10Byte     10Byte        
-----------------------------------------------
회사ID   거래처회사명 회사주소    회사전화     
------
(참조받는 컬럼 → P.K)
-----------------------------------------------
 10          LG       서울여의도  02-3456-7890      → 여러개 있을 필요 없어서 하나만
 20          SK       서울소공동  02-1234-5678    
 30          LG       부산동래구  051-9999-9999 
-----------------------------------------------

테이블명 : 직원 → 자식 테이블
   10Byte    10Byte  10Byte     10Byte
-------------------------------------------------
거래처직원명  직급   이메일     휴대폰    회사ID
                                          ------
                                          (참조하는 컬럼 → F.K(NULL가능))
-------------------------------------------------
  곽한얼     부장   khy@na...  010-...      10
  권홍비     과장   khb@na...  010-...      10
  김경환     대장   kkh@na...  010-...      10
  김선아     부장   ksa@na...  010-...      10
  김성희     대리   ksh@na...  010-...      20
  남상현     대리   nsh@na...  010-...      30
                     :
                     :
------------------------------------------------
*/

/*
가정) 서울 여의도 LG 라는 회사에 근무하는 거래처 직원 명단이
      총 100만 명이라고 한다.

      어느날 『서울 여의도』에 위치한 『LG』 본사가
      『경기 분당』으로 사옥을 이전하게 되었다.
      이로 인해
      회사 주소는 『경기 분당』으로 바뀌고,
      회사 전화는 『031-1111-2222』로 바뀌게 되었다.
      
      그러면 회사 테이블에서 1건의 회사주소와 회사전화를 변경해야 한다.
      
      - 이 때 수행되어야 할 쿼리문 → UPDATE 구문
      
        UPDATE 회사
        SET 회사주소='경기분당', 회사전화='031-1111-2222'
        WHERE 회사ID=10
        
        --> 1개 행을 하드디스크상에서 읽어다가
          메모리에 로드시켜주어야 한다.
          즉, 1 * 40Byte 를 모두
          하드디스크상에서 읽어다가 메모리에 로드시켜 주면 된다는 말이다.
          
          --> 이는 테이블 설계가 잘 된 상황이다.
              
              --> 정규화를 수행하기 이전에는 100만 건을 처리해야 할 업무에서
                  1건만 처리하면 되는 업무로 바뀐 상황이기 때문에
                  DB서버는 메모리에  고갈없이 아주 빠르게 처리될 것이다.
*/

-- A. 거래처회사명, 회사전화
/*
SELECT 거래처회사명, 회사전화         | SELECT 거래처회사명, 회사전화
FROM 회사                             | FROM 거래처직원
--> 3 * 40Byte                        | --> 200만 * 70Byte
*/

-- B. 거래처직원명, 직급
/*
SELECT 거래처직원명, 직급             | SELECT 거래처직원명, 직급
FROM 직원                             | FROM 거래처직원
--> 200만 * 50Byte                    | --> 200만 * 70Byte
*/

-- C. 거래처회사명, 거래처직원명
/*
SELECT 회사.거래처회사명, 직원.거래처직원명     | SELECT 거래처회사명, 거래처직원명
FROM 회사 JOIN 직원                             | FROM 거래처직원
ON 회사.회사ID = 직원.회사ID                    | --> 200만 * 70Byte
--> (3*40Btye) + (200만*50Byte)                 
*/


/*
-- 테이블명 : 주문
---------------------------------------------------------------------------------
  고객ID              제품코드            주문일자                주문수량
  ++++++++++++++++++++++++++++++++++++++++++++++++
                       (P.K)
---------------------------------------------------------------------------------
  CSY1227(조수연)     SWK9984(새우깡)     2019-04-02 11:11:11        50
  KHE7733(곽한얼)     YPR8866(양파링)     2019-04-02 12:12:12        30
  LJH7755(이지혜)     CPI1100(초파이)     2019-04-03 10:12:00        20
  LJH7755(이지혜)     SWK9984(새우깡)     2019-04-03 17:00:00        20
  KHE7733(곽한얼)     CPI1100(초파이)     2019-04-04 05:12:12        50
                                    :
                                    :
---------------------------------------------------------------------------------
*/

--※ 하나의 테이블에 존재하는 PRIMARY KEY 의 최대 갯수는 1개이다.
--   하지만, PRIMARY KEY 를 이루는(구성하는) 컬럼의 갯수는
--   복수(다수, 여러개)인 것이 가능하다.
--   컬럼 1개로만 (단일 컬럼) 구성된 PRIMARY KEY를
--   Single Primary Key 라고 부른다.
--   (단일 프라이머리 키)
--   두 개 이상의 컬럼으로 구성된 PRIMARY KEY를
--   Composite Primary Key 라고 부른다.
--   (복합 프라이머리 키)


--○ 제 2 정규화
--> 제 1 정규화를 마친 결과물에서 PRIMARY KEY 가 SINGLE COLUMN 이라면
--  제 2 정규화는 수행하지 않는다.
--  하지만, PRIMARY KEY 가 COMPOSITE COLUMN 이라면
--  반.드.시. 제 2정규화를 수행해야 한다.

--> 식별자가 아닌 컬럼은 식별자 전체 컬럼에 대해 의존적이어야 하는데
--  식별자 전체 컬럼이 아닌 일부 식별자 컬럼에 대해서만 의존적이라면
--  이를 분리하여 새로운 테이블 생성해 준다.

/*
테이블명 : 과목 → 부모 테이블
------------------------------------------------------------------------------------
과목번호    과목명       교수자번호  교수자명   강의실코드  강의실설명
++++++++                 ++++++++++
(P              .               K)
------------------------------------------------------------------------------------
JV0101      자바기초     21          슈바이처   A301        전산실습관 3층 30석 규모
JV0102      자바중급     22          테슬라     T502        전자공학관 5층 20석 규모
DB0102      오라클중급   22          테슬라     A201        전산실습관 2층 50석 규모
DB0102      오라클중급   10          장영실     T502        전자공학관 5층 20석 규모
DB0103      오라클고급   22          테슬라     A203        전산실습관 2층 90석 규모
JS0105      JSP심화      10          장영실     K101        인문사회관 1층 80석 규모
                                        :
                                        :
------------------------------------------------------------------------------------

테이블명 : 점수 → 자식 테이블
---------------------------------------------------
과목번호    교수자번호   학번      학생명     점수
======================
       (F.K)
++++++++                 ++++
(P           .             K)
---------------------------------------------------
DB0102      22           1902110   이기승     80
DB0102      22           1902127   윤희진     70
                        :
                        :
---------------------------------------------------
*/


--○ 제 3 정규화
--> 식별자가 아닌 컬럼이 식별자가 아닌 컬럼에 의존적인 상황이라면
--  이를 분리하여 새로운 테이블을 생성해 주어야 한다.


--※ 관계(Relation)의 종류

-- 1 : 1

-- 1 : 다
--> 제 1 정규화를 마친 결과물에서 나타나는 바람직한 관계.
--  관계형 데이터베이스를 활용하는 과정에서 추구해야 하는 관계.

-- 다 : 다
--> 논리적인 모델링에서는 존재할 수 있지만
--  실제 물리적인 모델링에서는 존재할 수 없는 관계.

/*
테이블명 : 고객 (다)                   테이블명 : 제품 (다)
---------------------------           ----------------------------
고객번호 고객명 이메일 ...            제품코드 제품명 제품단가 ...
++++++++                              ++++++++
 (P.K)                                 (P.K)
---------------------------           ----------------------------
  1100   이원영 ....                    swk    새우깡 1500
  1101   김선아 ....                    ggk    감자깡  700
  1102   임나래 ....                    ggc    자갈치  500
           :                                        :
           
           테이블명 : 주문등록 
           -------------------------------------
           고객번호 제품코드 주문일자 주문수량
           -------------------------------------
             1100     swk     ......     30
             1101     swk     ......     50
                            :
*/


--○ 제 4 정규화
-->  위에서 확인한 내용과 같이 『다:다』 관계를 『1:다』 관계로 깨뜨리는 과정이
--   제 4 정규화의 수행 과정이다.
--   → 일반적으로 파생 테이블 생성
--      → 『다:다』 관계를 『1:다』 관계로 깨뜨리는 역할 수행



--○ 역정규화(비정규화)
/*
--A 경우 → 역정규화를 수행하지 않는 것이 바람직한 경우

테이블명 : 부서                           테이블명 : 사원

      10        10       10          10        10     10    10     10       10       10
------------------------------     ----------------------------------------------- ------
부서번호   부서명   주소           사원번호  사원명  직급  급여  입사일  부서번호  부서명
++++++++                           ++++++++                              ========  ------
 (P.K)                              (P/K)                                 (F.K)
------------------------------     ----------------------------------------------- ------
              10개 행                                 1,000,000개 행
------------------------------     ----------------------------------------------- ------

>> 업무 분석 상 조회 결과물
---------------------------
부서명  사원명  직급  급여
---------------------------
 부서   사원    사원  사원
 
→ 『부서』테이블과 『사원』테이블을 JOIN 했을 때의 크기
    (10 * 30Byte) +  (1000000 * 60Byte) = 300 + 60000000 = 60000200Byte
     
→ 『사원』테이블을 역정규화 수행한 수 이 테이블만 읽어올 의 크기
    (즉, 부서 테이블의 부서명 컬럼을 사원 테이블에 추가한 경우)
     1000000 * 70Byte = 70000000Byte


--B 경우 → 역정규화를 수행하는 것이 바람직하다.

테이블명 : 부서                           테이블명 : 사원

  10        10       10                     10        10     10    10     10       10       10
-------------------------------------     ----------------------------------------------- ------
부서번호   부서명   주소                  사원번호  사원명  직급  급여  입사일  부서번호  부서명
++++++++                                  ++++++++                              ========  ------
 (P.K)                                     (P/K)                                 (F.K)
-------------------------------------     ----------------------------------------------- ------
        500,000개 행                                    1,000,000개 행
-------------------------------------     ----------------------------------------------- ------

>> 업무 분석 상 조회 결과물
---------------------------
부서명  사원명  직급  급여
---------------------------
 부서   사원    사원  사원
 
→ 『부서』테이블과 『사원』테이블을 JOIN 했을 때의 크기
    (500000 * 30Byte) +  (1000000 * 60Byte) = 15000000 + 60000000 = 75000000Byte
     
→ 『사원』테이블을 역정규화 수행한 수 이 테이블만 읽어올 의 크기
    (즉, 부서 테이블의 부서명 컬럼을 사원 테이블에 추가한 경우)
     1000000 * 70Byte = 70000000Byte
*/


/*
테이블명 : 사원 → 부모 테이블
---------------------------------------------------
사원번호   사원명   주민번호  입사일   급여   직급 
++++++++
 (P.K)
---------------------------------------------------
  7369     전훈의   9XXXXXXX  2010-XX  XXXX   부장
  7370     유진석   9XXXXXXX  2011-XX  XXXX   차장
  7371     최보라   9XXXXXXX  2010-XX  XXXX   과장
  7372     정임혜   9XXXXXXX  2010-XX  XXXX   대리 
  7373     조현우   9XXXXXXX  2010-XX  XXXX   사원
                        :
  
  
테이블명 : 사원가족 → 자식 테이블
-----------------------------------
주민번호   사원번호   관계    성명    
++++++++   ========
  (P.K)      (F.K)
-----------------------------------
9XXXXXX     7369      아내   아이유 
0XXXXXX     7369      아들   강동원  
9XXXXXX     7370      아내   이연희  
9XXXXXX     7371      남편   박형식
                :
                        
*/ 




=== 20190404_01_hr.sql ===

SELECT USER
FROM DUAL;
--==>> HR


/*
--※ 참고

1. 관계(relationship, relation)
   - 모든 엔트리(entry)는 단일값을 가진다. 
   - 각 열(column)은 유일한 이름을 가지며 순서는 무의미하다.
   - 테이블의 모든 행(row = 튜플 = tuple)은 동일하지 않으며 순서는 무의미하다.
   
2. 속성(attribute)
   - 테이블의 열(column)을 나타낸다.
   - 자료의 이름을 가진 최소 논리적 단위 : 객체의 성질, 상태 기술
   - 일반 파일(file)의 항목(아이템 = item = 필드 = field)에 해당한다.
   - 엔티티(entity)의 특성과 상태를 기술
   - 속성(attribute)의 이름은 모두 달라야 한다.
   
3. 튜플 = tuple = 엔티티 = entity
   - 테이블의 행(roe)
   - 연관된 몇 개의 속성으로 구성
   - 개념 정보 단위
   - 일반 파일(file)의 레코드(record)에 해당한다.
   - 튜플 변수(tuple variable)
     : 튜플(tuple)을 가리키는 변수, 모든 튜플 집합을 도메인으로 하는 변수
     
4. 도메인(domain)
   - 각 속성(attribute)이 가질 수 있도록 허용된 값들의 집합
   - 속성 명과 도메인 명이 반드시 동일할 필요는 없음
   - 모든 릴레이션에서 모든 속성들의 도메인은 원자적(atomic)이어야 함.
   - 원자적 도메인
     : 도메인의 원소가 더 이상 나누어질 수 없는 단일체일 때를 나타냄
   - (오라클 데이터타입으로 우선 이해)

5. 릴레이션(relation)
   - 파일 시스템에서 파일과 같은 개념
   - 중복된 튜플(tuple = entity = 엔티티)을 포함하지 않는다.
     → 모두 상이함(튜플의 유일성)
   - 릴레이션 = 튜플(엔티티 = entity)의 집합. 따라서 튜플의 순서는 무의미하다.
   - 속성(attribute)간에는 순서가 없다.
*/

---------------------------------------------------------------------------------------------

--■■■ 무결성(Integrity) ■■■--
/*
1. 무결성에는 개체 무결성(Entity Integrity)
              참조 무결성(Relational Integrity)
              도메인 무결성(Domain Integrity) 이 있다.

2. 개체 무결성
   개체 무결성은 릴레이션에서 저장되는 튜플(tuple)의
   유일성을 보장하기 위한 제약조건이다.

3. 참조 무결성
   참조 무결성은 릴레이션 간의 데이터 일관성을
   보장하기 위한 제약조건이다.

4. 도메인 무결성
   도메인 무결성은 허용 가능한 값의 범위를 
   지정하기 위한 제약조건이다.
   
5. 제약조건의 종류
   
   - PRIMARY KEY(PK:P) → 부모 테이블의 참조받는 컬럼 → 기본키, 식별자 
     해당 컬럼의 값은 반드시 존재해야 하며, 유일해야 한다.
     (UNIQUE 와 NOT NULL 이 결합된 형태)
     
   - FOREIGN KEY(FK:F:R) → 자식 테이블의 참조하는 컬럼 → 외부키, 외래키, 참조키
     해당 컬럼의 값은 참조되는 테이블의 컬럼 데이터들 중 하나와
     일치하거나 NULL 을 가진다.
    
   - UNIQRE(UK:U)
     테이블 내에서 해당 컬럼의 값은 항상 유일해야 한다.
     
   - NOT NULL(NN:CK:C)
     해당 컬럼은 NULL 을 포함할 수 없다.
   
   - CHECK(CK:C)
     해당 컬럼에서 저장 가능한 데이터의 값의 범위나 조건을 지정한다.
     
--○ 제약조건 제거
ALTER TABLE 테이블명
DROP CONSTARINT 제약조건명;
*/

---------------------------------------------------------------------------------------------------

--■■■ PRIMARY KEY ■■■--

-- 1. 테이블에 대한 기본 키를 생성한다.

-- 2. 테이블에서 각 행을 유일하게 식별하는 컬럼 또는 컬럼의 집합이다. (단일 OR 다중)
--    기본 키는 테이블 당 최대 하나만 존재한다.
--    그러나 반드시 하나의 컬럼으로만 구성되는 것은 아니다.
--    NULL 일 수 없고, 이미 테이블에 존재하고 있는 데이터를
--    다시 입력할 수 없도록 처리된다.
--    UNIQUE INDEX 가 자동으로 생성된다.
--    (오라클이 자체적으로 만든다.)

-- 3. 형식 및 구조
-- ① 컬럼 레벨의 형식
-- 컬럼명 데이터타입 [CONSTRAINT CONSTRAINT명] PRIMARY KEY[(컬럼명, ..)]

-- ② 테이블 레벨의 형식         (권장)
-- 컬럼명 데이터타입,
-- 컬럼명 데이터타입,
-- CONSTRAINT CONSTRAINT명 PRIMARY KEY(컬럼명, ...)

-- 4. CONSTRAINT 추가 시 CONSTRAINT명을 생략하면
--    오라클 서버가 자동적으로 CONSTRAINT 명을 부여하게 된다.
--    일반적으로 CONSTRAINT 명은 『테이블명_컬럼명_CONSTRAINT약어』
--    형식으로 기술한다.


--○ PK 지정 실습(① 컬럼 레벨의 형식)

-- 테이블 생성
CREATE TABLE TBL_TEST1
( COL1  NUMBER(5)       PRIMARY KEY
, COL2  VARCHAR(30)
);
--==>> Table TBL_TEST1이(가) 생성되었습니다.

-- 데이터 입력
INSERT INTO TBL_TEST1(COL1, COL2) VALUES(1, 'TEST');
INSERT INTO TBL_TEST1(COL1, COL2) VALUES(2, 'ABCD');
INSERT INTO TBL_TEST1(COL1, COL2) VALUES(3, NULL);
INSERT INTO TBL_TEST1(COL1) VALUES(4);
INSERT INTO TBL_TEST1(COL1, COL2) VALUES(2, 'ABCD');    --> 에러 발생
INSERT INTO TBL_TEST1(COL1, COL2) VALUES(5, 'ABCD');
INSERT INTO TBL_TEST1(COL1, COL2) VALUES(NULL, NULL);   --> 에러 벌생
INSERT INTO TBL_TEST1(COL1, COL2) VALUES(NULL, 'STUDY');--> 에러 발생
INSERT INTO TBL_TEST1(COL2) VALUES('STUDY');            --> 에러 발생


COMMIT;

SELECT *
FROM TBL_TEST1;
--==>>
/*
1	TEST
2	ABCD
3	
4	
5	ABCD
*/

DESC TBL_TEST1;
--==>>
/*
이름   널?       유형           
---- -------- ------------ 
COL1 NOT NULL NUMBER(5)    → PK 제약 확인 불가
COL2          VARCHAR2(30) 
*/

--○ 제약조건 확인
SELECT *
FROM USER_CONSTRAINTS;
--==>>
/*
HR	REGION_ID_NN	        C	REGIONS	        "REGION_ID" IS NOT NULL				                            ENABLED	NOT DEFERRABLE	IMMEDIATE	VALIDATED	    USER NAME			    14/05/29				
HR	REG_ID_PK	            P	REGIONS					                                                        ENABLED	NOT DEFERRABLE	IMMEDIATE	VALIDATED	    USER NAME			    14/05/29	HR	REG_ID_PK		
HR	COUNTRY_ID_NN	        C	COUNTRIES	    "COUNTRY_ID" IS NOT NULL				                        ENABLED	NOT DEFERRABLE	IMMEDIATE	VALIDATED	    USER NAME			    14/05/29				
HR	COUNTRY_C_ID_PK	        P	COUNTRIES					                                                    ENABLED	NOT DEFERRABLE	IMMEDIATE	VALIDATED	    USER NAME			    14/05/29	HR	COUNTRY_C_ID_PK		
HR	COUNTR_REG_FK	        R	COUNTRIES		                                HR	REG_ID_PK	NO ACTION	    ENABLED	NOT DEFERRABLE	IMMEDIATE	VALIDATED	    USER NAME			    14/05/29				
HR	LOC_CITY_NN	            C	LOCATIONS	    "CITY" IS NOT NULL				                                ENABLED	NOT DEFERRABLE	IMMEDIATE	VALIDATED	    USER NAME			    14/05/29				
HR	LOC_ID_PK	            P	LOCATIONS					                                                    ENABLED	NOT DEFERRABLE	IMMEDIATE	VALIDATED	    USER NAME			    14/05/29	HR	LOC_ID_PK		
HR	LOC_C_ID_FK	            R	LOCATIONS		                                HR	COUNTRY_C_ID_PK	NO ACTION	ENABLED	NOT DEFERRABLE	IMMEDIATE	VALIDATED	    USER NAME			    14/05/29				
HR	DEPT_NAME_NN	        C	DEPARTMENTS	    "DEPARTMENT_NAME" IS NOT NULL				                    ENABLED	NOT DEFERRABLE	IMMEDIATE	VALIDATED	    USER NAME			    14/05/29				
HR	DEPT_ID_PK	            P	DEPARTMENTS					                                                    ENABLED	NOT DEFERRABLE	IMMEDIATE	VALIDATED	    USER NAME			    14/05/29	HR	DEPT_ID_PK		
HR	DEPT_LOC_FK	            R	DEPARTMENTS		                                HR	LOC_ID_PK	NO ACTION	    ENABLED	NOT DEFERRABLE	IMMEDIATE	VALIDATED	    USER NAME			    14/05/29				
HR	JOB_TITLE_NN	        C	JOBS	        "JOB_TITLE" IS NOT NULL				                            ENABLED	NOT DEFERRABLE	IMMEDIATE	VALIDATED	    USER NAME			    14/05/29				
HR	JOB_ID_PK	            P	JOBS					                                                        ENABLED	NOT DEFERRABLE	IMMEDIATE	VALIDATED	    USER NAME			    14/05/29	HR	JOB_ID_PK		
HR	EMP_LAST_NAME_NN	    C	EMPLOYEES	    "LAST_NAME" IS NOT NULL				                            ENABLED	NOT DEFERRABLE	IMMEDIATE	VALIDATED	    USER NAME			    14/05/29				
HR	EMP_EMAIL_NN	        C	EMPLOYEES	    "EMAIL" IS NOT NULL				                                ENABLED	NOT DEFERRABLE	IMMEDIATE	VALIDATED	    USER NAME			    14/05/29				
HR	EMP_HIRE_DATE_NN	    C	EMPLOYEES	    "HIRE_DATE" IS NOT NULL				                            ENABLED	NOT DEFERRABLE	IMMEDIATE	VALIDATED	    USER NAME			    14/05/29				
HR	EMP_JOB_NN	            C	EMPLOYEES	    "JOB_ID" IS NOT NULL				                            ENABLED	NOT DEFERRABLE	IMMEDIATE	VALIDATED	    USER NAME			    14/05/29				
HR	EMP_SALARY_MIN	        C	EMPLOYEES	    salary > 0				                                        ENABLED	NOT DEFERRABLE	IMMEDIATE	VALIDATED	    USER NAME			    14/05/29				
HR	EMP_EMAIL_UK	        U	EMPLOYEES					                                                    ENABLED	NOT DEFERRABLE	IMMEDIATE	VALIDATED	    USER NAME			    14/05/29	HR	EMP_EMAIL_UK		
HR	EMP_EMP_ID_PK	        P	EMPLOYEES					                                                    ENABLED	NOT DEFERRABLE	IMMEDIATE	VALIDATED	    USER NAME			    14/05/29	HR	EMP_EMP_ID_PK		
HR	EMP_DEPT_FK	            R	EMPLOYEES		                                HR	DEPT_ID_PK	NO ACTION	    ENABLED	NOT DEFERRABLE	IMMEDIATE	VALIDATED	    USER NAME			    14/05/29				
HR	EMP_JOB_FK	            R	EMPLOYEES		                                HR	JOB_ID_PK	NO ACTION	    ENABLED	NOT DEFERRABLE	IMMEDIATE	VALIDATED	    USER NAME			    14/05/29				
HR	EMP_MANAGER_FK	        R	EMPLOYEES		                                HR	EMP_EMP_ID_PK	NO ACTION	ENABLED	NOT DEFERRABLE	IMMEDIATE	VALIDATED	    USER NAME			    14/05/29				
HR	DEPT_MGR_FK	            R	DEPARTMENTS		                                HR	EMP_EMP_ID_PK	NO ACTION	ENABLED	NOT DEFERRABLE	IMMEDIATE	VALIDATED	    USER NAME			    14/05/29				
HR	JHIST_EMPLOYEE_NN	    C	JOB_HISTORY	    "EMPLOYEE_ID" IS NOT NULL				                        ENABLED	NOT DEFERRABLE	IMMEDIATE	VALIDATED	    USER NAME			    14/05/29				
HR	JHIST_START_DATE_NN	    C	JOB_HISTORY	    "START_DATE" IS NOT NULL				                        ENABLED	NOT DEFERRABLE	IMMEDIATE	VALIDATED	    USER NAME			    14/05/29				
HR	JHIST_END_DATE_NN	    C	JOB_HISTORY	    "END_DATE" IS NOT NULL				                            ENABLED	NOT DEFERRABLE	IMMEDIATE	VALIDATED	    USER NAME			    14/05/29				
HR	JHIST_JOB_NN	        C	JOB_HISTORY	    "JOB_ID" IS NOT NULL				                            ENABLED	NOT DEFERRABLE	IMMEDIATE	VALIDATED	    USER NAME			    14/05/29				
HR	JHIST_DATE_INTERVAL	    C	JOB_HISTORY	    end_date > start_date				                            ENABLED	NOT DEFERRABLE	IMMEDIATE	VALIDATED	    USER NAME			    14/05/29				
HR	JHIST_EMP_ID_ST_DATE_PK	P	JOB_HISTORY					                                                    ENABLED	NOT DEFERRABLE	IMMEDIATE	VALIDATED	    USER NAME			    14/05/29	HR	JHIST_EMP_ID_ST_DATE_PK		
HR	JHIST_JOB_FK	        R	JOB_HISTORY		                                HR	JOB_ID_PK	NO ACTION	    ENABLED	NOT DEFERRABLE	IMMEDIATE	VALIDATED	    USER NAME			    14/05/29				
HR	JHIST_EMP_FK	        R	JOB_HISTORY		                                HR	EMP_EMP_ID_PK	NO ACTION	ENABLED	NOT DEFERRABLE	IMMEDIATE	VALIDATED	    USER NAME			    14/05/29				
HR	JHIST_DEPT_FK	        R	JOB_HISTORY		                                HR	DEPT_ID_PK	NO ACTION	    ENABLED	NOT DEFERRABLE	IMMEDIATE	VALIDATED	    USER NAME			    14/05/29				
HR	SYS_C004102	            O	EMP_DETAILS_VIEW					                                            ENABLED	NOT DEFERRABLE	IMMEDIATE	NOT VALIDATED	GENERATED NAME			14/05/29				
HR	SYS_C007011	            P	TBL_TEST1					                                                    ENABLED	NOT DEFERRABLE	IMMEDIATE	VALIDATED	    GENERATED NAME			19/04/04	HR	SYS_C007011		
*/

SELECT *
FROM USER_CONSTRAINTS
WHERE TABLE_NAME = 'TBL_TEST1';
--==>>
/*
TBL_TEST1					ENABLED	NOT DEFERRABLE	IMMEDIATE	VALIDATED	GENERATED NAME			19/04/04	HR	SYS_C007011		
*/

--○ 제약조건이 지정된 컬럼 확인(조회)
SELECT *
FROM USER_CONS_COLUMNS;
--==>>
/*
HR	REGION_ID_NN	        REGIONS	    REGION_ID	
HR	REG_ID_PK	            REGIONS	    REGION_ID	    1
HR	COUNTRY_ID_NN	        COUNTRIES	COUNTRY_ID	    
HR	COUNTRY_C_ID_PK	        COUNTRIES	COUNTRY_ID	    1
HR	COUNTR_REG_FK	        COUNTRIES	REGION_ID	    1
HR	LOC_ID_PK	            LOCATIONS	LOCATION_ID	    1
HR	LOC_CITY_NN	            LOCATIONS	CITY	
HR	LOC_C_ID_FK	            LOCATIONS	COUNTRY_ID	    1
HR	DEPT_ID_PK	            DEPARTMENTS	DEPARTMENT_ID	1
HR	DEPT_NAME_NN	        DEPARTMENTS	DEPARTMENT_NAME	
HR	DEPT_MGR_FK	            DEPARTMENTS	MANAGER_ID	    1
HR	DEPT_LOC_FK	            DEPARTMENTS	LOCATION_ID	    1
HR	JOB_ID_PK	            JOBS	    JOB_ID	        1
HR	JOB_TITLE_NN	        JOBS	    JOB_TITLE	
HR	EMP_EMP_ID_PK	        EMPLOYEES	EMPLOYEE_ID	    1
HR	EMP_LAST_NAME_NN	    EMPLOYEES	LAST_NAME	
HR	EMP_EMAIL_NN	        EMPLOYEES	EMAIL	
HR	EMP_EMAIL_UK	        EMPLOYEES	EMAIL	        1
HR	EMP_HIRE_DATE_NN	    EMPLOYEES	HIRE_DATE	
HR	EMP_JOB_NN	            EMPLOYEES	JOB_ID	
HR	EMP_JOB_FK	            EMPLOYEES	JOB_ID	        1
HR	EMP_SALARY_MIN	        EMPLOYEES	SALARY	
HR	EMP_MANAGER_FK	        EMPLOYEES	MANAGER_ID	    1
HR	EMP_DEPT_FK	            EMPLOYEES	DEPARTMENT_ID	1
HR	JHIST_EMPLOYEE_NN	    JOB_HISTORY	EMPLOYEE_ID	
HR	JHIST_EMP_ID_ST_DATE_PK	JOB_HISTORY	EMPLOYEE_ID	    1
HR	JHIST_EMP_FK	        JOB_HISTORY	EMPLOYEE_ID	    1
HR	JHIST_START_DATE_NN	    JOB_HISTORY	START_DATE	
HR	JHIST_DATE_INTERVAL	    JOB_HISTORY	START_DATE	
HR	JHIST_EMP_ID_ST_DATE_PK	JOB_HISTORY	START_DATE	    2
HR	JHIST_END_DATE_NN	J   OB_HISTORY	END_DATE	
HR	JHIST_DATE_INTERVAL	    JOB_HISTORY	END_DATE	
HR	JHIST_JOB_NN	        JOB_HISTORY	JOB_ID	
HR	JHIST_JOB_FK	        JOB_HISTORY	JOB_ID	        1
HR	JHIST_DEPT_FK	        JOB_HISTORY	DEPARTMENT_ID	1
HR	SYS_C007011	            TBL_TEST1	COL1	        1
*/


SELECT *
FROM USER_CONS_COLUMNS
WHERE TABLE_NAME = 'TBL_TEST1';
--==>>
/*
HR	SYS_C007011	TBL_TEST1	COL1	1
*/

--○ 제약조건이 설정된 소유주, 제약명, 테이블명, 제약종류, 컬럼명, 항목조회
SELECT UC.OWNER, UC.CONSTRAINT_NAME, UC.TABLE_NAME, UC.CONSTRAINT_TYPE, UCC.COLUMN_NAME
FROM USER_CONSTRAINTS UC, USER_CONS_COLUMNS UCC
WHERE UC.CONSTRAINT_NAME = UCC.CONSTRAINT_NAME
  AND UC.TABLE_NAME = 'TBL_TEST1';
--==>>
/*
HR	SYS_C007011	TBL_TEST1	P	COL1
*/


--○ PK 지정 실습(② 테이블 레벨의 형식)
-- 테이블 생성
CREATE TABLE TBL_TEST2
( COL1 NUMBER(5)
, COL2 VARCHAR(30)
, CONSTRAINT TEST2_COL1_PK PRIMARY KEY(COL1)
);
--==>> Table TBL_TEST2이(가) 생성되었습니다.

-- 데이터 입력
INSERT INTO TBL_TEST2(COL1, COL2) VALUES(1, 'TEST');
INSERT INTO TBL_TEST2(COL1, COL2) VALUES(2, 'ABCD');
INSERT INTO TBL_TEST2(COL1, COL2) VALUES(3, NULL);
INSERT INTO TBL_TEST2(COL1) VALUES(4);
INSERT INTO TBL_TEST2(COL1, COL2) VALUES(2, 'ABCD');    --> 에러 발생
INSERT INTO TBL_TEST2(COL1, COL2) VALUES(5, 'ABCD');
INSERT INTO TBL_TEST2(COL1, COL2) VALUES(NULL, NULL);   --> 에러 벌생
INSERT INTO TBL_TEST2(COL1, COL2) VALUES(NULL, 'STUDY');--> 에러 발생
INSERT INTO TBL_TEST2(COL2) VALUES('STUDY');            --> 에러 발생

COMMIT;
--==>> 커밋 완료.

SELECT *
FROM TBL_TEST2;
--==>>
/*
1	TEST
2	ABCD
3	
4	
5	ABCD
*/

--○ 제약조건이 설정된 소유주, 제약명, 테이블명, 제약종류, 컬럼명, 항목조회
SELECT UC.OWNER, UC.CONSTRAINT_NAME, UC.TABLE_NAME, UC.CONSTRAINT_TYPE, UCC.COLUMN_NAME
FROM USER_CONSTRAINTS UC, USER_CONS_COLUMNS UCC
WHERE UC.CONSTRAINT_NAME = UCC.CONSTRAINT_NAME
  AND UC.TABLE_NAME = 'TBL_TEST2';
--==>> HR	TEST2_COL1_PK	TBL_TEST2	P	COL1


--○ PK 지정 실습(③ 다중 컬럼 PK 지정 → 복합 프라이머리 키)
CREATE TABLE TBL_TEST3
( COL1 NUMBER(5)
, COL2 VARCHAR(30)
, CONSTRAINT TEST3_COL1_COL2_PK PRIMARY KEY(COL1, COL2)     -- 이름지정 TBL_TEST3으로 안써도됨, 두줄로 나눠서 쓰면 안됨
);
--==>> Table TBL_TEST3이(가) 생성되었습니다.


-- 데이터 입력
INSERT INTO TBL_TEST3(COL1, COL2) VALUES(1, 'TEST');
INSERT INTO TBL_TEST3(COL1, COL2) VALUES(2, 'ABCD');
INSERT INTO TBL_TEST3(COL1, COL2) VALUES(3, NULL);      --> 에러발생
INSERT INTO TBL_TEST3(COL1) VALUES (4);                 --> 에러발생
INSERT INTO TBL_TEST3(COL1, COL2) VALUES(2, 'ABCD');    --> 에러발생
INSERT INTO TBL_TEST3(COL1, COL2) VALUES(3, 'ABCD');                    -- 두개가 모두 일치해야 중복된 값이다.
INSERT INTO TBL_TEST3(COL1, COL2) VALUES(1, 'ABCD');
INSERT INTO TBL_TEST3(COL1, COL2) VALUES(2, 'KKKK');
INSERT INTO TBL_TEST3(COL1, COL2) VALUES(NULL, NULL);   --> 에러 발생
INSERT INTO TBL_TEST3(COL1, COL2) VALUES(NULL, 'STUDY');--> 에러 발생
INSERT INTO TBL_TEST3(COL1, COL2) VALUES('STUDY');      --> 에러 발생    

COMMIT;
--==>> 커밋 완료.

--○ PK 지정 실습(④ 테이블 생성 이후 제약조건 추가 → PK 지정)
-- 테이블 생성
CREATE TABLE TBL_TEST4
( COL1 NUMBER(5)
, COL2 VARCHAR(30)
);
--==>> Table TBL_TEST4이(가) 생성되었습니다.

--※ 이미 만들어져 있는 테이블에
--   부여하려는 제약조건을 위반한 데이터가 포함되어 있을 경우
--   해당 테이블에 제약조건을 추가하는 것은 불가능하다.

-- 제약조건 추가
ALTER TABLE TBL_TEST4 
ADD CONSTRAINT TEST4_COL1_PK PRIMARY KEY(COL1);
--==>> Table TBL_TEST4이(가) 변경되었습니다.

-- 데이터 입력
INSERT INTO TBL_TEST4(COL1, COL2) VALUES(1, 'TEST');
INSERT INTO TBL_TEST4(COL1, COL2) VALUES(2, 'ABCD');
INSERT INTO TBL_TEST4(COL1, COL2) VALUES(3, NULL);
INSERT INTO TBL_TEST4(COL1) VALUES(4);
INSERT INTO TBL_TEST4(COL1, COL2) VALUES(2, 'ABCD');    --> 에러 발생
INSERT INTO TBL_TEST4(COL1, COL2) VALUES(5, 'ABCD');
INSERT INTO TBL_TEST4(COL1, COL2) VALUES(NULL, NULL);   --> 에러 벌생
INSERT INTO TBL_TEST4(COL1, COL2) VALUES(NULL, 'STUDY');--> 에러 발생
INSERT INTO TBL_TEST4(COL2) VALUES('STUDY');            --> 에러 발생

COMMIT;
--==>> 커밋 완료.

SELECT *
FROM TBL_TEST4;
--==>>
/*
1	TEST
2	ABCD
3	
4	
5	ABCD
*/

--※ 제약조건 확인용 전용 뷰(VIEW) 생성
CREATE OR REPLACE VIEW VIEW_CONSTCHECK
AS
SELECT UC.OWNER "OWNER"
     , UC.CONSTRAINT_NAME "CONSTRAINT_NAME"
     , UC.TABLE_NAME "TABLE_NAME"
     , UC.CONSTRAINT_TYPE "CONSTRAINT_TYPE"
     , UCC.COLUMN_NAME "COLUMN_NAME"
     , UC.SEARCH_CONDITION "SEARCH_CONDITION"
     , UC.DELETE_RULE "DELETE_RULE"
FROM USER_CONSTRAINTS UC JOIN USER_CONS_COLUMNS UCC
ON UC.CONSTRAINT_NAME = UCC.CONSTRAINT_NAME;
--==>>View VIEW_CONSTCHECK이(가) 생성되었습니다.

--○ 생성된 뷰(VIEW)를 통한 제약조건 확인
SELECT *
FROM VIEW_CONSTCHECK
WHERE TABLE_NAME = 'TBL_TEST4';
--==>> HR	TEST4_COL1_PK	TBL_TEST4	P	COL1		


-------------------------------------------------------------------------------------------------------

--■■■ UNIQUE(UK:U) ■■■--

-- 1. 테이블에 지정한 컬럼의 데이터가 중복되지 않고
--    테이블 내에서 유일할 수 있도록 설정하는 제약조건.
--    PRIMARY KEY 와 유사한 제약조건이지만, NULL 을 허용한다는 차이가 있다.
--    내부적으로 PRIMARY KEY 와 마찬가지고 UNIQUE INDEX 가 자동 생성된다.
--    하나의 테이블 내에서 UNIQUE 제약조건은 여러 번 설정하는 것이 가능하다.
--    즉, 하나의 테이블에 UNIQUE 제약조건을 여러 개 만드는 것이
--    가능하다는 것이다.

-- 2. 형식 및 구조
--① 컬럼 레벨의 형식
-- 컬럼명 데이터타입 [CONSTRAINT CONSTRAINT명] UNIQUE

--② 테이블 레벨의 형식
-- 컬럼명 데이터타입,
-- 컬럼명 데이터타입,
-- CONSTRAINT CONSTRAINT명 UNIQUE(컬럼명, ...)

--○ UK 지정 실습(① 컬럼 레벨의 형식)
-- 테이블 생성
CREATE TABLE TBL_TEST5
( COL1 NUMBER(5)        PRIMARY KEY
, COL2 VARCHAR2(30)     UNIQUE
);
--==>> Table TBL_TEST5이(가) 생성되었습니다.

-- 제약조건 조회
SELECT *
FROM VIEW_CONSTCHECK
WHERE TABLE_NAME='TBL_TEST5';
--==>>
/*
HR	SYS_C007015	TBL_TEST5	P	COL1		
HR	SYS_C007016	TBL_TEST5	U	COL2		
*/

-- 데이터 입력
INSERT INTO TBL_TEST5(COL1, COL2) VALUES(1, 'TEST');
INSERT INTO TBL_TEST5(COL1, COL2) VALUES(2, 'ABCD');
INSERT INTO TBL_TEST5(COL1, COL2) VALUES(3, NULL);
INSERT INTO TBL_TEST5(COL1) VALUES(4);
INSERT INTO TBL_TEST5(COL1, COL2) VALUES(4, 'ABCD');    --> 에러 발생
INSERT INTO TBL_TEST5(COL1, COL2) VALUES(2, 'ABCD');    --> 에러 발생
INSERT INTO TBL_TEST5(COL1, COL2) VALUES(NULL, NULL);   --> 에러 발생
INSERT INTO TBL_TEST5(COL1, COL2) VALUES(5, NULL);

COMMIT;
--==>> 커밋 완료.

SELECT *
FROM TBL_TEST5;
--==>>
/*
1	TEST
2	ABCD
3	
4	
5	
*/

--○ UK 지정 실습(② 테이블 레벨의 형식)
-- 테이블 생성
CREATE TABLE TBL_TEST6
( COL1 NUMBER(5)
, COL2 VARCHAR(30)
, CONSTRAINT TEST6_COL1_PK PRIMARY KEY(COL1)
, CONSTRAINT TEST6_COL2_UK UNIQUE(COL2)
);
--==>> Table TBL_TEST6이(가) 생성되었습니다.

-- 제약조건 확인
SELECT *
FROM VIEW_CONSTCHECK
WHERE TABLE_NAME = 'TBL_TEST6';
--==>>
/*
HR	TEST6_COL1_PK	TBL_TEST6	P	COL1		
HR	TEST6_COL2_UK	TBL_TEST6	U	COL2		
*/


--○ UK 지정 실습(③ 테이블 생성 이후 제약조건 추가 → UK 제약조건 추가)
-- 테이블 생성
CREATE TABLE TBL_TEST7
( COL1 NUMBER(5)
, COL2 VARCHAR(30)
);
--==>> Table TBL_TEST7이(가) 생성되었습니다.

-- 제약조건 확인(조회)
SELECT *
FROM VIEW_CONSTCHECK
WHERE TABLE_NAME = 'TBL_TEST7';
--==>> 조회 결과 없음

-- 제약조건 추가
ALTER TABLE TBL_TEST7
ADD (CONSTRAINT TEST7_COL1_PK PRIMARY KEY(COL1)
   , CONSTRAINT TEST7_COL2_UK UNIQUE(COL2));
--==>> Table TBL_TEST7이(가) 변경되었습니다.

-- 제약조건 확인(조회)
SELECT *
FROM VIEW_CONSTCHECK
WHERE TABLE_NAME = 'TBL_TEST7';
--==>>
/*
HR	TEST7_COL1_PK	TBL_TEST7	P	COL1		
HR	TEST7_COL2_UK	TBL_TEST7	U	COL2		
*/


--------------------------------------------------------------------------------------------------------------------------------

--■■■ CHECK(CK:C) ■■■--

-- 1. 컬럼에서 허용 가능한 데이터의 범위나 조건을 지정하기 위한 제약조건
--    컬럼에 입력되는 데이터를 검사하여 조건에 맞는 데이터만 입력될
--    수 있도록 처리하며, 수정되는 데이터 또한 검사하여 조건에 맞는
--    데이터로 수정되는 것만 허용하는 기능을 수행하게 된다.

-- 2. 형식 및 구조
--① 컬럼 레벨의 형식
-- 컬럼명 데이터타입 [CONSTRAINT CONSTRAINT명] CHECK (컬럼 조건)

--② 테이블 레벨의 형식
-- 컬럼명 데이터타입,
-- 컬럼명 데이터타입,
-- CONSTRIANT CONSTRAINT명 CHECK (컬럼 조건)

--※ NUMBER(38)     까지
--   CHAR(2000)     까지
--   VARCHAR2(4000) 까지
--   NCHAR(1000)    까지
--   NVARCHAR2(2000)까지


--○ CK 지정 실습(① 컬럼 레벨의 형식)
-- 테이블 생성
CREATE TABLE TBL_TEST8
( COL1  NUMBER(5)       PRIMARY KEY 
, COL2  VARCHAR2(30)
, COL3  NUMBER(3)       CHECK(COL3 BETWEEN 0 AND 100)       -- COL3에 대해서 0 부터 100 까지 제한하겠다는 의미
);
--==>> Table TBL_TEST8이(가) 생성되었습니다.

-- 데이터 입력
INSERT INTO TBL_TEST8(COL1, COL2, COL3) VALUES(1, '원영', 100);
INSERT INTO TBL_TEST8(COL1, COL2, COL3) VALUES(2, '선아', 101);   --> 에러 발생
INSERT INTO TBL_TEST8(COL1, COL2, COL3) VALUES(3, '나래', -1);    --> 에러 발생
INSERT INTO TBL_TEST8(COL1, COL2, COL3) VALUES(4, '주영', 80);

COMMIT;
--==>> 커밋 완료.

SELECT *
FROM TBL_TEST8;
--==>>
/*
1	원영	100
4	주영	 80
*/

--○ 제약조건 확인
SELECT *
FROM VIEW_CONSTCHECK
WHERE TABLE_NAME = 'TBL_TEST8';
--==>>
/*
HR	SYS_C007021	TBL_TEST8	C	COL3	COL3 BETWEEN 0 AND 100	
HR	SYS_C007022	TBL_TEST8	P	COL1		
*/


--○ CK 지정 실습(② 테이블 레벨의 형식)
-- 테이블 생성
CREATE TABLE TBL_TEST9
( COL1 NUMBER(5)
, COL2 VARCHAR(30)
, COL3 NUMBER(3)
, CONSTRAINT TEST9_COL1_PK PRIMARY KEY(COL1)
, CONSTRAINT TEST9_COL3_CK CHECK(COL3 BETWEEN 0 AND 100)
);

-- 데이터 입력
INSERT INTO TBL_TEST9(COL1, COL2, COL3) VALUES(1, '원영', 100);
INSERT INTO TBL_TEST9(COL1, COL2, COL3) VALUES(2, '선아', 101);   --> 에러 발생
INSERT INTO TBL_TEST9(COL1, COL2, COL3) VALUES(3, '나래', -1);    --> 에러 발생
INSERT INTO TBL_TEST9(COL1, COL2, COL3) VALUES(4, '주영', 80);

SELECT *
FROM TBL_TEST9;
--==>>
/*
4	주영	 80
1	원영	100
*/

--○ 제약조건 확인
SELECT *
FROM VIEW_CONSTCHECK
WHERE TABLE_NAME = 'TBL_TEST9';
--==>>
/*
HR	TEST9_COL3_CK	TBL_TEST9	C	COL3	COL3 BETWEEN 0 AND 100	
HR	TEST9_COL1_PK	TBL_TEST9	P	COL1		
*/


--○ CK 지정 실습(③ 테이블 생성 이후 제약조건 추가 → CK 제약조건 추가
CREATE TABLE TBL_TEST10
( COL1 NUMBER(5)
, COL2 VARCHAR2(30)
, COL3 NUMBER(3)
);
--==>> Table TBL_TEST10이(가) 생성되었습니다.

-- 제약조건 확인
SELECT *
FROM VIEW_CONSTCHECK
WHERE TABLE_NAME = 'TBL_TEST10';
--==>> 조회 결과 없음

-- 제약조건 추가
ALTER TABLE TBL_TEST10
ADD (CONSTRAINT TEST10_COL1_PK PRIMARY KEY(COL1)
   , CONSTRAINT TEST10_COL3_CK CHECK(COL3 BETWEEN 0 AND 100));
--==>> Table TBL_TEST10이(가) 변경되었습니다.

-- 제약조건 확인
SELECT *
FROM VIEW_CONSTCHECK
WHERE TABLE_NAME = 'TBL_TEST10';
--==>>
/*
HR	TEST10_COL1_PK	TBL_TEST10	P	COL1		
HR	TEST10_COL3_CK	TBL_TEST10	C	COL3	COL3 BETWEEN 0 AND 100	
*/


--○ 실습 문제
-- 다음과 같이 TBL_TESTMEMBER 테이블을 생성하여
-- SSN 컬럼(주민번호 컬럼)에서
-- 데이터 입력 시 성별이 유효한 데이터만 입력될 수 있도록
-- 체크 제약조건을 추가할 수 있도록 한다.
-- → 주민번호 특정 자리에 입력 가능한 데이터로 1, 2, 3, 4 를 적용
-- 또한, SID 컬럼에는 PRIMARY KEY 제약조건을 설정할 수 있도록 한다.

-- 테이블 생성
CREATE TABLE TBL_TESTMEMBER
( SID   NUMBER
, NAME  VARCHAR2(30)
, SSN   CHAR(14)              -- 입력 형태 → 'YYMMDD-NNNNNNN'
, TEL   VARCHAR2(40)
);
--==>> Table TBL_TESTMEMBER이(가) 생성되었습니다.

-- 제약조건 추가
ALTER TABLE TBL_TESTMEMBER
ADD (CONSTRAINT TESTMEMBER_SID_PK PRIMARY KEY(SID)
   , CONSTRAINT TESTMEMBER_SSN_CK CHECK(SUBSTR(SSN, 8, 1) BETWEEN 1 AND 4));
--==>> Table TBL_TESTMEMBER이(가) 변경되었습니다.

/*
ALTER TABLE TBL_TESTMEMBER
ADD (CONSTRAINT TESTMEMBER_SID_PK PRIMARY KEY(SID)
   , CONSTRAINT TESTMEMBER_SSN_CK CHECK(SUBSTR(SSN, 8, 1) IN ('1','2','3','4'));
*/

-- 제약조건 확인
SELECT *
FROM VIEW_CONSTCHECK
WHERE TABLE_NAME = 'TBL_TESTMEMBER';
--==>>
/*
HR	TEST10_SID_PK	TBL_TESTMEMBER	P	SID		
HR	TEST10_SSN_CK	TBL_TESTMEMBER	C	SSN	SUBSTR(SSN, 8, 1) BETWEEN 1 AND 4	
*/

-- 입력 테스트
INSERT INTO TBL_TESTMEMBER(SID, NAME, SSN, TEL)
VALUES(1, '윤희진', '961001-2068518', '01094159735');

INSERT INTO TBL_TESTMEMBER(SID, NAME, SSN, TEL)
VALUES(2, '김선아', '901212-2234567', '010-2222-222');

INSERT INTO TBL_TESTMEMBER(SID, NAME, SSN, TEL)
VALUES(3, '임나래', '901212-8234567', '010-8888-8888');    --> 에러 발생

INSERT INTO TBL_TESTMEMBER(SID, NAME, SSN, TEL)
VALUES(4, '나주영', '901212-0234567', '010-0000-0000');    --> 에러 발생

COMMIT;
--==>> 커밋 완료.

SELECT *
FROM TBL_TESTMEMBER;
--==>>
/*
1	윤희진	961001-2068518	01094159735
2	김선아	901212-2234567	010-2222-222
*/

--------------------------------------------------------------------------------------------------------------------------------


--■■■ FOREIGN KEY(FK:F:R) ■■■--

-- 1. 참조 키 또는 외래 키(FK)는
--    두 테이블의 데이터 간 연결을 설정하고
--    강제 적용시키는데 사용되는 열이다.
--    한 테이블의 기본 키 값이 있는 열을
--    다른 테이블에 추가하며 테이블 간 연결을 설정할 수 있다.
--    이 때, 두 번째 테이블에 추가되는 열이 외래 키가 된다.

-- 2. 부모 테이블(참조받는 컬럼이 포함된 테이블)이 먼저 생성된 후
--    자식 테이블(참조하는 컬럼이 포함된 테이블)이 생성되어야 한다.
--    이 때, 자식 테이블에 FOREIGN KEY 제약조건이 설정된다.

-- 3. 형식 및 구조
--① 컬럼 레벨의 형식
-- 컬러명 데이터타입 [CONSTRAINT CONSTRAINT명]
--                   REGERENCES 참조테이블명(참조컬럼명)
--                   [ON DELETE CASCADE | ON  DELETS SET NULL]

--② 테이블 레벨의 형식
-- 컬럼명 데이터타입,
-- 컬럼명 데이터타입,
-- CONSTRAINT CONSTRAINT명 FOREIGN KEY(컬럼명)
--            REFERENCE 참조테이블명(참조컬럼명)
--            [ON DELETE CASCADE | ON DELETE SET NULL]

--※ FOREIGN KEY 제약조건을 설정하는 실습을 진행하기 위해서는
--   독립적인 하나의 테이블을 생성하여 처리하는 것이 아니라
--   부모 테이블 생성 작업을 먼저 수행해야 한다.
--   그리고 이 때, 부모 테이블에는 반드시 PK 또는 UK 제약조건이
--   설정된 컬럼이 존재해야 한다.


-- 부모 테이블 생성
CREATE TABLE TBL_JOBS
( JIKWI_ID      NUMBER
, JIKWI_NAME    VARCHAR2(30)
, CONSTRAINT JOBS_ID_PK PRIMARY KEY(JIKWI_ID)
);
--==>> Table TBL_JOBS이(가) 생성되었습니다.

-- 부모 테이블에 데이터 입력
INSERT INTO TBL_JOBS(JIKWI_ID, JIKWI_NAME) VALUES(1, '사원');
INSERT INTO TBL_JOBS(JIKWI_ID, JIKWI_NAME) VALUES(2, '대리');
INSERT INTO TBL_JOBS(JIKWI_ID, JIKWI_NAME) VALUES(3, '과장');
INSERT INTO TBL_JOBS(JIKWI_ID, JIKWI_NAME) VALUES(4, '부장');
--==>> 1 행 이(가) 삽입되었습니다. * 4

SELECT *
FROM TBL_JOBS;
--==>>
/*
1	사원
2	대리
3	과장
4	부장
*/

COMMIT;
--==>> 커밋 완료.

--○ FK 지정 실습(① 컬럼 레벨의 형식)
CREATE TABLE TBL_EMP1
( SID       NUMBER          PRIMARY KEY
, NAME      VARCHAR2(30)
, JIKWI_ID  NUMBER          REFERENCES TBL_JOBS(JIKWI_ID)
);
--==>> Table TBL_EMP1이(가) 생성되었습니다.

-- 제약조건 확인
SELECT *
FROM VIEW_CONSTCHECK
WHERE TABLE_NAME = 'TBL_EMP1';
--==>>
/*
HR	SYS_C007034	TBL_EMP1	P	SID		
HR	SYS_C007035	TBL_EMP1	R	JIKWI_ID		NO ACTION
*/

-- 데이터 입력
INSERT INTO TBL_EMP1(SID, NAME, JIKWI_ID) VALUES(1, '조수연', 1);
INSERT INTO TBL_EMP1(SID, NAME, JIKWI_ID) VALUES(2, '곽한얼', 2);
INSERT INTO TBL_EMP1(SID, NAME, JIKWI_ID) VALUES(3, '이승희', 3);
INSERT INTO TBL_EMP1(SID, NAME, JIKWI_ID) VALUES(4, '최은상', 4);
INSERT INTO TBL_EMP1(SID, NAME, JIKWI_ID) VALUES(5, '권홍비', 5);      --> 에러 발생(부모테이블에 JIKWI_ID 컬럼에 5가 없기 때문)
INSERT INTO TBL_EMP1(SID, NAME, JIKWI_ID) VALUES(5, '권홍비', 1);
INSERT INTO TBL_EMP1(SID, NAME) VALUES(6, '윤희진');
INSERT INTO TBL_EMP1(SID, NAME, JIKWI_ID) VALUES(7, '이기승', NULL);

SELECT *
FROM TBL_EMP1;
--==>>
/*
1	조수연	1
2	곽한얼	2
3	이승희	3
4	최은상	4
5	권홍비	1
6	윤희진	
7	이기승	
*/

COMMIT;
--==>> 커밋 완료.


--○ FK 지정 실습(② 테이블 레벨의 형식)
CREATE TABLE TBL_EMP2
( SID       NUMBER
, NAME      VARCHAR(30)
, JIKWI_ID  NUMBER
, CONSTRAINT EMP2_SID_PK PRIMARY KEY(SID)
, CONSTRAINT EMP2_JIKWI_ID_FK FOREIGN KEY(JIKWI_ID)
                REFERENCES TBL_JOBS(JIKWI_ID)
);
--==>> Table TBL_EMP2이(가) 생성되었습니다.

-- 제약조건 확인
SELECT *
FROM VIEW_CONSTCHECK
WHERE TABLE_NAME = 'TBL_EMP2';
--==>>
/*
HR	EMP2_SID_PK	        TBL_EMP2	P	SID		
HR	EMP2_JIKWI_ID_FK	TBL_EMP2	R	JIKWI_ID		NO ACTION
*/

--○ FK 지정 실습(③ 테이블 생성 이후 제약조건 추가 →  FK 제약조건 추가)
-- 테이블 생성
CREATE TABLE TBL_EMP3
( SID       NUMBER
, NAME      VARCHAR2(30)
, JIKWI_ID  NUMBER
);
--==>> Table TBL_EMP3이(가) 생성되었습니다.

SELECT *
FROM VIEW_CONSTCHECK
WHERE TABLE_NAME = 'TBL_EMP3';
--==>> 조회 결과 없음

-- 제약조건 추가
ALTER TABLE TBL_EMP3
ADD (CONSTRAINT EMP3_SID_PK PRIMARY KEY(SID)
   , CONSTRAINT EMP3_JIKWI_FK FOREIGN KEY(JIKWI_ID)
                        REFERENCES TBL_JOBS(JIKWI_ID));
--==>> Table TBL_EMP3이(가) 변경되었습니다.

--제약조건 확인
SELECT *
FROM VIEW_CONSTCHECK
WHERE TABLE_NAME = 'TBL_EMP3';
--==>>
/*
HR	EMP3_SID_PK	    TBL_EMP3	P	SID		
HR	EMP3_JIKWI_FK	TBL_EMP3	R	JIKWI_ID		NO ACTION
*/

-- 4. FOREIGN KEY 생성 시 주의사항
--    참고하고자 하는 부모 테이블을 먼저 생성해야 한다.
--    참고하고자 하는 컬럼이 PRIMARY KEY 나 UNIQUE 제약조건이 있어야 한다.
--    테이블 사이에 PRIMARY KEY 와 FOREIGN KEY 가 정의되어 있으면
--    PRIMARY KEY 제약조건이 설정된 컬럼의 데이터 삭제 시
--    FOREIGN KEY 컬럼에 그 값이 입력되어 있는 경우 삭제되지 않는다.
--    (단, FK 설정 과정에서 『ON DELETE CASCADE』 나
--    『ON DELETE SET NULL』 옵션을 사용하여 설정한 경우에는
--    삭제가 가능하다.)
--    부모 테이블을 제거하기 위해서는 자식 테이블을 먼저 제거해야 한다.

-- 부모 테이블
SELECT *
FROM TBL_JOBS;
--==>>
/*
1	사원
2	대리
3	과장
4	부장
*/

-- 자식 테이블
SELECT *
FROM TBL_EMP1;
--==>>
/*
1	조수연	1
2	곽한얼	2
3	이승희	3
4	최은상	4
5	권홍비	1
6	윤희진	
7	이기승	
*/


-- 최은상 부장의 직위를 사원으로 변경
UPDATE TBL_EMP1
SET JIKWI_ID = 1
WHERE SID = 4;
--==>> 1 행 이(가) 업데이트되었습니다.

-- 확인
SELECT *
FROM TBL_EMP1;
--==>>
/*
1	조수연	1
2	곽한얼	2
3	이승희	3
4	최은상	1
5	권홍비	1
6	윤희진	
7	이기승	
*/

--○ 커밋
COMMIT;
--==>> 커밋 완료.

-- 부모테이블(TBL_JOBS)의 부장 데이터를 참조하고 있는
-- 자식테이블(TBL_EMP1)의 데이터가 존재하지 않는 상황.

-- 이와 같은 상황에서 부모테이블(TBL_JOBS)의
-- 부장 데이터 삭제
DELETE
FROM TBL_JOBS
WHERE JIKWI_ID = 4;
--==>> 1 행 이(가) 삭제되었습니다.

-- 확인
SELECT *
FROM TBL_JOBS;
--==>>
/*
1	사원
2	대리
3	과장
*/

--○ 커밋
COMMIT;
--==>> 커밋 완료.

-- 부모테이블(TBL_JOBS)의 사원 데이터를 참조하고 있는
-- 자식테이블(TBL_EMP1)의 데이터가 3건 존재하는 상황.

-- 이와 같은 상황에서 부모테이블(TBL_JOBS)의
-- 사원 데이터 삭제
DELETE
FROM TBL_JOBS
WHERE JIKWI_ID=1;
--==>> 에러 발생
/*
명령의 961 행에서 시작하는 중 오류 발생 -
DELETE
FROM TBL_JOBS
WHERE JIKWI_ID=1
오류 보고 -
ORA-02292: integrity constraint (HR.SYS_C007035) violated - child record found
*/


-- 부모 테이블(TBL_JOBS) 제거
DROP TABLE TBL_JOBS;
--==>> 에러 발생
/*
명령의 976 행에서 시작하는 중 오류 발생 -
DROP TABLE TBL_JOBS
오류 보고 -
ORA-02449: unique/primary keys in table referenced by foreign keys
02449. 00000 -  "unique/primary keys in table referenced by foreign keys"
*Cause:    An attempt was made to drop a table with unique or
           primary keys referenced by foreign keys in another table.
*Action:   Before performing the above operations the table, drop the
           foreign key constraints in other tables. You can see what
           constraints are referencing a table by issuing the following
           command:
           SELECT * FROM USER_CONSTRAINTS WHERE TABLE_NAME = "tabnam";
*/

--※ 부모 테이블의 데이터를 자유롭게 삭제하기 위해서는
--   『ON DELETE CASCADE』 옵션 지정이 필요하다.

--   TBL_EMP1 테이블(자식테이블)에서 FK 제약조건을 제거한 후
--   CASCADE 옵션을 포함하여 다시 FK 제약조건을 설정한다.

--○ 제약조건 확인
SELECT *
FROM VIEW_CONSTCHECK
WHERE TABLE_NAME = 'TBL_EMP1';
--==>>
/*
HR	SYS_C007034	TBL_EMP1	P	SID		
HR	SYS_C007035	TBL_EMP1	R	JIKWI_ID		NO ACTION
*/


--○ 제약조건 제거
ALTER TABLE TBL_EMP1
DROP CONSTRAINT SYS_C007035;
--==>> Table TBL_EMP1이(가) 변경되었습니다.


--○ 제약조건 제거 이후 다시 확인
SELECT *
FROM VIEW_CONSTCHECK
WHERE TABLE_NAME = 'TBL_EMP1';
--==>>
/*
HR	SYS_C007034	TBL_EMP1	P	SID		
*/


--○ 『ON DELETE CASCADE』 옵션이 포함된 내용으로 제약조건 재 지정
ALTER TABLE TBL_EMP1
ADD CONSTRAINT EMP1_JIKWIID_FK FOREIGN KEY(JIKWI_ID)
                    REFERENCES TBL_JOBS(JIKWI_ID)
                    ON DELETE CASCADE;
--==>> Table TBL_EMP1이(가) 변경되었습니다.


--○ 제약조건 재 지정 이후 다시 확인
SELECT *
FROM VIEW_CONSTCHECK
WHERE TABLE_NAME = 'TBL_EMP1';
--==>>
/*
HR	SYS_C007034	    TBL_EMP1	P	SID		
HR	EMP1_JIKWIID_FK	TBL_EMP1	R	JIKWI_ID		CASCADE
*/

--> CASCADE 옵션을 지정한 후에는
--  참조받고 있는 부모 테이블의 데이터를
--  언제든지 자유롭게 삭제하는 것이 가능하다.
--  단, 부모 테이블의 데이터가 삭제될 경우
--  이를 참조하는 자식 테이블의 데이터도 모두 함께 삭제된다.
--  CHECK!!!


-- 부모 테이블
SELECT *
FROM TBL_JOBS;
--==>>
/*
1	사원
2	대리
3	과장
*/

-- 자식 테이블
SELECT *
FROM TBL_EMP1;
--==>>
/*
1	조수연	1   ←
2	곽한얼	2
3	이승희	3
4	최은상	1   ←
5	권홍비	1   ←
6	윤희진	
7	이기승	
*/

--○ TBL_JOBS(부모테이블)의 사원 데이터 삭제
DELETE
FROM TBL_JOBS
WHERE JIKWI_ID=1;
--==>> 1 행 이(가) 삭제되었습니다.

-- 부모 테이블
SELECT *
FROM TBL_JOBS;
--==>>
/*
2	대리
3	과장
*/

-- 자식 테이블
SELECT *
FROM TBL_EMP1;
--==>>
/*
2	곽한얼	2
3	이승희	3
6	윤희진	
7	이기승	
*/


--------------------------------------------------------------------------------------------------------------------------------

--■■■ NOT NULL(NN:CK:C) ■■■--

-- 1. 테이블에서 지정한 컬럼의 데이터가 NULL 을 갖지 못하도록 하는 제약조건

-- 2. 형식 및 구조
-- ① 컬럼 레벨의 형식  (→ 더 많이 쓰임, 보통 테이블레벨의형식 권장)
-- 컬럼명 데이터타입 [COMSTRAINT CONSTRAINT명] NOT NULL  

-- ② 테이블 레벨의 형식
-- 컬럼명 데이터타입,
-- 컬럼명 데이터타입,
-- CONSTRAINT CONSTRAINT명 CHECK(컬럼명 IS NOT NULL)

-- 3. 기존에 생성되어 있는 테이블에 NOT NULL 제약조건을 추가할 경우
--    ADD 보다 MODIFY 절을 더 많이 사용한다.

--    ALTER TABLE 테이블명 
--    MODIFY 컬럼명 데이터타입 NOT NULL;

-- 4. 기존 테이블에 데이터가 이미 들어있지 않은 컬럼(→ NULL 인 상태)을
--    NOT NULL 제약조건을 갖게끔 수정하는 경우에는 에러 발생 한다.

--○ NOT NULL 지정 실습(① 컬럼 레벨의 형식)
-- 테이블 생성
CREATE TABLE TBL_TEST11
( COL1  NUMBER(5)       PRIMARY KEY
, COL2  VARCHAR(30)     NOT NULL
);
--==>> Table TBL_TEST11이(가) 생성되었습니다.

-- 데이터 입력
INSERT INTO TBL_TEST11(COL1, COL2) VALUES(1, 'TEST');
INSERT INTO TBL_TEST11(COL1, COL2) VALUES(2, 'ABCD');
INSERT INTO TBL_TEST11(COL1, COL2) VALUES(3, NULL);     --> 에러 발생
INSERT INTO TBL_TEST11(COL1) VALUES(4);                 --> 에러 발생

SELECT *
FROM TBL_TEST11;
--==>>
/*
1	TEST
2	ABCD
*/

COMMIT;
--==>> 커밋 완료.


-- 제약조건 확인
SELECT *
FROM VIEW_CONSTCHECK
WHERE TABLE_NAME = 'TBL_TEST11';
--==>>
/*
HR	SYS_C007041	TBL_TEST11	C	COL2	"COL2" IS NOT NULL	
HR	SYS_C007042	TBL_TEST11	P	COL1		
*/


--○ NOT NULL 지정 실습(② 테이블 레벨의 형식)
-- 테이블 생성
CREATE TABLE TBL_TEST12
( COL1  NUMBER(5)
, COL2 VARCHAR(30)
, CONSTRAINT TEST12_COL1_PK PRIMARY KEY(COL1)
, CONSTRAINT TEST12_CON2_NN CHECK(COL2 IS NOT NULL)
);
--==>> Table TBL_TEST12이(가) 생성되었습니다.

-- 제약조건 확인
SELECT *
FROM VIEW_CONSTCHECK
WHERE TABLE_NAME = 'TBL_TEST12';
--==>>
/*
HR	TEST12_CON2_NN	TBL_TEST12	C	COL2	COL2 IS NOT NULL	
HR	TEST12_COL1_PK	TBL_TEST12	P	COL1		
*/


--○ NOT NULL 지정 실습(③ 테이블 생성 이후 제약조건 추가 → NN 제약조건 추가)
CREATE TABLE TBL_TEST13
( COL1  NUMBER(5)
, COL2  VARCHAR(30)
);
--==>> Table TBL_TEST13이(가) 생성되었습니다.

-- 제약조건 확인
SELECT *
FROM VIEW_CONSTCHECK
WHERE TABLE_NAME = 'TBL_TEST13';
--==>> 조회 결과 없음

-- 제약조건 추가
ALTER TABLE TBL_TEST13
ADD (CONSTRAINT TEST13_COL1_PK PRIMARY KEY(COL1) 
   , CONSTRAINT TEST13_COL2_NN CHECK(COL2 IS NOT NULL));
--==>> Table TBL_TEST13이(가) 변경되었습니다.

-- 제약조건 확인
SELECT *
FROM VIEW_CONSTCHECK
WHERE TABLE_NAME = 'TBL_TEST13';
--==>>
/*
HR	TEST13_COL1_PK	TBL_TEST13	P	COL1		
HR	TEST13_COL2_NN	TBL_TEST13	C	COL2	COL2 IS NOT NULL	
*/


--※ NOT NULL 제약조건만 TBL_TEST13 테이블의 COL2 에 추가하는 경우
--   다음과 같은 방법도 가능하다.
ALTER TABLE TBL_TEST13
MODIFY COL2 NOT NULL;
--==>> Table TBL_TEST13이(가) 변경되었습니다.

-- 컬럼 레벨에서 NOT NULL 제약조건을 지정한 테이블
DESC TBL_TEST11;
/*
이름   널?       유형           
---- -------- ------------ 
COL1 NOT NULL NUMBER(5)    
COL2 NOT NULL VARCHAR2(30) 
*/
--> DESC 를 통해 COL2 컬럼이 NOT NULL 인 정보가 확인되는 상황

-- 테이블 레벨에서 NOT NULL 제약조건을 지정한 테이블
DESC TBL_TEST12;
--==>>
/*
이름   널?       유형           
---- -------- ------------ 
COL1 NOT NULL NUMBER(5)    
COL2          VARCHAR2(30)      (→ 표시가 없기 때문에 컬럼 레벨에서 제약조건 지정 권장)
*/
--> DESC 를 통해 COL2 컬럼이 NOT NULL 인 정보가 확인되지 않는 상황

-- 테이블 생성 이후 ADD 를 통해 NOT NULL 제약조건 추가하였으며
-- 또한, MODIFY 절을 통해 NOT NULL 제약조건을 다시 추가한 테이블
DESC TBL_TEST13;
--==>>
/*
이름   널?       유형           
---- -------- ------------ 
COL1 NOT NULL NUMBER(5)    
COL2 NOT NULL VARCHAR2(30) 
*/
--> DESC 를 통해 COL2 컬림이 NOT NULL 인 정보가 확인되는 상황


-- 제약조건 확인 전용 뷰(VIEW) 조회
SELECT *
FROM VIEW_CONSTCHECK
WHERE TABLE_NAME IN ('TBL_TEST11', 'TBL_TEST12', 'TBL_TEST13');
--==>>
/*
HR	SYS_C007041	    TBL_TEST11	C	COL2	"COL2" IS NOT NULL	
HR	SYS_C007042	    TBL_TEST11	P	COL1		
HR	TEST12_CON2_NN	TBL_TEST12	C	COL2	COL2 IS NOT NULL	
HR	TEST12_COL1_PK	TBL_TEST12	P	COL1		
HR	TEST13_COL1_PK	TBL_TEST13	P	COL1		
HR	TEST13_COL2_NN	TBL_TEST13	C	COL2	COL2 IS NOT NULL	
HR	SYS_C007047	    TBL_TEST13	C	COL2	"COL2" IS NOT NULL	
*/




=== 20190405_01_hr_팀별실습과제_3조.sql ===


--■■■ 팀별 실습 과제 ■■■--

-- HR 샘플 스키마 ERD 를 이용한 테이블 재구성!!

-- 팀별로 HR 스키마에 있는 기본 테이블(7개)
-- CONTRIES / DEPARTMENTS / EMPLOYEES / JOB_HISTORY / JOBS / LOCATIONS / REGIONS
-- 을 똑같이 새로 구성한다.

-- 단, 생성하는 테이블의 이름은 『테이블명+팀번호』
-- CONTRIES03 / DEPARTMENTS03 / EMPLOYEES03 / JOB_HISTORY03 / JOBS03 / LOCATIONS03 / REGIONS03
-- 과 같이 구성한다.

-- 1. 기존 테이블의 정보 수집
-- 2. 테이블 생성(컬럼 이름, 자료형, DEFAULT 표현식, NOT NULL 등...)
--    제약조건 설정(PK, UK, FK, CK, ... NN)
-- 3. 작성 후 데이터 입력
-- 4. 제출항목
--    20190405_01_hr_팀별실습과제_0조.sql
--    후기_0조.txt



/*
SELECT *
FROM VIEW_CONSTCHECK
WHERE TABLE_NAME IN ('COUNTRIES', 'DEPARTMENTS', 'EMPLOYEES', 'JOB_HISTORY', 'JOBS', 'LOCATIONS', 'REGIONS');

SELECT *
FROM TAB;

SELECT *
FROM USER_COL_COMMENTS
WHERE TABLE_NAME IN ('COUNTRIES', 'DEPARTMENTS', 'EMPLOYEES', 'JOB_HISTORY', 'JOBS', 'LOCATIONS', 'REGIONS');

SELECT *
FROM USER_SEQUENCES;
/*
SEQUENCE_NAME                   MIN_VALUE  MAX_VALUE INCREMENT_BY C O CACHE_SIZE LAST_NUMBER
------------------------------ ---------- ---------- ------------ - - ---------- -----------
DEPARTMENTS_SEQ                         1       9990           10 N N          0         280
EMPLOYEES_SEQ                           1 1.0000E+28            1 N N          0         207
LOCATIONS_SEQ                           1       9900          100 N N          0        3300
*/



--■ REGIONS03 테이블 생성
CREATE TABLE REGIONS03
( REGION_ID     NUMBER          CONSTRAINT REGION03_ID_NN NOT NULL
, REGION_NAME   VARCHAR2(25)
, CONSTRAINT REG03_ID_PK PRIMARY KEY(REGION_ID)
);
--==>> Table REGIONS03이(가) 생성되었습니다.

--○ REGIONS03 테이블에 데이터 입력
INSERT INTO REGIONS03(REGION_ID, REGION_NAME) VALUES
(1,'Europe');
INSERT INTO REGIONS03(REGION_ID, REGION_NAME) VALUES
(2, 'Americas');
INSERT INTO REGIONS03(REGION_ID, REGION_NAME) VALUES
(3, 'Asia');
INSERT INTO REGIONS03(REGION_ID, REGION_NAME) VALUES
(4, 'Middle East and Africa');
--==>> 1 행 이(가) 삽입되었습니다. * 4



--■ JOBS03 테이블 생성 
CREATE TABLE JOBS03
( JOB_ID        VARCHAR2(10)
, JOB_TITLE     VARCHAR2(35)   CONSTRAINT JOB03_TITLE_NN NOT NULL
, MIN_SALARY    NUMBER(6)
, MAX_SALARY    NUMBER(6)
, CONSTRAINT JOB03_ID_PK PRIMARY KEY(JOB_ID)
);
--==>> Table JOBS03이(가) 생성되었습니다.

--○ JOBS03 테이블에 데이터 입력
INSERT INTO JOBS03(JOB_ID,JOB_TITLE,MIN_SALARY,MAX_SALARY) VALUES('AD_PRES','President',20080,40000);
INSERT INTO JOBS03(JOB_ID,JOB_TITLE,MIN_SALARY,MAX_SALARY) VALUES('AD_VP','Administration Vice President',15000,30000);
INSERT INTO JOBS03(JOB_ID,JOB_TITLE,MIN_SALARY,MAX_SALARY) VALUES('AD_ASST','Administration Assistant',3000,6000);
INSERT INTO JOBS03(JOB_ID,JOB_TITLE,MIN_SALARY,MAX_SALARY) VALUES('FI_MGR','Finance Manager',8200,16000);
INSERT INTO JOBS03(JOB_ID,JOB_TITLE,MIN_SALARY,MAX_SALARY) VALUES('FI_ACCOUNT','Accountant',4200,9000);
INSERT INTO JOBS03(JOB_ID,JOB_TITLE,MIN_SALARY,MAX_SALARY) VALUES('AC_MGR','Accounting Manager',8200,16000);
INSERT INTO JOBS03(JOB_ID,JOB_TITLE,MIN_SALARY,MAX_SALARY) VALUES('AC_ACCOUNT','Public Accountant',4200,9000);
INSERT INTO JOBS03(JOB_ID,JOB_TITLE,MIN_SALARY,MAX_SALARY) VALUES('SA_MAN','Sales Manager',10000,20080);
INSERT INTO JOBS03(JOB_ID,JOB_TITLE,MIN_SALARY,MAX_SALARY) VALUES('SA_REP','Sales Representative',6000,12008);
INSERT INTO JOBS03(JOB_ID,JOB_TITLE,MIN_SALARY,MAX_SALARY) VALUES('PU_MAN','Purchasing Manager',8000,15000);
INSERT INTO JOBS03(JOB_ID,JOB_TITLE,MIN_SALARY,MAX_SALARY) VALUES('PU_CLERK','Purchasing Clerk',2500,5500);
INSERT INTO JOBS03(JOB_ID,JOB_TITLE,MIN_SALARY,MAX_SALARY) VALUES('ST_MAN','Stock Manager',5500,8500);
INSERT INTO JOBS03(JOB_ID,JOB_TITLE,MIN_SALARY,MAX_SALARY) VALUES('ST_CLERK','Stock Clerk',2008,5000);
INSERT INTO JOBS03(JOB_ID,JOB_TITLE,MIN_SALARY,MAX_SALARY) VALUES('SH_CLERK','Shipping Clerk',2500,5500);
INSERT INTO JOBS03(JOB_ID,JOB_TITLE,MIN_SALARY,MAX_SALARY) VALUES('IT_PROG','Programmer',4000,10000);
INSERT INTO JOBS03(JOB_ID,JOB_TITLE,MIN_SALARY,MAX_SALARY) VALUES('MK_MAN','Marketing Manager',9000,15000);
INSERT INTO JOBS03(JOB_ID,JOB_TITLE,MIN_SALARY,MAX_SALARY) VALUES('MK_REP','Marketing Representative',4000,9000);
INSERT INTO JOBS03(JOB_ID,JOB_TITLE,MIN_SALARY,MAX_SALARY) VALUES('HR_REP','Human Resources Representative',4000,9000);
INSERT INTO JOBS03(JOB_ID,JOB_TITLE,MIN_SALARY,MAX_SALARY) VALUES('PR_REP','Public Relations Representative',4500,10500);
--==>> 1 행 이(가) 삽입되었습니다. * 19



--■ COUNTRIES03 테이블 생성
CREATE TABLE COUNTRIES03
(   COUNTRY_ID      CHAR(2)      CONSTRAINT COUNTRY03_ID_NN  NOT NULL
,   COUNTRY_NAME    VARCHAR2(40)
,   REGION_ID       NUMBER
, CONSTRAINT COUNTRY03_C_ID_PK PRIMARY KEY(COUNTRY_ID)
, CONSTRAINT COUNTR03_REG_FK FOREIGN KEY(REGION_ID)
                            REFERENCES REGIONS03(REGION_ID)
);
--==>> Table COUNTRIES03이(가) 생성되었습니다.

--○ COUNTRIES03 테이블에 데이터 입력
INSERT INTO COUNTRIES03(COUNTRY_ID,COUNTRY_NAME,REGION_ID)
VALUES('AR','Argentina',2);
INSERT INTO COUNTRIES03(COUNTRY_ID,COUNTRY_NAME,REGION_ID)
VALUES('AU','Australia',3);
INSERT INTO COUNTRIES03(COUNTRY_ID,COUNTRY_NAME,REGION_ID)
VALUES('BE','Belgium',1);
INSERT INTO COUNTRIES03(COUNTRY_ID,COUNTRY_NAME,REGION_ID)
VALUES('BR','Brazil',2);
INSERT INTO COUNTRIES03(COUNTRY_ID,COUNTRY_NAME,REGION_ID)
VALUES('CA','Canada',2);
INSERT INTO COUNTRIES03(COUNTRY_ID,COUNTRY_NAME,REGION_ID)
VALUES('CH','Switzerland',1);
INSERT INTO COUNTRIES03(COUNTRY_ID,COUNTRY_NAME,REGION_ID)
VALUES('CN'	,'China',3);
INSERT INTO COUNTRIES03(COUNTRY_ID,COUNTRY_NAME,REGION_ID)
VALUES('DE','Germany',1);
INSERT INTO COUNTRIES03(COUNTRY_ID,COUNTRY_NAME,REGION_ID)
VALUES('DK','Denmark',1);
INSERT INTO COUNTRIES03(COUNTRY_ID,COUNTRY_NAME,REGION_ID)
VALUES('EG','Egypt',4);
INSERT INTO COUNTRIES03(COUNTRY_ID,COUNTRY_NAME,REGION_ID)
VALUES('FR','France',1);
INSERT INTO COUNTRIES03(COUNTRY_ID,COUNTRY_NAME,REGION_ID)
VALUES('IL','Israel',4);
INSERT INTO COUNTRIES03(COUNTRY_ID,COUNTRY_NAME,REGION_ID)
VALUES('IN','India',3);
INSERT INTO COUNTRIES03(COUNTRY_ID,COUNTRY_NAME,REGION_ID)
VALUES('IT','Italy',1);
INSERT INTO COUNTRIES03(COUNTRY_ID,COUNTRY_NAME,REGION_ID)
VALUES('JP','Japan',3);
INSERT INTO COUNTRIES03(COUNTRY_ID,COUNTRY_NAME,REGION_ID)
VALUES('KW','Kuwait',4);
INSERT INTO COUNTRIES03(COUNTRY_ID,COUNTRY_NAME,REGION_ID)
VALUES('ML','Malaysia',3);
INSERT INTO COUNTRIES03(COUNTRY_ID,COUNTRY_NAME,REGION_ID)
VALUES('MX','Mexico',2);
INSERT INTO COUNTRIES03(COUNTRY_ID,COUNTRY_NAME,REGION_ID)
VALUES('NG','Nigeria',4);
INSERT INTO COUNTRIES03(COUNTRY_ID,COUNTRY_NAME,REGION_ID)
VALUES('NL','Netherlands',1);
INSERT INTO COUNTRIES03(COUNTRY_ID,COUNTRY_NAME,REGION_ID)
VALUES('SG','Singapore',3);
INSERT INTO COUNTRIES03(COUNTRY_ID,COUNTRY_NAME,REGION_ID)
VALUES('UK','United Kingdom',1);
INSERT INTO COUNTRIES03(COUNTRY_ID,COUNTRY_NAME,REGION_ID)
VALUES('US','United States of America',2);
INSERT INTO COUNTRIES03(COUNTRY_ID,COUNTRY_NAME,REGION_ID)
VALUES('ZM','Zambia',4);
INSERT INTO COUNTRIES03(COUNTRY_ID,COUNTRY_NAME,REGION_ID)
VALUES('ZW','Zimbabwe',4);
--==>> 1 행 이(가) 삽입되었습니다. * 25



--■ LOCATIONS03 테이블 생성
CREATE TABLE LOCATIONS03
( LOCATION_ID       NUMBER(4)       
, STREET_ADDRESS    VARCHAR2(40)
, POSTAL_CODE       VARCHAR2(12)
, CITY              VARCHAR2(30)    CONSTRAINT LOC03_CITY_NN  NOT NULL    
, STATE_PROVIENCE   VARCHAR2(25)
, COUNTRY_ID        CHAR(2)
, CONSTRAINT LOC03_ID_PK PRIMARY KEY(LOCATION_ID)
, CONSTRAINT LOC03_C_ID_FK FOREIGN KEY(COUNTRY_ID)
                        REFERENCES COUNTRIES03(COUNTRY_ID)
);
--==>> Table LOCATIONS03이(가) 생성되었습니다.

--○ 시퀀스 생성
CREATE SEQUENCE LOCATIONS03_SEQ   
START WITH 1000                -- 시작값
INCREMENT BY 100             -- 증가값
MAXVALUE 9900               -- 최대값 제한 없음
NOCACHE;  
--==>> Sequence LOCATIONS03_SEQ이(가) 생성되었습니다.

--○ LOCATIONS03 테이블에 데이터 입력
INSERT INTO LOCATIONS03(LOCATION_ID, STREET_ADDRESS, POSTAL_CODE, CITY, STATE_PROVIENCE, COUNTRY_ID) VALUES
(LOCATIONS03_SEQ.NEXTVAL, '1297 Via Cola di Rie', '00989', 'Roma', NULL, 'IT');
INSERT INTO LOCATIONS03(LOCATION_ID, STREET_ADDRESS, POSTAL_CODE, CITY, STATE_PROVIENCE, COUNTRY_ID) VALUES
(LOCATIONS03_SEQ.NEXTVAL, '93091 Calle della Testa','10934','Venice',NULL,'IT');
INSERT INTO LOCATIONS03(LOCATION_ID, STREET_ADDRESS, POSTAL_CODE, CITY, STATE_PROVIENCE, COUNTRY_ID) VALUES
(LOCATIONS03_SEQ.NEXTVAL, '2017 Shinjuku-ku','1689','Tokyo','Tokyo Prefecture','JP');
INSERT INTO LOCATIONS03(LOCATION_ID, STREET_ADDRESS, POSTAL_CODE, CITY, STATE_PROVIENCE, COUNTRY_ID) VALUES
(LOCATIONS03_SEQ.NEXTVAL, '9450 Kamiya-cho','6823','Hiroshima',NULL,'JP');
INSERT INTO LOCATIONS03(LOCATION_ID, STREET_ADDRESS, POSTAL_CODE, CITY, STATE_PROVIENCE, COUNTRY_ID) VALUES
(LOCATIONS03_SEQ.NEXTVAL, '2014 Jabberwocky Rd','26192','Southlake','Texas','US');
INSERT INTO LOCATIONS03(LOCATION_ID, STREET_ADDRESS, POSTAL_CODE, CITY, STATE_PROVIENCE, COUNTRY_ID) VALUES
(LOCATIONS03_SEQ.NEXTVAL, '2011 Interiors Blvd','99236','South San Francisco','California','US');
INSERT INTO LOCATIONS03(LOCATION_ID, STREET_ADDRESS, POSTAL_CODE, CITY, STATE_PROVIENCE, COUNTRY_ID) VALUES
(LOCATIONS03_SEQ.NEXTVAL, '2007 Zagora St','50090','South Brunswick','New Jersey','US');
INSERT INTO LOCATIONS03(LOCATION_ID, STREET_ADDRESS, POSTAL_CODE, CITY, STATE_PROVIENCE, COUNTRY_ID) VALUES
(LOCATIONS03_SEQ.NEXTVAL, '2004 Charade Rd','98199','Seattle','Washington','US');
INSERT INTO LOCATIONS03(LOCATION_ID, STREET_ADDRESS, POSTAL_CODE, CITY, STATE_PROVIENCE, COUNTRY_ID) VALUES
(LOCATIONS03_SEQ.NEXTVAL, '147 Spadina Ave','M5V 2L7', 'Toronto','Ontario','CA');
INSERT INTO LOCATIONS03(LOCATION_ID, STREET_ADDRESS, POSTAL_CODE, CITY, STATE_PROVIENCE, COUNTRY_ID) VALUES
(LOCATIONS03_SEQ.NEXTVAL, '6092 Boxwood St','YSW 9T2','Whitehorse','Yukon','CA');
INSERT INTO LOCATIONS03(LOCATION_ID, STREET_ADDRESS, POSTAL_CODE, CITY, STATE_PROVIENCE, COUNTRY_ID) VALUES
(LOCATIONS03_SEQ.NEXTVAL, '40-5-12 Laogianggen','190518','Beijing',NULL,'CN');
INSERT INTO LOCATIONS03(LOCATION_ID, STREET_ADDRESS, POSTAL_CODE, CITY, STATE_PROVIENCE, COUNTRY_ID) VALUES
(LOCATIONS03_SEQ.NEXTVAL, '1298 Vileparle (E)', '490231','Bombay','Maharashtra','IN');
INSERT INTO LOCATIONS03(LOCATION_ID, STREET_ADDRESS, POSTAL_CODE, CITY, STATE_PROVIENCE, COUNTRY_ID) VALUES
(LOCATIONS03_SEQ.NEXTVAL, '12-98 Victoria Street','2901','Sydney','New South Wales','AU');
INSERT INTO LOCATIONS03(LOCATION_ID, STREET_ADDRESS, POSTAL_CODE, CITY, STATE_PROVIENCE, COUNTRY_ID) VALUES
(LOCATIONS03_SEQ.NEXTVAL, '198 Clementi North','540198','Singapore',NULL,'SG');
INSERT INTO LOCATIONS03(LOCATION_ID, STREET_ADDRESS, POSTAL_CODE, CITY, STATE_PROVIENCE, COUNTRY_ID) VALUES
(LOCATIONS03_SEQ.NEXTVAL, '8204 Arthur St',NULL,'London',NULL,'UK');
INSERT INTO LOCATIONS03(LOCATION_ID, STREET_ADDRESS, POSTAL_CODE, CITY, STATE_PROVIENCE, COUNTRY_ID) VALUES
(LOCATIONS03_SEQ.NEXTVAL, 'Magdalen Centre, The Oxford Science Park','OX9 9ZB','Oxford','Oxford','UK');
INSERT INTO LOCATIONS03(LOCATION_ID, STREET_ADDRESS, POSTAL_CODE, CITY, STATE_PROVIENCE, COUNTRY_ID) VALUES
(LOCATIONS03_SEQ.NEXTVAL, '9702 Chester Road','09629850293','Stretford','Manchester','UK');
INSERT INTO LOCATIONS03(LOCATION_ID, STREET_ADDRESS, POSTAL_CODE, CITY, STATE_PROVIENCE, COUNTRY_ID) VALUES
(LOCATIONS03_SEQ.NEXTVAL, 'Schwanthalerstr. 7031','80925','Munich','Bavaria','DE');
INSERT INTO LOCATIONS03(LOCATION_ID, STREET_ADDRESS, POSTAL_CODE, CITY, STATE_PROVIENCE, COUNTRY_ID) VALUES
(LOCATIONS03_SEQ.NEXTVAL, 'Rua Frei Caneca 1360', '01307-002','Sao paulo','Sao paulo','BR');
INSERT INTO LOCATIONS03(LOCATION_ID, STREET_ADDRESS, POSTAL_CODE, CITY, STATE_PROVIENCE, COUNTRY_ID) VALUES
(LOCATIONS03_SEQ.NEXTVAL, '20 Rue des Corps-Saints','1730','Geneva','Geneve','CH');
INSERT INTO LOCATIONS03(LOCATION_ID, STREET_ADDRESS, POSTAL_CODE, CITY, STATE_PROVIENCE, COUNTRY_ID) VALUES
(LOCATIONS03_SEQ.NEXTVAL, 'Murtenstrasse 921','3095','Bern','BE','CH');
INSERT INTO LOCATIONS03(LOCATION_ID, STREET_ADDRESS, POSTAL_CODE, CITY, STATE_PROVIENCE, COUNTRY_ID) VALUES
(LOCATIONS03_SEQ.NEXTVAL, 'Pieter Breughelstraat 837','3029SK','Utrecht','Utrecht','NL');
INSERT INTO LOCATIONS03(LOCATION_ID, STREET_ADDRESS, POSTAL_CODE, CITY, STATE_PROVIENCE, COUNTRY_ID) VALUES
(LOCATIONS03_SEQ.NEXTVAL, 'Mariano Escobedo 9991','11932','Mexico City','Distrito Federal','MX');
--==>> 1 행 이(가) 삽입되었습니다. * 23



--■ DEPARTMENTS03 테이블 생성
CREATE TABLE DEPARTMENTS03
(   DEPARTMENT_ID       NUMBER(4)      CONSTRAINT DEPT03_NAME_NN NOT NULL
,   DEPARTMENT_NAME     VARCHAR2(30)   
,   MANAGER_ID          NUMBER(6) 
,   LOCATION_ID         NUMBER(4)
, CONSTRAINT DEPT03_ID_PK PRIMARY KEY(DEPARTMENT_ID)
, CONSTRAINT DEPT03_LOC_FK FOREIGN KEY(LOCATION_ID)
                        REFERENCES LOCATIONS03(LOCATION_ID)
);
--==>> Table DEPARTMENTS03이(가) 생성되었습니다.

--○ 시퀀스 생성
CREATE SEQUENCE DEPARTMENTS03_SEQ   
START WITH 10                -- 시작값
INCREMENT BY 10             -- 증가값
MAXVALUE 9990               -- 최대값 제한 없음
NOCACHE;
--==>> Sequence DEPARTMENTS03_SEQ이(가) 생성되었습니다.

--○ DEPARTMENTS03 테이블에 데이터 입력
INSERT INTO DEPARTMENTS03(DEPARTMENT_ID,DEPARTMENT_NAME,MANAGER_ID,LOCATION_ID)
VALUES(DEPARTMENTS03_SEQ.NEXTVAL,'Administration',200,1700);
INSERT INTO DEPARTMENTS03(DEPARTMENT_ID,DEPARTMENT_NAME,MANAGER_ID,LOCATION_ID)
VALUES(DEPARTMENTS03_SEQ.NEXTVAL,'Marketing',201,1800);
INSERT INTO DEPARTMENTS03(DEPARTMENT_ID,DEPARTMENT_NAME,MANAGER_ID,LOCATION_ID)
VALUES(DEPARTMENTS03_SEQ.NEXTVAL,'Purchasing',114,1700);
INSERT INTO DEPARTMENTS03(DEPARTMENT_ID,DEPARTMENT_NAME,MANAGER_ID,LOCATION_ID)
VALUES(DEPARTMENTS03_SEQ.NEXTVAL,'Human Resources',203,2400);
INSERT INTO DEPARTMENTS03(DEPARTMENT_ID,DEPARTMENT_NAME,MANAGER_ID,LOCATION_ID)
VALUES(DEPARTMENTS03_SEQ.NEXTVAL,'Shipping',121,1500);
INSERT INTO DEPARTMENTS03(DEPARTMENT_ID,DEPARTMENT_NAME,MANAGER_ID,LOCATION_ID)
VALUES(DEPARTMENTS03_SEQ.NEXTVAL,'IT',103,1400);
INSERT INTO DEPARTMENTS03(DEPARTMENT_ID,DEPARTMENT_NAME,MANAGER_ID,LOCATION_ID)
VALUES(DEPARTMENTS03_SEQ.NEXTVAL,'Public Relations',204,2700);
INSERT INTO DEPARTMENTS03(DEPARTMENT_ID,DEPARTMENT_NAME,MANAGER_ID,LOCATION_ID)
VALUES(DEPARTMENTS03_SEQ.NEXTVAL,'Sales',145,2500);
INSERT INTO DEPARTMENTS03(DEPARTMENT_ID,DEPARTMENT_NAME,MANAGER_ID,LOCATION_ID)
VALUES(DEPARTMENTS03_SEQ.NEXTVAL,'Executive',100,1700);
INSERT INTO DEPARTMENTS03(DEPARTMENT_ID,DEPARTMENT_NAME,MANAGER_ID,LOCATION_ID)
VALUES(DEPARTMENTS03_SEQ.NEXTVAL,'Finance',108,1700);
INSERT INTO DEPARTMENTS03(DEPARTMENT_ID,DEPARTMENT_NAME,MANAGER_ID,LOCATION_ID)
VALUES(DEPARTMENTS03_SEQ.NEXTVAL,'Accounting',205,1700);
INSERT INTO DEPARTMENTS03(DEPARTMENT_ID,DEPARTMENT_NAME,MANAGER_ID,LOCATION_ID)
VALUES(DEPARTMENTS03_SEQ.NEXTVAL,'Treasury',NULL,1700);
INSERT INTO DEPARTMENTS03(DEPARTMENT_ID,DEPARTMENT_NAME,MANAGER_ID,LOCATION_ID)
VALUES(DEPARTMENTS03_SEQ.NEXTVAL,'Corporate Tax',NULL,1700);
INSERT INTO DEPARTMENTS03(DEPARTMENT_ID,DEPARTMENT_NAME,MANAGER_ID,LOCATION_ID)
VALUES(DEPARTMENTS03_SEQ.NEXTVAL,	'Control And Credit',NULL,	1700);
INSERT INTO DEPARTMENTS03(DEPARTMENT_ID,DEPARTMENT_NAME,MANAGER_ID,LOCATION_ID)
VALUES(DEPARTMENTS03_SEQ.NEXTVAL,'Shareholder Services',NULL,	1700);
INSERT INTO DEPARTMENTS03(DEPARTMENT_ID,DEPARTMENT_NAME,MANAGER_ID,LOCATION_ID)
VALUES(DEPARTMENTS03_SEQ.NEXTVAL,'Benefits',NULL,1700);
INSERT INTO DEPARTMENTS03(DEPARTMENT_ID,DEPARTMENT_NAME,MANAGER_ID,LOCATION_ID)
VALUES(DEPARTMENTS03_SEQ.NEXTVAL,'Manufacturing',NULL,1700);
INSERT INTO DEPARTMENTS03(DEPARTMENT_ID,DEPARTMENT_NAME,MANAGER_ID,LOCATION_ID)
VALUES(DEPARTMENTS03_SEQ.NEXTVAL,'Construction',NULL,1700);
INSERT INTO DEPARTMENTS03(DEPARTMENT_ID,DEPARTMENT_NAME,MANAGER_ID,LOCATION_ID)
VALUES(DEPARTMENTS03_SEQ.NEXTVAL,'Contracting',NULL,1700);
INSERT INTO DEPARTMENTS03(DEPARTMENT_ID,DEPARTMENT_NAME,MANAGER_ID,LOCATION_ID)
VALUES(DEPARTMENTS03_SEQ.NEXTVAL,'Operations',NULL,1700);
INSERT INTO DEPARTMENTS03(DEPARTMENT_ID,DEPARTMENT_NAME,MANAGER_ID,LOCATION_ID)
VALUES(DEPARTMENTS03_SEQ.NEXTVAL,'IT Support',NULL,1700);
INSERT INTO DEPARTMENTS03(DEPARTMENT_ID,DEPARTMENT_NAME,MANAGER_ID,LOCATION_ID)
VALUES(DEPARTMENTS03_SEQ.NEXTVAL,'NOC',NULL,1700);
INSERT INTO DEPARTMENTS03(DEPARTMENT_ID,DEPARTMENT_NAME,MANAGER_ID,LOCATION_ID)
VALUES(DEPARTMENTS03_SEQ.NEXTVAL,'IT Helpdesk',NULL,1700);
INSERT INTO DEPARTMENTS03(DEPARTMENT_ID,DEPARTMENT_NAME,MANAGER_ID,LOCATION_ID)
VALUES(DEPARTMENTS03_SEQ.NEXTVAL,'Government Sales',NULL,1700);
INSERT INTO DEPARTMENTS03(DEPARTMENT_ID,DEPARTMENT_NAME,MANAGER_ID,LOCATION_ID)
VALUES(DEPARTMENTS03_SEQ.NEXTVAL,'Retail Sales',NULL,1700);
INSERT INTO DEPARTMENTS03(DEPARTMENT_ID,DEPARTMENT_NAME,MANAGER_ID,LOCATION_ID)
VALUES(DEPARTMENTS03_SEQ.NEXTVAL,'Recruiting',NULL,1700);
INSERT INTO DEPARTMENTS03(DEPARTMENT_ID,DEPARTMENT_NAME,MANAGER_ID,LOCATION_ID)
VALUES(DEPARTMENTS03_SEQ.NEXTVAL,'Payroll',NULL,1700);
--==>> 1 행 이(가) 삽입되었습니다. * 27



--■ EMPLOYEE03 테이블 생성
CREATE TABLE EMPLOYEES03
( EMPLOYEE_ID       NUMBER(6)       
, FIRST_NAME        VARCHAR2(20)
, LAST_NAME         VARCHAR2(25)    CONSTRAINT EMP03_LAST_NAME_NN NOT NULL
, EMAIL             VARCHAR2(25)    CONSTRAINT EMP03_EMAIL_NN NOT NULL
, PHONE_NUMBER      VARCHAR2(20)
, HIRE_DATE         DATE            CONSTRAINT EMP03_HIRE_DATE_NN NOT NULL
, JOB_ID            VARCHAR2(10)    CONSTRAINT EMP03_JOB_NN NOT NULL
, SALARY            NUMBER(8, 2)    CONSTRAINT EMP03_SALARY_MIN CHECK(SALARY>0) 
, COMMISSION_PCT    NUMBER(2,2)
, MANAGER_ID        NUMBER(6)
, DEPARTMENT_ID     NUMBER(4)
, CONSTRAINT EMP03_EMP_ID_PK PRIMARY KEY(EMPLOYEE_ID)
, CONSTRAINT EMP03_DEPT_FK FOREIGN KEY(DEPARTMENT_ID)
                    REFERENCES DEPARTMENTS03(DEPARTMENT_ID)
, CONSTRAINT EMP03_JOB_FK FOREIGN KEY(JOB_ID)
                    REFERENCES JOBS03(JOB_ID)
, CONSTRAINT EMP03_EMAIL_UK UNIQUE(EMAIL)
);
--==>> Table EMPLOYEES03이(가) 생성되었습니다.

--○ 시퀀스 생성
CREATE SEQUENCE EMPLOYEES03_SEQ   
START WITH 100                -- 시작값
INCREMENT BY 1             -- 증가값
NOMAXVALUE               -- 최대값 제한 없음
NOCACHE;
--==>> Sequence EMPLOYEES03_SEQ이(가) 생성되었습니다.

--○ EMPLOYEE03 테이블에 데이터 입력
INSERT INTO EMPLOYEES03(EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
VALUES(EMPLOYEES03_SEQ.NEXTVAL, 'Steven', 'King', 'SKING', '515.123.4567', TO_DATE('2003-06-17 00:00:00', 'YYYY-MM-DD HH24:MI:SS'), 'AD_PRES', 24000, NULL, NULL, 90);
INSERT INTO EMPLOYEES03(EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
VALUES(EMPLOYEES03_SEQ.NEXTVAL, 'Neena', 'Kochhar', 'NKOCHHAR', '515.123.4568', TO_DATE('2005-09-21 00:00:00', 'YYYY-MM-DD HH24:MI:SS'), 'AD_VP', 17000, NULL, 100, 90);
INSERT INTO EMPLOYEES03(EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
VALUES(EMPLOYEES03_SEQ.NEXTVAL, 'Lex', 'De Haan', 'LDEHAAN', '515.123.4569', TO_DATE('2001-01-13 00:00:00', 'YYYY-MM-DD HH24:MI:SS'), 'AD_VP', 17000, NULL, 100, 90);
INSERT INTO EMPLOYEES03(EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
VALUES(EMPLOYEES03_SEQ.NEXTVAL, 'Alexander', 'Hunold', 'AHUNOLD', '590.423.4567', TO_DATE('2006-01-03 00:00:00', 'YYYY-MM-DD HH24:MI:SS'), 'IT_PROG', 9000, NULL, 102, 60);
INSERT INTO EMPLOYEES03(EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
VALUES(EMPLOYEES03_SEQ.NEXTVAL, 'Bruce', 'Ernst', 'BERNST', '590.423.4568', TO_DATE('2007-05-21 00:00:00', 'YYYY-MM-DD HH24:MI:SS'), 'IT_PROG', 6000, NULL, 103, 60);
INSERT INTO EMPLOYEES03(EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
VALUES(EMPLOYEES03_SEQ.NEXTVAL, 'David', 'Austin', 'DAUSTIN', '590.423.4569', TO_DATE('2005-06-25 00:00:00', 'YYYY-MM-DD HH24:MI:SS'), 'IT_PROG', 4800, NULL, 103, 60);
INSERT INTO EMPLOYEES03(EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
VALUES(EMPLOYEES03_SEQ.NEXTVAL, 'Valli', 'Pataballa', 'VPATABAL', '590.423.4560', TO_DATE('2006-02-05 00:00:00', 'YYYY-MM-DD HH24:MI:SS'), 'IT_PROG', 4800, NULL, 103, 60);
INSERT INTO EMPLOYEES03(EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
VALUES(EMPLOYEES03_SEQ.NEXTVAL, 'Diana', 'Lorentz', 'DLORENTZ', '590.423.5567', TO_DATE('2007-02-07 00:00:00', 'YYYY-MM-DD HH24:MI:SS'), 'IT_PROG', 4200, NULL, 103, 60);
INSERT INTO EMPLOYEES03(EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
VALUES(EMPLOYEES03_SEQ.NEXTVAL, 'Nancy', 'Greenberg', 'NGREENBE', '515.124.4569', TO_DATE('2002-08-17 00:00:00', 'YYYY-MM-DD HH24:MI:SS'), 'FI_MGR', 12008, NULL, 101, 100);
INSERT INTO EMPLOYEES03(EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
VALUES(EMPLOYEES03_SEQ.NEXTVAL,'Daniel','Faviet','DFAVIET','515.124.4169',TO_DATE('2002-08-16 00:00:00', 'YYYY-MM-DD HH24:MI:SS'),'FI_ACCOUNT',9000,NULL,108,100);
INSERT INTO EMPLOYEES03(EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
VALUES(EMPLOYEES03_SEQ.NEXTVAL,'John','Chen','JCHEN','515.124.4269',TO_DATE('2005-09-28', 'YYYY-MM-DD HH24:MI:SS'),'FI_ACCOUNT',8200,NULL,108,100);

INSERT INTO EMPLOYEES03(EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
VALUES(EMPLOYEES03_SEQ.NEXTVAL,'Ismael','Sciarra','ISCIARRA','515.124.4369',TO_DATE('2005-09-30 00:00:00', 'YYYY-MM-DD HH24:MI:SS'),'FI_ACCOUNT',7700,NULL,108,100);
INSERT INTO EMPLOYEES03(EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
VALUES(EMPLOYEES03_SEQ.NEXTVAL,'Jose Manuel','Urman','JMURMAN','515.124.4469',TO_DATE('2006-03-07 00:00:00', 'YYYY-MM-DD HH24:MI:SS'),'FI_ACCOUNT',7800,NULL,108,100);
INSERT INTO EMPLOYEES03(EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
VALUES(EMPLOYEES03_SEQ.NEXTVAL,'Luis','Popp','LPOPP','515.124.4567',TO_DATE('2007-12-07 00:00:00', 'YYYY-MM-DD HH24:MI:SS'),'FI_ACCOUNT',6900,NULL,108,100);
INSERT INTO EMPLOYEES03(EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
VALUES(EMPLOYEES03_SEQ.NEXTVAL,'Den','Raphaely','DRAPHEAL','515.127.4561',TO_DATE('2002-12-07 00:00:00', 'YYYY-MM-DD HH24:MI:SS'),'PU_MAN',11000,NULL,100,30);
INSERT INTO EMPLOYEES03(EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
VALUES(EMPLOYEES03_SEQ.NEXTVAL,'Alexander','Khoo','AKHOO','515.127.4562',TO_DATE('2003-05-18 00:00:00', 'YYYY-MM-DD HH24:MI:SS'),'PU_CLERK',3100,NULL,114,30);
INSERT INTO EMPLOYEES03(EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
VALUES(EMPLOYEES03_SEQ.NEXTVAL,'Shelli','Baida','SBAIDA','515.127.4563',TO_DATE('2005-12-24 00:00:00', 'YYYY-MM-DD HH24:MI:SS'),'PU_CLERK',2900,NULL,114,30);
INSERT INTO EMPLOYEES03(EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
VALUES(EMPLOYEES03_SEQ.NEXTVAL,'Sigal','Tobias','STOBIAS','515.127.4564',TO_DATE('2005-07-24 00:00:00', 'YYYY-MM-DD HH24:MI:SS'),'PU_CLERK',2800,NULL,114,30);
INSERT INTO EMPLOYEES03(EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
VALUES(EMPLOYEES03_SEQ.NEXTVAL,'Guy','Himuro','GHIMURO','515.127.4565',TO_DATE('2006-11-15 00:00:00', 'YYYY-MM-DD HH24:MI:SS'),'PU_CLERK',2600,NULL,114,30);
INSERT INTO EMPLOYEES03(EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
VALUES(EMPLOYEES03_SEQ.NEXTVAL,'Karen','Colmenares','KCOLMENA','515.127.4566',TO_DATE('2007-08-10 00:00:00', 'YYYY-MM-DD HH24:MI:SS'),'PU_CLERK',2500,NULL,114,30);
INSERT INTO EMPLOYEES03(EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
VALUES(EMPLOYEES03_SEQ.NEXTVAL,'Matthew','Weiss','MWEISS','650.123.1234',TO_DATE('2004-07-18 00:00:00', 'YYYY-MM-DD HH24:MI:SS'),'ST_MAN',8000,NULL,100,50);

INSERT INTO EMPLOYEES03(EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
VALUES(EMPLOYEES03_SEQ.NEXTVAL,'Adam','Fripp','AFRIPP','650.123.2234',TO_DATE('2005-04-10 00:00:00', 'YYYY-MM-DD HH24:MI:SS'),'ST_MAN',8200,NULL,100,50);
INSERT INTO EMPLOYEES03(EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
VALUES(EMPLOYEES03_SEQ.NEXTVAL,'Payam','Kaufling','PKAUFLIN','650.123.3234',TO_DATE('2003-05-01 00:00:00', 'YYYY-MM-DD HH24:MI:SS'),'ST_MAN',7900,NULL,100,50);
INSERT INTO EMPLOYEES03(EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
VALUES(EMPLOYEES03_SEQ.NEXTVAL,'Shanta','Vollman','SVOLLMAN','650.123.4234',TO_DATE('2005-10-10 00:00:00', 'YYYY-MM-DD HH24:MI:SS'),'ST_MAN',6500,NULL,100,50);
INSERT INTO EMPLOYEES03(EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
VALUES(EMPLOYEES03_SEQ.NEXTVAL,'Kevin','Mourgos','KMOURGOS','650.123.5234',TO_DATE('2007-11-16 00:00:00', 'YYYY-MM-DD HH24:MI:SS'),'ST_MAN',5800,NULL,100,50);
INSERT INTO EMPLOYEES03(EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
VALUES(EMPLOYEES03_SEQ.NEXTVAL,'Julia','Nayer','JNAYER','650.124.1214',TO_DATE('2005-07-16 00:00:00', 'YYYY-MM-DD HH24:MI:SS'),'ST_CLERK',3200,NULL,120,50);
INSERT INTO EMPLOYEES03(EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
VALUES(EMPLOYEES03_SEQ.NEXTVAL,'Irene','Mikkilineni','IMIKKILI','650.124.1224',TO_DATE('2006-09-28 00:00:00', 'YYYY-MM-DD HH24:MI:SS'),'ST_CLERK',2700,NULL,120,50);
INSERT INTO EMPLOYEES03(EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
VALUES(EMPLOYEES03_SEQ.NEXTVAL,'James','Landry','JLANDRY','650.124.1334',TO_DATE('2007-01-14 00:00:00', 'YYYY-MM-DD HH24:MI:SS'),'ST_CLERK',2400,NULL,120,50);
INSERT INTO EMPLOYEES03(EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
VALUES(EMPLOYEES03_SEQ.NEXTVAL,'Steven','Markle','SMARKLE','650.124.1434',TO_DATE('2008-03-08 00:00:00', 'YYYY-MM-DD HH24:MI:SS'),'ST_CLERK',2200,NULL,120,50);
INSERT INTO EMPLOYEES03(EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
VALUES(EMPLOYEES03_SEQ.NEXTVAL,'Laura','Bissot','LBISSOT','650.124.5234',TO_DATE('2005-08-20 00:00:00', 'YYYY-MM-DD HH24:MI:SS'),'ST_CLERK',3300,NULL,121,50);
INSERT INTO EMPLOYEES03(EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
VALUES(EMPLOYEES03_SEQ.NEXTVAL,'Mozhe','Atkinson','MATKINSO','650.124.6234',TO_DATE('2005-10-30 00:00:00', 'YYYY-MM-DD HH24:MI:SS'),'ST_CLERK',2800,NULL,121,50);

INSERT INTO EMPLOYEES03 VALUES(EMPLOYEES03_SEQ.NEXTVAL,'James','Marlow','JAMRLOW','650.124.7234',TO_DATE('2005-02-16 00:00:00', 'YYYY-MM-DD HH24:MI:SS') ,'ST_CLERK',2500,NULL,121,50);
INSERT INTO EMPLOYEES03 VALUES(EMPLOYEES03_SEQ.NEXTVAL,'TJ','Olson','TJOLSON','650.124.8234',TO_DATE('2007-04-10 00:00:00', 'YYYY-MM-DD HH24:MI:SS'),'ST_CLERK',2100,NULL,121,50);
INSERT INTO EMPLOYEES03 VALUES(EMPLOYEES03_SEQ.NEXTVAL,'Jason','Mallin','JMALLIN','650.127.1934',TO_DATE('2004-06-14 00:00:00','YYYY-MM-DD HH24:MI:SS'),'ST_CLERK',3300,NULL,122,50);
INSERT INTO EMPLOYEES03 VALUES(EMPLOYEES03_SEQ.NEXTVAL,'Michael','Rogers','MROGERS','650.127.1834',TO_DATE('2006-08-26 00:00:00','YYYY-MM-DD HH24:MI:SS'),'ST_CLERK',2900,NULL,122,50);

INSERT INTO EMPLOYEES03 VALUES(EMPLOYEES03_SEQ.NEXTVAL,'Ki','Gee','KGEE','650.127.1734',TO_DATE('2007-12-12 00:00:00','YYYY-MM-DD HH24:MI:SS'),'ST_CLERK',2400, NULL,122,50);
INSERT INTO EMPLOYEES03 VALUES(EMPLOYEES03_SEQ.NEXTVAL,'Hazel','Philtanker','HPHILTAN','650.127.1634',TO_DATE('2008-02-06 00:00:00','YYYY-MM-DD HH24:MI:SS'),'ST_CLERK',2200,NULL,122,50);
INSERT INTO EMPLOYEES03 VALUES(EMPLOYEES03_SEQ.NEXTVAL,'Renske','Ladwig','RLADWIG','650.121.1234',TO_DATE('2003-07-14 00:00:00','YYYY-MM-DD HH24:MI:SS'),'ST_CLERK',3600,NULL,123,50);
INSERT INTO EMPLOYEES03 VALUES(EMPLOYEES03_SEQ.NEXTVAL,'Stephen','Stiles','SSTILES','650.121.2034',TO_DATE('2005-10-26 00:00:00','YYYY-MM-DD HH24:MI:SS'),'ST_CLERK',3200,NULL,123,50);
INSERT INTO EMPLOYEES03 VALUES(EMPLOYEES03_SEQ.NEXTVAL,'John','Seo','JSEO','650.121.2019',TO_DATE('2006-02-12 00:00:00','YYYY-MM-DD HH24:MI:SS'),'ST_CLERK',2700,NULL,123,50);

INSERT INTO EMPLOYEES03 VALUES(EMPLOYEES03_SEQ.NEXTVAL,'Joshua','Patel','JPATEL','650.121.1834',TO_DATE('2006-04-06 00:00:00','YYYY-MM-DD HH24:MI:SS'),'ST_CLERK',2500,NULL,123,50);
INSERT INTO EMPLOYEES03 VALUES(EMPLOYEES03_SEQ.NEXTVAL,'Trenna','Rajs','TRAJS','650.121.8009',TO_DATE('2003-10-17 00:00:00','YYYY-MM-DD HH24:MI:SS'),'ST_CLERK',3500,NULL,124,50);
INSERT INTO EMPLOYEES03 VALUES(EMPLOYEES03_SEQ.NEXTVAL,'Curtis','Davies','CDAVIES','650.121.2994',TO_DATE('2005-01-29 00:00:00','YYYY-MM-DD HH24:MI:SS'),'ST_CLERK',3100,NULL,124,50);
INSERT INTO EMPLOYEES03 VALUES(EMPLOYEES03_SEQ.NEXTVAL,'Randall','Matos','RMATOS','650.121.2874',TO_DATE('2006-03-15 00:00:00','YYYY-MM-DD HH24:MI:SS'),'ST_CLERK',2600,NULL,124,50);
INSERT INTO EMPLOYEES03 VALUES(EMPLOYEES03_SEQ.NEXTVAL,'Peter','Vargas','PVARGAS','650.121.2004',TO_DATE('2006-07-09 00:00:00','YYYY-MM-DD HH24:MI:SS'),'ST_CLERK',2500,NULL,124,50);

INSERT INTO EMPLOYEES03 VALUES(EMPLOYEES03_SEQ.NEXTVAL,'John','Russell','JRUSSEL','011.44.1344.429268',TO_DATE('2004-10-01 00:00:00','YYYY-MM-DD HH24:MI:SS'),'SA_MAN',14000,0.4,100,80);
INSERT INTO EMPLOYEES03 VALUES(EMPLOYEES03_SEQ.NEXTVAL,'Karen','Partners','KPARTNER','011.44.1344.467268',TO_DATE('2005-01-05 00:00:00','YYYY-MM-DD HH24:MI:SS'),'SA_MAN',13500,0.3,100,80);
INSERT INTO EMPLOYEES03 VALUES(EMPLOYEES03_SEQ.NEXTVAL,'Alberto','Errazuriz','AERRAZUR','011.44.1344.429278',TO_DATE('2005-03-10 00:00:00','YYYY-MM-DD HH24:MI:SS'),'SA_MAN',12000,0.3,100,80);
INSERT INTO EMPLOYEES03 VALUES(EMPLOYEES03_SEQ.NEXTVAL,'Gerald','Cambrault','GCAMBRAU','011.44.1344.619268',TO_DATE('2007-10-15 00:00:00','YYYY-MM-DD HH24:MI:SS'),'SA_MAN',11000,0.3,100,80);
INSERT INTO EMPLOYEES03 VALUES(EMPLOYEES03_SEQ.NEXTVAL,'Eleni','Zlotkey','EZLOTKEY','011.44.1344.429018',TO_DATE('2008-01-29 00:00:00','YYYY-MM-DD HH24:MI:SS'),'SA_MAN',10500,0.2,100,80);

INSERT INTO EMPLOYEES03 VALUES(EMPLOYEES03_SEQ.NEXTVAL,'Peter','Tucker','PTUCKER','011.44.1344.129268',TO_DATE('2005-01-30 00:00:00','YYYY-MM-DD HH24:MI:SS'),'SA_REP',10000,0.3,145,80);
INSERT INTO EMPLOYEES03 VALUES(EMPLOYEES03_SEQ.NEXTVAL,'David','Bernstein','DBERNSTE','011.44.1344.345268',TO_DATE('2005-03-24 00:00:00','YYYY-MM-DD HH24:MI:SS'),'SA_REP',9500,0.25,145,80);
INSERT INTO EMPLOYEES03 VALUES(EMPLOYEES03_SEQ.NEXTVAL,'Peter','Hall','PHALL','011.44.1344.478968',TO_DATE('2005-08-20 00:00:00','YYYY-MM-DD HH24:MI:SS'),'SA_REP',9000,0.25,145,80);
INSERT INTO EMPLOYEES03 VALUES(EMPLOYEES03_SEQ.NEXTVAL,'Christopher','Olsen','COLSEN','011.44.1344.498718',TO_DATE('2006-03-30 00:00:00','YYYY-MM-DD HH24:MI:SS'),'SA_REP',8000,0.2,145,80);
INSERT INTO EMPLOYEES03 VALUES(EMPLOYEES03_SEQ.NEXTVAL,'Nanette','Cambrault','NCAMBRAU','011.44.1344.987668',TO_DATE('2006-12-09 00:00:00','YYYY-MM-DD HH24:MI:SS'),'SA_REP',7500,0.2,145,80);

INSERT INTO EMPLOYEES03 VALUES(EMPLOYEES03_SEQ.NEXTVAL,'Oliver','Tuvault','OTUVAULT','011.44.1344.486508',TO_DATE('2007-11-23 00:00:00','YYYY-MM-DD HH24:MI:SS'),'SA_REP',7000,0.15,145,80);
INSERT INTO EMPLOYEES03 VALUES(EMPLOYEES03_SEQ.NEXTVAL,'Janette','King','JKING','011.44.1345.429268',TO_DATE('2004-01-30 00:00:00','YYYY-MM-DD HH24:MI:SS'),'SA_REP',10000,0.35,146,80);
INSERT INTO EMPLOYEES03 VALUES(EMPLOYEES03_SEQ.NEXTVAL,'Patrick','Sully','PSULLY','011.44.1345.929268',TO_DATE('2004-03-04 00:00:00','YYYY-MM-DD HH24:MI:SS'),'SA_REP',9500,0.35,146,80);
INSERT INTO EMPLOYEES03 VALUES(EMPLOYEES03_SEQ.NEXTVAL,'Allan','McEwen','AMCEWEN','011.44.1345.829268',TO_DATE('2004-08-01 00:00:00','YYYY-MM-DD HH24:MI:SS'),'SA_REP',9000,0.35,146,80);
INSERT INTO EMPLOYEES03 VALUES(EMPLOYEES03_SEQ.NEXTVAL,'Lindsey','Smith','LSMITH','011.44.1345.729268',TO_DATE('2005-03-10 00:00:00','YYYY-MM-DD HH24:MI:SS'),'SA_REP',8000,0.3,146,80);

INSERT INTO EMPLOYEES03 VALUES(EMPLOYEES03_SEQ.NEXTVAL,'Louise','Doran','LDORAN','011.44.1345.629268',TO_DATE('2005-12-15 00:00:00','YYYY-MM-DD HH24:MI:SS'),'SA_REP',7500,0.3,146,80);
INSERT INTO EMPLOYEES03 VALUES(EMPLOYEES03_SEQ.NEXTVAL,'Sarath','Sewall','SSEWALL','011.44.1345.529268',TO_DATE('2006-11-03 00:00:00','YYYY-MM-DD HH24:MI:SS'),'SA_REP',7000,0.25,146,80);
INSERT INTO EMPLOYEES03 VALUES(EMPLOYEES03_SEQ.NEXTVAL,'Clara','Vishney','CVISHNEY','011.44.1346.129268',TO_DATE('2005-11-11 00:00:00','YYYY-MM-DD HH24:MI:SS'),'SA_REP',10500,0.25,147,80);
INSERT INTO EMPLOYEES03 VALUES(EMPLOYEES03_SEQ.NEXTVAL,'Danielle','Greene','DGREENE','011.44.1346.229268',TO_DATE('2007-03-19 00:00:00','YYYY-MM-DD HH24:MI:SS'),'SA_REP',9500,0.15,147,80);
INSERT INTO EMPLOYEES03 VALUES(EMPLOYEES03_SEQ.NEXTVAL,'Mattea','Marvins','MMARVINS','011.44.1346.329268',TO_DATE('2008-01-24 00:00:00','YYYY-MM-DD HH24:MI:SS'),'SA_REP',7200,0.1,147,80);

INSERT INTO EMPLOYEES03 VALUES(EMPLOYEES03_SEQ.NEXTVAL,'David','Lee','DLEE','011.44.1346.529268',TO_DATE('2008-02-23 00:00:00','YYYY-MM-DD HH24:MI:SS'),'SA_REP',6800,0.1,147,80);
INSERT INTO EMPLOYEES03 VALUES(EMPLOYEES03_SEQ.NEXTVAL,'Sundar','Ande','SANDE','011.44.1346.629268',TO_DATE('2008-03-24 00:00:00','YYYY-MM-DD HH24:MI:SS'),'SA_REP',6400,0.1,147,80);
INSERT INTO EMPLOYEES03 VALUES(EMPLOYEES03_SEQ.NEXTVAL,'Amit','Banda','ABANDA','011.44.1346.729268',TO_DATE('2008-04-21 00:00:00','YYYY-MM-DD HH24:MI:SS'),'SA_REP',6200,0.1,147,80);
INSERT INTO EMPLOYEES03 VALUES(EMPLOYEES03_SEQ.NEXTVAL,'Lisa','Ozer','LOZER','011.44.1343.929268',TO_DATE('2005-03-11 00:00:00','YYYY-MM-DD HH24:MI:SS'),'SA_REP',11500,0.25,148,80);
INSERT INTO EMPLOYEES03 VALUES(EMPLOYEES03_SEQ.NEXTVAL,'Harrison','Bloom','HBLOOM','011.44.1343.829268',TO_DATE('2006-03-23 00:00:00','YYYY-MM-DD HH24:MI:SS'),'SA_REP',10000,0.2,148,80);


INSERT INTO EMPLOYEES03(EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
VALUES(EMPLOYEES03_SEQ.NEXTVAL, 'Tayler', 'Fox', 'TFOX', '011.44.1343.729268', TO_DATE('2006-01-24 00:00:00', 'YYYY-MM-DD HH24:MI:SS'), 'SA_REP', 9600, 0.2, 148, 80);
INSERT INTO EMPLOYEES03(EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
VALUES(EMPLOYEES03_SEQ.NEXTVAL, 'William', 'Smith', 'WSMITH', '011.44.1343.629268', TO_DATE('2007-02-23 00:00:00', 'YYYY-MM-DD HH24:MI:SS'), 'SA_REP', 7400, 0.15, 148, 80);
INSERT INTO EMPLOYEES03(EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
VALUES(EMPLOYEES03_SEQ.NEXTVAL, 'Elizabeth', 'Bates', 'EBATES', '011.44.1343.529268', TO_DATE('2007-03-24 00:00:00', 'YYYY-MM-DD HH24:MI:SS'), 'SA_REP', 7300, 0.15, 148, 80);
INSERT INTO EMPLOYEES03(EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
VALUES(EMPLOYEES03_SEQ.NEXTVAL, 'Sundita', 'Kumar', 'SKUMAR', '011.44.1343.329268', TO_DATE('2008-04-21 00:00:00', 'YYYY-MM-DD HH24:MI:SS'), 'SA_REP', 6100, 0.1, 148, 80);
INSERT INTO EMPLOYEES03(EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
VALUES(EMPLOYEES03_SEQ.NEXTVAL, 'Ellen', 'Abel', 'EABEL', '011.44.1644.429267', TO_DATE('2004-05-11 00:00:00', 'YYYY-MM-DD HH24:MI:SS'), 'SA_REP', 11000, 0.3, 149, 80);
INSERT INTO EMPLOYEES03(EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
VALUES(EMPLOYEES03_SEQ.NEXTVAL, 'Alyssa', 'Hutton', 'AHUTTON', '011.44.1644.429266', TO_DATE('2005-03-19 00:00:00', 'YYYY-MM-DD HH24:MI:SS'), 'SA_REP', 8800, 0.25, 149, 80);
INSERT INTO EMPLOYEES03(EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
VALUES(EMPLOYEES03_SEQ.NEXTVAL, 'Jonathon', 'Taylor', 'JTAYLOR', '011.44.1644.429265', TO_DATE('2006-03-24 00:00:00', 'YYYY-MM-DD HH24:MI:SS'), 'SA_REP', 8600, 0.2, 149, 80);
INSERT INTO EMPLOYEES03(EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
VALUES(EMPLOYEES03_SEQ.NEXTVAL, 'Jack', 'Livingston', 'JLIVINGS', '011.44.1644.429264', TO_DATE('2006-04-23 00:00:00', 'YYYY-MM-DD HH24:MI:SS'), 'SA_REP', 8400, 0.2, 149, 80);
INSERT INTO EMPLOYEES03(EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
VALUES(EMPLOYEES03_SEQ.NEXTVAL, 'Kimberely', 'Grant', 'KGRANT', '011.44.1644.429263', TO_DATE('2007-05-24 00:00:00', 'YYYY-MM-DD HH24:MI:SS'), 'SA_REP', 7000, 0.15, 149, NULL);
INSERT INTO EMPLOYEES03(EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
VALUES(EMPLOYEES03_SEQ.NEXTVAL, 'Charles', 'Johnson', 'CJOHNSON', '011.44.1644.429262', TO_DATE('2008-01-04 00:00:00', 'YYYY-MM-DD HH24:MI:SS'),'SA_REP', 6200, 0.1, 149, 80);
INSERT INTO EMPLOYEES03(EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
VALUES(EMPLOYEES03_SEQ.NEXTVAL, 'Winston', 'Taylor', 'WTAYLOR', '650.507.9876', TO_DATE('2006-01-24 00:00:00', 'YYYY-MM-DD HH24:MI:SS'), 'SH_CLERK', 3200, NULL, 120, 50);

INSERT INTO EMPLOYEES03(EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
VALUES(EMPLOYEES03_SEQ.NEXTVAL, 'Jean', 'Fleaur', 'JFLEAUR', '650.507.9877', TO_DATE('2006-02-23 00:00:00', 'YYYY-MM-DD HH24:MI:SS'), 'SH_CLERK', 3100, NULL, 120, 50);
INSERT INTO EMPLOYEES03(EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
VALUES(EMPLOYEES03_SEQ.NEXTVAL, 'Martha', 'Sullivan', 'MSULLIVA', '650.507.9878', TO_DATE('2007-06-21 00:00:00', 'YYYY-MM-DD HH24:MI:SS'),'SH_CLERK', 2500, NULL, 120, 50);
INSERT INTO EMPLOYEES03(EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
VALUES(EMPLOYEES03_SEQ.NEXTVAL, 'Girard', 'Geoni', 'GGEONI', '650.507.9879', TO_DATE('2008-02-03 00:00:00', 'YYYY-MM-DD HH24:MI:SS'), 'SH_CLERK', 2800, NULL, 120, 50);
INSERT INTO EMPLOYEES03(EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
VALUES(EMPLOYEES03_SEQ.NEXTVAL, 'Nandita', 'Sarchand', 'NSARCHAN', '650.509.1876', TO_DATE('2004-01-27 00:00:00', 'YYYY-MM-DD HH24:MI:SS'), 'SH_CLERK', 4200, NULL, 121, 50);
INSERT INTO EMPLOYEES03(EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
VALUES(EMPLOYEES03_SEQ.NEXTVAL, 'Alexis', 'Bull', 'ABULL', '650.509.2876', TO_DATE('2005-02-20 00:00:00', 'YYYY-MM-DD HH24:MI:SS'), 'SH_CLERK', 4100, NULL, 121, 50);
INSERT INTO EMPLOYEES03(EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
VALUES(EMPLOYEES03_SEQ.NEXTVAL, 'Julia', 'Dellinger', 'JDELLING', '650.509.3876', TO_DATE('2006-06-24 00:00:00', 'YYYY-MM-DD HH24:MI:SS'), 'SH_CLERK', 3400, NULL, 121, 50);
INSERT INTO EMPLOYEES03(EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
VALUES(EMPLOYEES03_SEQ.NEXTVAL, 'Anthony', 'Cabrio', 'ACABRIO', '650.509.4876', TO_DATE('2007-02-07 00:00:00', 'YYYY-MM-DD HH24:MI:SS'), 'SH_CLERK', 3000, NULL, 121, 50);
INSERT INTO EMPLOYEES03(EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
VALUES(EMPLOYEES03_SEQ.NEXTVAL, 'Kelly', 'Chung', 'KCHUNG', '650.505.1876', TO_DATE('2005-06-14 00:00:00', 'YYYY-MM-DD HH24:MI:SS'), 'SH_CLERK', 3800, NULL, 122, 50);
INSERT INTO EMPLOYEES03(EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
VALUES(EMPLOYEES03_SEQ.NEXTVAL, 'Jennifer', 'Dilly', 'JDILLY', '650.505.2876', TO_DATE('2005-08-13 00:00:00', 'YYYY-MM-DD HH24:MI:SS'), 'SH_CLERK', 3600, NULL, 122, 50);
INSERT INTO EMPLOYEES03(EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
VALUES(EMPLOYEES03_SEQ.NEXTVAL, 'Timothy', 'Gates', 'TGATES', '650.505.3876', TO_DATE('2006-07-11 00:00:00', 'YYYY-MM-DD HH24:MI:SS'), 'SH_CLERK', 2900, NULL, 122, 50);

INSERT INTO EMPLOYEES03(EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
VALUES(EMPLOYEES03_SEQ.NEXTVAL, 'Randall', 'Perkins', 'RPERKINS', '650.505.4876', TO_DATE('2007-12-19 00:00:00', 'YYYY-MM-DD HH24:MI:SS'), 'SH_CLERK', 2500, NULL, 122, 50);
INSERT INTO EMPLOYEES03(EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
VALUES(EMPLOYEES03_SEQ.NEXTVAL, 'Sarah', 'Bell', 'SBELL', '650.501.1876', TO_DATE('2004-02-04 00:00:00', 'YYYY-MM-DD HH24:MI:SS'), 'SH_CLERK', 4000, NULL, 123, 50);
INSERT INTO EMPLOYEES03(EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
VALUES(EMPLOYEES03_SEQ.NEXTVAL, 'Britney', 'Everett', 'BEVERETT', '650.501.2876', TO_DATE('2005-03-03 00:00:00', 'YYYY-MM-DD HH24:MI:SS'), 'SH_CLERK', 3900, NULL, 123, 50);
INSERT INTO EMPLOYEES03(EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
VALUES(EMPLOYEES03_SEQ.NEXTVAL, 'Samuel', 'McCain', 'SMCCAIN', '650.501.3876', TO_DATE('2006-07-01 00:00:00', 'YYYY-MM-DD HH24:MI:SS'), 'SH_CLERK', 3200, NULL, 123, 50);
INSERT INTO EMPLOYEES03(EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
VALUES(EMPLOYEES03_SEQ.NEXTVAL, 'Vance', 'Jones', 'VJONES', '650.501.4876', TO_DATE('2007-03-17 00:00:00', 'YYYY-MM-DD HH24:MI:SS'), 'SH_CLERK', 2800, NULL, 123, 50);
INSERT INTO EMPLOYEES03(EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
VALUES(EMPLOYEES03_SEQ.NEXTVAL, 'Alana', 'Walsh', 'AWALSH', '650.507.9811', TO_DATE('2006-04-24 00:00:00', 'YYYY-MM-DD HH24:MI:SS'), 'SH_CLERK', 3100, NULL, 124, 50);
INSERT INTO EMPLOYEES03(EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
VALUES(EMPLOYEES03_SEQ.NEXTVAL, 'Kevin', 'Feeney', 'KFEENEY', '650.507.9822', TO_DATE('2006-05-23 00:00:00', 'YYYY-MM-DD HH24:MI:SS'), 'SH_CLERK', 3000, NULL, 124, 50);
INSERT INTO EMPLOYEES03(EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
VALUES(EMPLOYEES03_SEQ.NEXTVAL, 'Donald', 'OConnell', 'DOCONNEL', '650.507.9833', TO_DATE('2007-06-21 00:00:00', 'YYYY-MM-DD HH24:MI:SS'), 'SH_CLERK', 2600, NULL, 124, 50);
INSERT INTO EMPLOYEES03(EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
VALUES(EMPLOYEES03_SEQ.NEXTVAL, 'Douglas', 'Grant', 'DGRANT', '650.507.9844', TO_DATE('2008-01-13 00:00:00', 'YYYY-MM-DD HH24:MI:SS'), 'SH_CLERK', 2600, NULL, 124, 50);
INSERT INTO EMPLOYEES03(EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
VALUES(EMPLOYEES03_SEQ.NEXTVAL, 'Jennifer', 'Whalen', 'JWHALEN', '515.123.4444', TO_DATE('2003-09-17 00:00:00', 'YYYY-MM-DD HH24:MI:SS'), 'AD_ASST', 4400, NULL, 101, 10);

INSERT INTO EMPLOYEES03(EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
VALUES(EMPLOYEES03_SEQ.NEXTVAL, 'Michael', 'Hartstein', 'MHARTSTE', '515.123.5555', TO_DATE('2004-02-17 00:00:00', 'YYYY-MM-DD HH24:MI:SS'), 'MK_MAN', 13000, NULL, 100, 20);
INSERT INTO EMPLOYEES03(EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
VALUES(EMPLOYEES03_SEQ.NEXTVAL, 'Pat', 'Fay', 'PFAY', '603.123.6666', TO_DATE('2005-08-17 00:00:00', 'YYYY-MM-DD HH24:MI:SS'), 'MK_REP', 6000, NULL, 201, 20);
INSERT INTO EMPLOYEES03(EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
VALUES(EMPLOYEES03_SEQ.NEXTVAL, 'Susan', 'Mavris', 'SMAVRIS', '515.123.7777', TO_DATE('2002-06-07 00:00:00', 'YYYY-MM-DD HH24:MI:SS'), 'HR_REP', 6500, NULL, 101, 40);
INSERT INTO EMPLOYEES03(EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
VALUES(EMPLOYEES03_SEQ.NEXTVAL, 'Hermann', 'Baer', 'HBAER', '515.123.8888', TO_DATE('2002-06-07 00:00:00', 'YYYY-MM-DD HH24:MI:SS'), 'PR_REP', 10000, NULL, 101, 70);
INSERT INTO EMPLOYEES03(EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
VALUES(EMPLOYEES03_SEQ.NEXTVAL, 'Shelley', 'Higgins', 'SHIGGINS', '515.123.8080', TO_DATE('2002-06-07 00:00:00', 'YYYY-MM-DD HH24:MI:SS'), 'AC_MGR', 12008, NULL, 101, 110);
INSERT INTO EMPLOYEES03(EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
VALUES(EMPLOYEES03_SEQ.NEXTVAL, 'William', 'Gietz', 'WGIETZ', '515.123.8181', TO_DATE('2002-06-07 00:00:00', 'YYYY-MM-DD HH24:MI:SS'), 'AC_ACCOUNT', 8300, NULL, 205, 110);
--==> 1 행 이(가) 삽입되었습니다. * 107



--■ JOB_HISTORY03 테이블 생성
CREATE TABLE JOB_HISTORY03
( EMPLOYEE_ID       NUMBER(6)       CONSTRAINT JHIST03_EMPLOYEE_NN NOT NULL
, START_DATE        DATE            CONSTRAINT JHIST03_START_DATE_NN NOT NULL
, END_DATE          DATE            CONSTRAINT JHIST03_END_DATE_NN NOT NULL
, JOB_ID            VARCHAR2(10)    CONSTRAINT JHIST03_JOB_NN NOT NULL
, DEPARTMENT_ID     NUMBER(4)
, CONSTRAINT JHIST03_DATE_INTERVAL CHECK(END_DATE > START_DATE)
, CONSTRAINT JHIST03_EMP_ID_ST_DATE_PK PRIMARY KEY(EMPLOYEE_ID,START_DATE)
, CONSTRAINT JHIST03_JOB_FK FOREIGN KEY(JOB_ID)
                    REFERENCES JOBS03(JOB_ID)
, CONSTRAINT JHIST03_EMP_FK FOREIGN KEY(EMPLOYEE_ID)
                    REFERENCES EMPLOYEES03(EMPLOYEE_ID)
, CONSTRAINT JHIST03_DEPT_FK FOREIGN KEY(DEPARTMENT_ID)
                    REFERENCES DEPARTMENTS03(DEPARTMENT_ID)
);
--==>> Table JOB_HISTORY03이(가) 생성되었습니다.

--○ JOB_HISTORY03 테이블에 데이터 입력
INSERT INTO JOB_HISTORY03(EMPLOYEE_ID, START_DATE, END_DATE, JOB_ID, DEPARTMENT_ID)
VALUES(102,TO_DATE('2001-01-13 00:00:00', 'YYYY-MM-DD HH24:MI:SS'), TO_DATE('2006-07-24 00:00:00', 'YYYY-MM-DD HH24:MI:SS'), 'IT_PROG', 60);
INSERT INTO JOB_HISTORY03(EMPLOYEE_ID, START_DATE, END_DATE, JOB_ID, DEPARTMENT_ID)
VALUES(101,TO_DATE('1997-09-21 00:00:00', 'YYYY-MM-DD HH24:MI:SS'), TO_DATE('2001-10-27 00:00:00', 'YYYY-MM-DD HH24:MI:SS'), 'AC_ACCOUNT', 110);
INSERT INTO JOB_HISTORY03(EMPLOYEE_ID, START_DATE, END_DATE, JOB_ID, DEPARTMENT_ID)
VALUES(101,TO_DATE('2001-10-28 00:00:00', 'YYYY-MM-DD HH24:MI:SS'), TO_DATE('2005-03-15 00:00:00', 'YYYY-MM-DD HH24:MI:SS'), 'AC_MGR', 110);
INSERT INTO JOB_HISTORY03(EMPLOYEE_ID, START_DATE, END_DATE, JOB_ID, DEPARTMENT_ID)
VALUES(201,TO_DATE('2004-02-17 00:00:00', 'YYYY-MM-DD HH24:MI:SS'), TO_DATE('2007-12-19 00:00:00', 'YYYY-MM-DD HH24:MI:SS'), 'MK_REP', 20);
INSERT INTO JOB_HISTORY03(EMPLOYEE_ID, START_DATE, END_DATE, JOB_ID, DEPARTMENT_ID)
VALUES(114,TO_DATE('2006-03-24 00:00:00', 'YYYY-MM-DD HH24:MI:SS'), TO_DATE('2007-12-31 00:00:00', 'YYYY-MM-DD HH24:MI:SS'), 'ST_CLERK', 50);
INSERT INTO JOB_HISTORY03(EMPLOYEE_ID, START_DATE, END_DATE, JOB_ID, DEPARTMENT_ID)
VALUES(122,TO_DATE('2007-01-01 00:00:00', 'YYYY-MM-DD HH24:MI:SS'), TO_DATE('2007-12-31 00:00:00', 'YYYY-MM-DD HH24:MI:SS'), 'ST_CLERK', 50);
INSERT INTO JOB_HISTORY03(EMPLOYEE_ID, START_DATE, END_DATE, JOB_ID, DEPARTMENT_ID)
VALUES(200,TO_DATE('1995-09-17 00:00:00', 'YYYY-MM-DD HH24:MI:SS'), TO_DATE('2001-06-17 00:00:00', 'YYYY-MM-DD HH24:MI:SS'), 'AD_ASST', 90);
INSERT INTO JOB_HISTORY03(EMPLOYEE_ID, START_DATE, END_DATE, JOB_ID, DEPARTMENT_ID)
VALUES(176,TO_DATE('2006-03-24 00:00:00', 'YYYY-MM-DD HH24:MI:SS'), TO_DATE('2006-12-31 00:00:00', 'YYYY-MM-DD HH24:MI:SS'), 'SA_REP', 80);
INSERT INTO JOB_HISTORY03(EMPLOYEE_ID, START_DATE, END_DATE, JOB_ID, DEPARTMENT_ID)
VALUES(176,TO_DATE('2007-01-01 00:00:00', 'YYYY-MM-DD HH24:MI:SS'), TO_DATE('2007-12-31 00:00:00', 'YYYY-MM-DD HH24:MI:SS'), 'SA_MAN', 80);
INSERT INTO JOB_HISTORY03(EMPLOYEE_ID, START_DATE, END_DATE, JOB_ID, DEPARTMENT_ID)
VALUES(200,TO_DATE('2002-07-01 00:00:00', 'YYYY-MM-DD HH24:MI:SS'), TO_DATE('2006-12-31 00:00:00', 'YYYY-MM-DD HH24:MI:SS'), 'AC_ACCOUNT', 90);
--==>> 1 행 이(가) 삽입되었습니다. * 10



--■ 제약조건 추가
ALTER TABLE EMPLOYEES03
ADD CONSTRAINT EMP03_MANAGER_FK FOREIGN KEY(MANAGER_ID)
                REFERENCES EMPLOYEES03(EMPLOYEE_ID);
--> EMPLOYEES03 테이블의  MANAGER_ID 를 
-- EMPLOYEES03 테이블의 EMPLOYEE_ID 컬럼을 참조하는 FOREIGN KEY로 설정
                
ALTER TABLE DEPARTMENTS03
ADD CONSTRAINT DEPT03_MGR_FK FOREIGN KEY(MANAGER_ID)
                REFERENCES EMPLOYEES03(EMPLOYEE_ID);
-->  DEPARTMENTS03 테이블의  MANAGER_ID 를 
-- EMPLOYEES03 테이블의 EMPLOYEE_ID 컬럼을 참조하는 FOREIGN KEY로 설정



--■ TABLE COMMENT 작성
COMMENT ON TABLE COUNTRIES03 IS 'country table. Contains 25 rows. References with locations table.';
COMMENT ON TABLE LOCATIONS03 IS '"Locations table that contains specific address of a specific office,
warehouse, and/or production site of a company. Does not store addresses /
locations of customers. Contains 23 rows; references with the
departments and countries tables. "';
COMMENT ON TABLE DEPARTMENTS03 IS '"Departments table that shows details of departments where employees
work. Contains 27 rows; references with locations, employees, and job_history tables."';

COMMENT ON TABLE JOBS03 IS '"jobs table with job titles and salary ranges. Contains 19 rows.
References with employees and job_history table."';
COMMENT ON TABLE EMPLOYEES03 IS '"employees table. Contains 107 rows. References with departments,
jobs, job_history tables. Contains a self reference."';
COMMENT ON TABLE JOB_HISTORY03 IS '"Table that stores job history of the employees. If an employee
changes departments within the job or changes jobs within the department,
new rows get inserted into this table with old job information of the
employee. Contains a complex primary key: employee_id+start_date.
Contains 25 rows. References with jobs, employees, and departments tables."';
--==>> Comment이(가) 생성되었습니다. * 6



--■ COLUMN COMMENT 작성
-- LOCATIONS03
COMMENT ON COLUMN LOCATIONS03.LOCATION_ID IS 'Primary key of locations table';
COMMENT ON COLUMN LOCATIONS03.STREET_ADDRESS IS '"Street address of an office, warehouse, or production site of a company.
Contains building number and street name"';
COMMENT ON COLUMN LOCATIONS03.POSTAL_CODE IS '"Postal code of the location of an office, warehouse, or production site
of a company. "';
COMMENT ON COLUMN LOCATIONS03.CITY IS '"A not null column that shows city where an office, warehouse, or
production site of a company is located. "';
COMMENT ON COLUMN LOCATIONS03.STATE_PROVIENCE IS '"State or Province where an office, warehouse, or production site of a
company is located."';
COMMENT ON COLUMN LOCATIONS03.COUNTRY_ID IS '"Country where an office, warehouse, or production site of a company is
located. Foreign key to country_id column of the countries table."';

-- DEPARTMENTS03
COMMENT ON COLUMN DEPARTMENTS03.DEPARTMENT_ID IS 'Primary key column of departments table.';
COMMENT ON COLUMN DEPARTMENTS03.DEPARTMENT_NAME IS '"A not null column that shows name of a department. Administration,
Marketing, Purchasing, Human Resources, Shipping, IT, Executive, Public
Relations, Sales, Finance, and Accounting. "';
COMMENT ON COLUMN DEPARTMENTS03.MANAGER_ID IS 'Manager_id of a department. Foreign key to employee_id column of employees table. The manager_id column of the employee table references this column.';
COMMENT ON COLUMN DEPARTMENTS03.LOCATION_ID IS 'Location id where a department is located. Foreign key to location_id column of locations table.';

-- JOB_HISTORY03
COMMENT ON COLUMN JOB_HISTORY03.EMPLOYEE_ID IS '"A not null column in the complex primary key employee_id+start_date.
Foreign key to employee_id column of the employee table"';
COMMENT ON COLUMN JOB_HISTORY03.START_DATE IS '"A not null column in the complex primary key employee_id+start_date.
Must be less than the end_date of the job_history table. (enforced by
constraint jhist_date_interval)"';
COMMENT ON COLUMN JOB_HISTORY03.END_DATE IS '"Last day of the employee in this job role. A not null column. Must be
greater than the start_date of the job_history table.
(enforced by constraint jhist_date_interval)"';
COMMENT ON COLUMN JOB_HISTORY03.JOB_ID IS '"Job role in which the employee worked in the past; foreign key to
job_id column in the jobs table. A not null column."';
COMMENT ON COLUMN JOB_HISTORY03.DEPARTMENT_ID IS 'Department id in which the employee worked in the past; foreign key to deparment_id column in the departments table';

-- COUNTRIES03
COMMENT ON COLUMN COUNTRIES03.COUNTRY_ID IS 'Primary key of countries table.';
COMMENT ON COLUMN COUNTRIES03.COUNTRY_NAME IS 'Country name';
COMMENT ON COLUMN COUNTRIES03.REGION_ID IS 'Region ID for the country. Foreign key to region_id column in the departments table.';

-- JOBS03
COMMENT ON COLUMN JOBS03.JOB_ID IS 'Primary key of jobs table.';
COMMENT ON COLUMN JOBS03.JOB_TITLE IS 'A not null column that shows job title, e.g. AD_VP, FI_ACCOUNTANT';
COMMENT ON COLUMN JOBS03.MIN_SALARY IS 'Minimum salary for a job title.';
COMMENT ON COLUMN JOBS03.MAX_SALARY IS 'Maximum salary for a job title';

-- EMPLOYEES03
COMMENT ON COLUMN EMPLOYEES03.EMPLOYEE_ID IS 'Primary key of employees table.';
COMMENT ON COLUMN EMPLOYEES03.FIRST_NAME IS 'First name of the employee. A not null column.';
COMMENT ON COLUMN EMPLOYEES03.LAST_NAME IS 'Last name of the employee. A not null column.';
COMMENT ON COLUMN EMPLOYEES03.EMAIL IS 'Email id of the employee';
COMMENT ON COLUMN EMPLOYEES03.PHONE_NUMBER IS 'Phone number of the employee; includes country code and area code';
COMMENT ON COLUMN EMPLOYEES03.HIRE_DATE IS 'Date when the employee started on this job. A not null column.';
COMMENT ON COLUMN EMPLOYEES03.JOB_ID IS '"Current job of the employee; foreign key to job_id column of the
jobs table. A not null column."';
COMMENT ON COLUMN EMPLOYEES03.SALARY IS '"Monthly salary of the employee. Must be greater
than zero (enforced by constraint emp_salary_min)"';
COMMENT ON COLUMN EMPLOYEES03.COMMISSION_PCT IS '"Commission percentage of the employee; Only employees in sales
department elgible for commission percentage"';
COMMENT ON COLUMN EMPLOYEES03.MANAGER_ID IS '"Manager id of the employee; has same domain as manager_id in
departments table. Foreign key to employee_id column of employees table.
(useful for reflexive joins and CONNECT BY query)"';
COMMENT ON COLUMN EMPLOYEES03.DEPARTMENT_ID IS '"Department id where employee works; foreign key to department_id
column of the departments table"';


--==>> Comment이(가) 생성되었습니다. * 33




=== 20190405_02_hr.sql ===

SELECT USER 
FROM DUAL;
--==>> HR

--■■■ DEFAULT 표현식 ■■■--

-- 1. INSERT 와 UPDATE 문에서
--    사용자가 전달하는 특정 값이 아닌
--    기본 값을 입력하도록 처리할 수 있다.

-- 2. 형식 및 구조
-- 컬럼명 데이터타입 DEFAULT 기본값

-- 3. INSERT 명령 시 해당 컬럼에 입력될 값을 할당하지 않거나,
--    DEFAULT 키워드를 활용하여 기본 값을 입력하도록 할 수 있다.

-- 4. DEFAULT 키워드와 다른 제약(NOT NULL 등) 표기가 같이 오는 경우
--    DEFAULT 키워드를 먼저 표기(작성)할 것을 권장한다.

--○ DEFAULT 표현식 실습
-- 테이블 생성
CREATE TABLE TBL_BOARD                      -- 게시판 테이블 생성
( SID       NUMBER          PRIMARY KEY     -- 게시물 번호 → 식별자(자동 증가)
, NAME      VARCHAR(30)                     -- 게시물 작성자
, CONTENTS  VARCHAR(2000)                   -- 게시물 내용
, WRITEDAY  DATE            DEFAULT SYSDATE -- 게시물 작성일(현재 날짜 자동 입력)
, COMMENTS  NUMBER          DEFAULT 0       -- 게시물의 댓글 갯수(기본값 0)
, COUNTS    NUMBER          DEFAULT 0       -- 게시물 조회수(기본값 0)
);
--==>> Table TBL_BOARD이(가) 생성되었습니다.

--※ SID 를 자동 증가 값으로 운영하려면 시퀀스 객체가 필요하다.
--   자동으로 입력되는 컬럼은 사용자가 입력해야 하는 항목에서
--   제외시킬 수 있다.

-- 시퀀스 생성
CREATE SEQUENCE SEQ_BOARD
NOCACHE;
--==>> Sequence SEQ_BOARD이(가) 생성되었습니다.

-- 세션 설정 변경
ALTER SESSION SET NLS_DATE_FORMAT = 'YYYY-MM-DD HH24:MI:SS';
--==>> Session이(가) 변경되었습니다.


-- 게시물 작성
INSERT INTO TBL_BOARD(SID, NAME, CONTENTS, WRITEDAY, COMMENTS, COUNTS)
VALUES(SEQ_BOARD.NEXTVAL, '남상현'
, '오라클에서 DEFAULT 표현식을 실습중입니다.'
, TO_DATE('2019-04-05 11:01:13', 'YYYY-MM-DD HH24:MI:SS')
, 0, 0);
--==>> 1 행 이(가) 삽입되었습니다.

INSERT INTO TBL_BOARD(SID, NAME, CONTENTS, WRITEDAY, COMMENTS, COUNTS)
VALUES(SEQ_BOARD.NEXTVAL, '한승원'
, '계속 테스트중입니다.', SYSDATE, 0, 0);
--==>> 1 행 이(가) 삽입되었습니다.

INSERT INTO TBL_BOARD(SID, NAME, CONTENTS, WRITEDAY, COMMENTS, COUNTS)
VALUES(SEQ_BOARD.NEXTVAL, '김경환'
, '힘껏 테스트중입니다.', DEFAULT, DEFAULT, DEFAULT);
--==>> 1 행 이(가) 삽입되었습니다.

INSERT INTO TBL_BOARD(SID, NAME, CONTENTS)
VALUES(SEQ_BOARD.NEXTVAL, '진윤비', '테스트 마무리');
--==>> 1 행 이(가) 삽입되었습니다.

SELECT *
FROM TBL_BOARD;
/*
1	남상현	오라클에서 DEFAULT 표현식을 실습중입니다.	2019-04-05 11:01:13	0	0
2	한승원	계속 테스트중입니다.	                    2019-04-05 11:04:00	0	0
3	김경환	힘껏 테스트중입니다.	                    2019-04-05 11:05:33	0	0
4	진윤비	테스트 마무리	                            2019-04-05 11:06:55	0	0
*/


--○ DEFAULT 표현식 확인(조회)
SELECT *
FROM USER_TAB_COLUMNS
WHERE TABLE_NAME = 'TBL_BOARD';
--==>>
/*
TBL_BOARD	SID     	NUMBER			22			N	1		NO	NO		0		NO	YES	NONE
TBL_BOARD	NAME	    VARCHAR2		30			Y	2											CHAR_CS	30	NO	NO		30	B	NO	YES	NONE
TBL_BOARD	CONTENTS	VARCHAR2		2000		Y	3											CHAR_CS	2000	NO	NO		2000	B	NO	YES	NONE
TBL_BOARD	WRITEDAY	DATE			7			Y	4	60	"SYSDATE -- 게시물 작성일(현재 날짜 자동 입력)
"											NO	NO		0		NO	YES	NONE
TBL_BOARD	COMMENTS	NUMBER			22			Y	5	51	"0       -- 게시물의 댓글 갯수(기본값 0)
"											NO	NO		0		NO	YES	NONE
TBL_BOARD	COUNTS	    NUMBER			22			Y	6	44	"0       -- 게시물 조회수(기본값 0)
"											NO	NO		0		NO	YES	NONE
*/

--○ 테이블 생성 이후 DEFALUT 표현식 추가 / 변경
ALTER TABLE 테이블명
MODIFY 컬럼명 [자료형] DEFAULT 기본값;

--○ 생성된 DEFAULT 표현식 제거(삭제)
ALTER TABLE 테이블명
MODIFY 컬럼명 [자료형] DEFAULT NULL;




=== 20190408_01_scott ===

SELECT USER
FROM DUAL;
--==>> SCOTT

--■■■ UPDATE ■■■--

-- 1. 테이블에서 기존 데이터를 변경하는 구문

-- 2. 형식 및 구조
-- UPDATE 테이블명
-- SET 컬럼명 = 변경할 값[, 컬럼명 = 변경할 값, 컬럼명 = 변경할 값[
-- [WHERE 조건절]

SELECT *
FROM TBL_SAWON;

--○ TBL_SAWON 테이블에서 사원번호 1003번 사원의
--   주민번호를 『8710012234567』

UPDATE TBL_SAWON
SET JUBUN = '8710012234567'
WHERE SANO = 1003;
--==>> 1 행 이(가) 업데이트되었습니다.

SELECT *
FROM TBL_SAWON;

-- 실행 후 COMMIT 또는 ROLLBACK 을 반드시 선택적으로 실행
COMMIT;
--==>> 커밋 완료.


--○ TBL_SAWON 테이블에서 1005번 사원의 입사일과 급여를
--   각각 2018-02-22, 1200 으로 변경한다.
UPDATE TBL_SAWON
SET HIREDATE = TO_DATE('2018-02-22', 'YYYY-MM-DD'), SAL = 1200
WHERE SANO = 1005;
--==>> 1 행 이(가) 업데이트되었습니다.

SELECT *
FROM TBL_SAWON;

-- 실행 후 COMMIT 또는 ROLLBACK 을 반드시 선택적으로 실행
COMMIT;
--==>> 커밋 완료.


--○ TBL_INSA 테이블 복사(데이터만)
CREATE TABLE TBL_INSABACKUP
AS
SELECT *
FROM TBL_INSA;
--==>> Table TBL_INSABACKUP이(가) 생성되었습니다.


--○ TBL_INSABACKUP 테이블에서
--   직위가 과장과 부장만 수당 10% 인상
UPDATE TBL_INSABACKUP
SET SUDANG = SUDANG*1.1
WHERE JIKWI IN ('과장', '부장');
--==>> 15개 행 이(가) 업데이트되었습니다.

SELECT *
FROM TBL_INSABACKUP;

-- 실행 후 COMMIT 또는 ROLLBACK 을 반드시 선택적으로 실행
COMMIT;
--==>> 커밋 완료.


--○ TBL_INSABACKUP 테이블에서 전화번호가 016, 017, 018, 019 로 시작하는
--   전화번호인 경우 이를 모두 010 으로 변경한다.
UPDATE TBL_INSABACKUP
SET TEL = '010'||SUBSTR(TEL, 4)
WHERE SUBSTR(TEL, 1, 3) IN ('016', '017', '018', '019');
--==>> 24개 행 이(가) 업데이트되었습니다.

SELECT *
FROM TBL_INSABACKUP;

-- 실행 후 COMMIT 또는 ROLLBACK 을 반드시 선택적으로 실행
COMMIT;
--==>> 커밋 완료.


--○ TBL_SAWON 테이블 백업
CREATE TABLE TBL_SAWONBACKUP
AS
SELECT * 
FROM TBL_SAWON;
--==>> Table TBL_SAWONBACKUP이(가) 생성되었습니다.
--> TBL_SAWON 테이블의 데이터만 백업을 수행
--  즉, 다른 이름의 테이블 형태로 저장해 둔 상황


--○ 확인
SELECT *
FROM TBL_SAWONBACKUP;
SELECT *
FROM TBL_SAWON;


-- 위와 같이 UPDATE 처리 이후에 COMMIT 을 수행하였기 때문에
-- ROLLBACK 은 불가능한 상황이다.
-- 하지만, TBL_SAWONBACKUP 테이블에 데이터를 백업해 두었다.
-- SANAME 컬럼의 내용만 추출하여 대신 넣어줄수 있다는 것이다.

UPDATE TBL_SAWON
SET SANAME = ( SELECT SANAME
               FROM TBL_SAWONBACKUP
               WHERE SANO = TBL_SAWON.SANO);


-- 실행 후 COMMIT 또는 ROLLBACK 을 반드시 선택적으로 실행
COMMIT;
--==>> 커밋 완료.





=== 20190408_02_hr.sql ===

SELECT USER 
FROM DUAL;
--==>> HR


--○ EMPLOYEES 테이블의 직원들 SALARY 를 10% 인상한다.
--   단, 부서명이 'IT' 인 경우로 한정한다.
--   (결과 확인 후 ROLLBACK)
SELECT *
FROM EMPLOYEES;
--==>>
/*
100	Steven	    King	    SKING	    515.123.4567	    03/06/17	AD_PRES	    24000			    90
101	Neena	    Kochhar	    NKOCHHAR	515.123.4568	    05/09/21	AD_VP	    17000		    100	90
102	Lex	        De Haan	    LDEHAAN	    515.123.4569	    01/01/13	AD_VP	    17000		    100	90
103	Alexander	Hunold	    AHUNOLD	    590.423.4567	    06/01/03	IT_PROG	     9900	    	102	60
104	Bruce	    Ernst	    BERNST	    590.423.4568	    07/05/21	IT_PROG	     6600	    	103	60
105	David	    Austin	    DAUSTIN 	590.423.4569	    05/06/25	IT_PROG	     5280	    	103	60
106	Valli	    Pataballa	VPATABAL	590.423.4560	    06/02/05	IT_PROG	     5280	    	103	60
107	Diana	    Lorentz	    DLORENTZ	590.423.5567	    07/02/07	IT_PROG	     4620	    	103	60
108	Nancy	    Greenberg	NGREENBE	515.124.4569	    02/08/17	FI_MGR	    12008	    	101	100
109	Daniel	    Faviet	    DFAVIET	    515.124.4169	    02/08/16	FI_ACCOUNT	 9000	    	108	100
110	John	    Chen	    JCHEN	    515.124.4269	    05/09/28	FI_ACCOUNT	 8200	    	108	100
111	Ismael	    Sciarra	    ISCIARRA	515.124.4369	    05/09/30	FI_ACCOUNT	 7700	    	108	100
112	Jose Manuel	Urman	    JMURMAN	    515.124.4469	    06/03/07	FI_ACCOUNT	 7800	    	108	100
113	Luis	    Popp	    LPOPP	    515.124.4567	    07/12/07	FI_ACCOUNT	 6900	    	108	100
114	Den	        Raphaely	DRAPHEAL	515.127.4561	    02/12/07	PU_MAN	    11000	    	100	30
115	Alexander	Khoo	    AKHOO	    515.127.4562	    03/05/18	PU_CLERK	 3100	    	114	30
116	Shelli	    Baida	    SBAIDA	    515.127.4563	    05/12/24	PU_CLERK	 2900	    	114	30
117	Sigal	    Tobias	    STOBIAS	    515.127.4564	    05/07/24	PU_CLERK	 2800	    	114	30
118	Guy	        Himuro	    GHIMURO	    515.127.4565	    06/11/15	PU_CLERK	 2600	    	114	30
119	Karen	    Colmenares	KCOLMENA	515.127.4566	    07/08/10	PU_CLERK	 2500	    	114	30
120	Matthew	    Weiss	    MWEISS	    650.123.1234	    04/07/18	ST_MAN	     8000	    	100	50
121	Adam	    Fripp	    AFRIPP	    650.123.2234	    05/04/10	ST_MAN	     8200	    	100	50
122	Payam	    Kaufling	PKAUFLIN	650.123.3234	    03/05/01	ST_MAN	     7900	    	100	50
123	Shanta	    Vollman	    SVOLLMAN	650.123.4234	    05/10/10	ST_MAN	     6500	    	100	50
124	Kevin	    Mourgos	    KMOURGOS	650.123.5234	    07/11/16	ST_MAN	     5800	    	100	50
125	Julia	    Nayer	    JNAYER	    650.124.1214	    05/07/16	ST_CLERK	 3200	    	120	50
126	Irene	    Mikkilineni	IMIKKILI	650.124.1224	    06/09/28	ST_CLERK	 2700	    	120	50
127	James	    Landry	    JLANDRY	    650.124.1334	    07/01/14	ST_CLERK	 2400	    	120	50
128	Steven	    Markle	    SMARKLE	    650.124.1434	    08/03/08	ST_CLERK	 2200	    	120	50
129	Laura	    Bissot	    LBISSOT	    650.124.5234	    05/08/20	ST_CLERK	 3300	    	121	50
130	Mozhe	    Atkinson	MATKINSO	650.124.6234	    05/10/30	ST_CLERK	 2800	    	121	50
131	James	    Marlow	    JAMRLOW	    650.124.7234	    05/02/16	ST_CLERK	 2500	    	121	50
132	TJ	        Olson	    TJOLSON	    650.124.8234	    07/04/10	ST_CLERK	 2100	    	121	50
133	Jason	    Mallin	    JMALLIN	    650.127.1934	    04/06/14	ST_CLERK	 3300	    	122	50
134	Michael	    Rogers	    MROGERS	    650.127.1834	    06/08/26	ST_CLERK	 2900	    	122	50
135	Ki	        Gee	        KGEE	    650.127.1734	    07/12/12	ST_CLERK	 2400	    	122	50
136	Hazel	    Philtanker	HPHILTAN	650.127.1634	    08/02/06	ST_CLERK	 2200	    	122	50
137	Renske	    Ladwig	    RLADWIG	    650.121.1234	    03/07/14	ST_CLERK	 3600	    	123	50
138	Stephen	    Stiles	    SSTILES	    650.121.2034	    05/10/26	ST_CLERK	 3200	    	123	50
139	John	    Seo	        JSEO	    650.121.2019	    06/02/12	ST_CLERK	 2700	    	123	50
140	Joshua	    Patel	    JPATEL	    650.121.1834	    06/04/06	ST_CLERK	 2500	    	123	50
141	Trenna	    Rajs	    TRAJS	    650.121.8009	    03/10/17	ST_CLERK	 3500	    	124	50
142	Curtis	    Davies	    CDAVIES	    650.121.2994	    05/01/29	ST_CLERK	 3100	    	124	50
143	Randall	    Matos	    RMATOS	    650.121.2874	    06/03/15	ST_CLERK	 2600	    	124	50
144	Peter	    Vargas	    PVARGAS	    650.121.2004	    06/07/09	ST_CLERK	 2500	    	124	50
145	John	    Russell	    JRUSSEL	    011.44.1344.429268	04/10/01	SA_MAN	    14000	 0.4	100	80
146	Karen	    Partners	KPARTNER	011.44.1344.467268	05/01/05	SA_MAN	    13500	 0.3	100	80
147	Alberto	    Errazuriz	AERRAZUR	011.44.1344.429278	05/03/10	SA_MAN	    12000	 0.3    100	80
148	Gerald	    Cambrault	GCAMBRAU	011.44.1344.619268	07/10/15	SA_MAN	    11000	 0.3    100	80
149	Eleni	    Zlotkey	    EZLOTKEY	011.44.1344.429018	08/01/29	SA_MAN	    10500	 0.2    100	80
150	Peter	    Tucker	    PTUCKER	    011.44.1344.129268	05/01/30	SA_REP	    10000	 0.3    145	80
151	David	    Bernstein	DBERNSTE	011.44.1344.345268	05/03/24	SA_REP 	     9500	0.25	145	80
152	Peter	    Hall	    PHALL	    011.44.1344.478968	05/08/20	SA_REP  	 9000	0.25	145	80
153	Christopher	Olsen	    COLSEN	    011.44.1344.498718	06/03/30	SA_REP	     8000	 0.2 	145	80
154	Nanette	    Cambrault	NCAMBRAU	011.44.1344.987668	06/12/09	SA_REP	     7500	 0.2 	145	80
155	Oliver	    Tuvault	    OTUVAULT	011.44.1344.486508	07/11/23	SA_REP	     7000	0.15	145	80
156	Janette	    King	    JKING	    011.44.1345.429268	04/01/30	SA_REP	    10000	0.35	146	80
157	Patrick	    Sully	    PSULLY	    011.44.1345.929268	04/03/04	SA_REP	     9500	0.35	146	80
158	Allan	    McEwen	    AMCEWEN	    011.44.1345.829268	04/08/01	SA_REP	     9000	0.35	146	80
159	Lindsey	    Smith	    LSMITH	    011.44.1345.729268	05/03/10	SA_REP	     8000	 0.3    146	80
160	Louise	    Doran	    LDORAN	    011.44.1345.629268	05/12/15	SA_REP	     7500	 0.3    146	80
161	Sarath	    Sewall	    SSEWALL	    011.44.1345.529268	06/11/03	SA_REP	     7000	0.25	146	80
162	Clara	    Vishney	    CVISHNEY	011.44.1346.129268	05/11/11	SA_REP	    10500	0.25	147	80
163	Danielle	Greene	    DGREENE	    011.44.1346.229268	07/03/19	SA_REP	     9500	0.15	147	80
164	Mattea	    Marvins	    MMARVINS	011.44.1346.329268	08/01/24	SA_REP	     7200	 0.1    147	80
165	David	    Lee     	DLEE	    011.44.1346.529268	08/02/23	SA_REP	     6800	 0.1    147	80
166	Sundar	    Ande	    SANDE	    011.44.1346.629268	08/03/24	SA_REP	     6400	 0.1	147	80
167	Amit	    Banda	    ABANDA	    011.44.1346.729268	08/04/21	SA_REP	     6200	 0.1	147	80
168	Lisa	    Ozer	    LOZER	    011.44.1343.929268	05/03/11	SA_REP	    11500	0.25	148	80
169	Harrison	Bloom	    HBLOOM	    011.44.1343.829268	06/03/23	SA_REP	    10000	 0.2	148	80
170	Tayler	    Fox	        TFOX	    011.44.1343.729268	06/01/24	SA_REP	     9600	 0.2	148	80
171	William	    Smith	    WSMITH	    011.44.1343.629268	07/02/23	SA_REP	     7400	0.15	148	80
172	Elizabeth	Bates	    EBATES	    011.44.1343.529268	07/03/24	SA_REP	     7300	0.15	148	80
173	Sundita	    Kumar	    SKUMAR	    011.44.1343.329268	08/04/21	SA_REP	     6100	 0.1	148	80
174	Ellen	    Abel	    EABEL	    011.44.1644.429267	04/05/11	SA_REP	    11000	 0.3	149	80
175	Alyssa	    Hutton	    AHUTTON	    011.44.1644.429266	05/03/19	SA_REP	     8800	0.25	149	80
176	Jonathon	Taylor	    JTAYLOR	    011.44.1644.429265	06/03/24	SA_REP	     8600	 0.2	149	80
177	Jack	    Livingston	JLIVINGS	011.44.1644.429264	06/04/23	SA_REP	     8400	 0.2	149	80
178	Kimberely	Grant	    KGRANT	    011.44.1644.429263	07/05/24	SA_REP	     7000	0.15	149	
179	Charles	    Johnson 	CJOHNSON	011.44.1644.429262	08/01/04	SA_REP	     6200	 0.1	149	80
180	Winston	    Taylor	    WTAYLOR	    650.507.9876	    06/01/24	SH_CLERK	 3200		    120	50
181	Jean	    Fleaur	    JFLEAUR	    650.507.9877	    06/02/23	SH_CLERK	 3100	    	120	50
182	Martha	    Sullivan	MSULLIVA	650.507.9878	    07/06/21	SH_CLERK	 2500	    	120	50
183	Girard	    Geoni	    GGEONI	    650.507.9879	    08/02/03	SH_CLERK	 2800	    	120	50
184	Nandita	    Sarchand	NSARCHAN	650.509.1876	    04/01/27	SH_CLERK	 4200	    	121	50
185	Alexis	    Bull	    ABULL	    650.509.2876	    05/02/20	SH_CLERK	 4100	    	121	50
186	Julia	    Dellinger	JDELLING	650.509.3876	    06/06/24	SH_CLERK 	 3400	    	121	50
187	Anthony	    Cabrio	    ACABRIO	    650.509.4876	    07/02/07	SH_CLERK	 3000	    	121	50
188	Kelly	    Chung	    KCHUNG	    650.505.1876	    05/06/14	SH_CLERK 	 3800	    	122	50
189	Jennifer	Dilly	    JDILLY	    650.505.2876	    05/08/13	SH_CLERK	 3600	    	122	50
190	Timothy	    Gates	    TGATES	    650.505.3876	    06/07/11	SH_CLERK	 2900	    	122	50
191	Randall	    Perkins	    RPERKINS	650.505.4876	    07/12/19	SH_CLERK	 2500	    	122	50
192	Sarah	    Bell	    SBELL	    650.501.1876	    04/02/04	SH_CLERK	 4000	    	123	50
193	Britney	    Everett	    BEVERETT	650.501.2876    	05/03/03	SH_CLERK	 3900	    	123	50
194	Samuel	    McCain	    SMCCAIN	    650.501.3876    	06/07/01	SH_CLERK	 3200	    	123	50
195	Vance	    Jones	    VJONES	    650.501.4876	    07/03/17	SH_CLERK	 2800	    	123	50
196	Alana	    Walsh	    AWALSH	    650.507.9811	    06/04/24	SH_CLERK	 3100	    	124	50
197	Kevin	    Feeney	    KFEENEY	    650.507.9822	    06/05/23	SH_CLERK	 3000	    	124	50
198	Donald	    OConnell	DOCONNEL	650.507.9833	    07/06/21	SH_CLERK	 2600	    	124	50
199	Douglas	    Grant	    DGRANT	    650.507.9844    	08/01/13	SH_CLERK	 2600	    	124	50
200	Jennifer	Whalen	    JWHALEN	    515.123.4444    	03/09/17	AD_ASST	     4400 	    	101	10
201	Michael	    Hartstein	MHARTSTE	515.123.5555    	04/02/17	MK_MAN	    13000	    	100	20
202	Pat	        Fay 	    PFAY	    603.123.6666    	05/08/17	MK_REP	     6000	    	201	20
203	Susan	    Mavris	    SMAVRIS	    515.123.7777    	02/06/07	HR_REP	     6500	    	101	40
204	Hermann	    Baer	    HBAER	    515.123.8888    	02/06/07	PR_REP	    10000	    	101	70
205	Shelley	    Higgins	    SHIGGINS	515.123.8080    	02/06/07	AC_MGR	    12008	    	101	110
206	William	    Gietz	    WGIETZ	    515.123.8181    	02/06/07	AC_ACCOUNT	 8300	    	205	110
*/

SELECT *
FROM DEPARTMENTS;

UPDATE EMPLOYEES
SET SALARY = SALARY*1.1
WHERE SUBSTR(JOB_ID, 1, 2) IN ( SELECT DEPARTMENT_NAME 
                                FROM DEPARTMENTS 
                                WHERE DEPARTMENT_NAME = 'IT');
                                
-- UPDATE
UPDATE EMPLOYEES
SET SALARY = SALARY *1.1
WHERE DEPARTMENT_ID = ( SELECT DEPARTMENT_ID
                        FROM DEPARTMENTS
                        WHERE DEPARTMENT_NAME = 'IT');
--==>> 5개 행 이(가) 업데이트되었습니다.

ROLLBACK;
--==>> 롤백 완료.


--○ EMPLOYEES 테이블에서 JOB_TITLE 이 『Sasle Manager』 인 사원들의
--   SALARY 를 해당 직무(직종)의 최고 급여(MAX_SALARY)로 수정한다.
--   단, 입사일이 2006년 이전(해당 년도 제외) 입사자에 한하여
--   적용할 수 있도록 처리한다.,
--   (결과 확인 후 ROLLBACK)

SELECT *
FROM JOBS;

UPDATE EMPLOYEES
SET SALARY = ( SELECT MAX_SALARY
               FROM JOBS
               WHERE JOB_TITLE = 'Sales Manager')
WHERE EXTRACT(YEAR FROM HIRE_DATE) < 2006
      AND JOB_ID = ( SELECT JOB_ID
                     FROM JOBS
                     WHERE JOB_TITLE = 'Sales Manager');
                     
UPDATE EMPLOYEES
SET SALARY = ( SELECT MAX_SALARY
               FROM JOBS
               WHERE JOB_TITLE = 'Sales Manager')
WHERE JOB_ID = ( SELECT JOB_ID
                     FROM JOBS
                     WHERE JOB_TITLE = 'Sales Manager')
     AND TO_NUMBER(TO_CHAR(HIRE_DATE, 'YYYY')<=2005;

SELECT *
FROM EMPLOYEES;

ROLLBACK;
--==>> 롤백 완료.


--○ EMPLOYEES 테이블에서 SALARY 를
--   각 부서의 이름별로 다른 인상률을 적용하여 수정할 수 있도록 한다,
--   Finance → 10%
--   Executive → 15%
--   Accounting → 20%
--   나머지 → 0%
--   (결과 확인 후 ROLLBACK)

UPDATE EMPLOYEES
SET SALARY = CASE DEPARTMENT_ID
                                WHEN ( SELECT DEPARTMENT_ID
                                       FROM DEPARTMENTS
                                       WHERE DEPARTMENT_NAME='Finance')
                                THEN SALARY*1.1
                                WHEN ( SELECT DEPARTMENT_ID
                                       FROM DEPARTMENTS
                                       WHERE DEPARTMENT_NAME='Executive')
                                THEN SALARY*1.15
                                WHEN ( SELECT DEPARTMENT_ID
                                       FROM DEPARTMENTS
                                       WHERE DEPARTMENT_NAME='Accounting')
                                THEN SALARY*1.2
                                ELSE SALARY
            END;
--==>> 107개 행 이(가) 업데이트되었습니다.

UPDATE EMPLOYEES
SET SALARY = CASE DEPARTMENT_ID
                                WHEN ( SELECT DEPARTMENT_ID
                                       FROM DEPARTMENTS
                                       WHERE DEPARTMENT_NAME='Finance')
                                THEN SALARY*1.1
                                WHEN ( SELECT DEPARTMENT_ID
                                       FROM DEPARTMENTS
                                       WHERE DEPARTMENT_NAME='Executive')
                                THEN SALARY*1.15
                                WHEN ( SELECT DEPARTMENT_ID
                                       FROM DEPARTMENTS
                                       WHERE DEPARTMENT_NAME='Accounting')
                                THEN SALARY*1.2
                                ELSE SALARY
            END
WHERE DEPARTMENT_ID IN ( SELECT DEPARTMENT_ID
                         FROM DEPARTMENTS
                         WHERE DEPARTMENT_NAME IN ('Finance','Executive','Accounting'));
--==>> 11개 행 이(가) 업데이트되었습니다.

ROLLBACK;
--==>> 롤백 완료.




--■■■ DELETE ■■■--

-- 1. 테이블에서 지정된 행(레코드)을 삭제하는 데 사용하는 구문

-- 2. 형식 및 구조
-- DELETE [FROM] 테이블명
-- [WHERE 조건절];

DELETE
FROM EMPLOYEES
WHERE EMPLOYEE_ID = 198;
--==>> 1 행 이(가) 삭제되었습니다.

ROLLBACK;
--==>> 롤백 완료.


--○ EMPLOYEES 테이블에서 직원들의 정보를 삭제한다.
--   단, 부서명이 'IT' 인 경우로 한정한다.

--※ 실제로는 EMPLOYEES 테이블의 데이터가(삭제하고자 하는 대상)
--   다른 테이블(혹은 자기 자신 테이블)에 의해 참조당하는 경우
--   삭제되지 않을 수 있다는 사실을 염두해야 하며
--   그에 대한 이유도 알아야 한다.
DELETE
FROM EMPLOYEES
WHERE DEPARTMENT_ID = ( SELECT DEPARTMENT_ID
                        FROM DEPARTMENTS
                        WHERE DEPARTMENT_NAME = 'IT');
--==>> 에러 발생
/*
ORA-02292: integrity constraint (HR.DEPT_MGR_FK) violated - child record found
*/




--■■■ 뷰(VIEW) ■■■--

-- 1. 뷰(VIEW)란 이미 특정한 데이터베이스 내에 존재하는
--    하나 이상의 테이블에서 사용자가 얻디 원하는 데이터들만을
--    정확하고 편하게 가져오기 위하여 사전에 원하는 컬럼둘만 모아서
--    만들어놓은 가상의 테이블로 편의성 및 보안에 목적이 있다.

--    가상의 테이블이란 뷰가 실제로 존재하는 테이블(객체)이 아니라
--    하나 이상의 테이블에서 파생된 또 다른 정보를 볼 수 있는 방법이며
--    그 정보를 추출해내는 SQL 문장이라고 볼 수 있다.

-- 2. 형식 및 구조
-- CREATE [OR REPLACE] VIEW 뷰이름
-- [(ALIAS,[, ALIAS, ...])]
-- AS
-- 서브쿼리(SUBQUERY)
-- [WITH CHECK OPTION]
-- [WITH READ ONLY];


--○ 뷰 생성
CREATE OR REPLACE VIEW VIEW_EMPLOYEES
AS
SELECT E.FIRST_NAME, E.LAST_NAME, D.DEPARTMENT_NAME, L.CITY, C.COUNTRY_NAME, R.REGION_NAME
FROM EMPLOYEES E, DEPARTMENTS D, LOCATIONS L, COUNTRIES C, REGIONS R
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID(+)
  AND D.LOCATION_ID = L.LOCATION_ID(+)
  AND L.COUNTRY_ID = C.COUNTRY_ID(+)
  AND C.REGION_ID = R.REGION_ID(+);
--==>> View VIEW_EMPLOYEES이(가) 생성되었습니다.

--○ 뷰(VIEW) 조회
SELECT *
FROM VIEW_EMPLOYEES;

--○ 뷰(VIEW) 구조 확인
DESC VIEW_EMPLOYEES;
--==>>
/*
이름              널?       유형           
--------------- -------- ------------ 
FIRST_NAME               VARCHAR2(20) 
LAST_NAME       NOT NULL VARCHAR2(25) 
DEPARTMENT_NAME          VARCHAR2(30) 
CITY                     VARCHAR2(30) 
COUNTRY_NAME             VARCHAR2(40) 
REGION_NAME              VARCHAR2(25) 
*/


--○ 뷰(VIEW) 소스 확인 -- CHECK!!
SELECT VIEW_NAME, TEXT              -- TEXT
FROM USER_VIEWS                     -- USER_VIEWS
WHERE VIEW_NAME='VIEW_EMPLOYEES';
--==>>
/*
VIEW_EMPLOYEES	"SELECT E.FIRST_NAME, E.LAST_NAME, D.DEPARTMENT_NAME, L.CITY, C.COUNTRY_NAME, R.REGION_NAME
                 FROM EMPLOYEES E, DEPARTMENTS D, LOCATIONS L, COUNTRIES C, REGIONS R
                 WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID(+)
                   AND D.LOCATION_ID = L.LOCATION_ID(+)
                   AND L.COUNTRY_ID = C.COUNTRY_ID(+)
                   AND C.REGION_ID = R.REGION_ID(+)"
*/





=== 20190408_03_scott(plsql).sql ===

SELECT USER
FROM DUAL;
--==>> SCOTT

--■■■ PL/SQL ■■■--

-- 1. PL/SQL(Procedural Language extension to SQL) 은
--    프로그래밍 언어의 특성을 가지는 SQL 의 확장이며,
--    데이터 조작과 질의 문장은 PL/SQL 의 절차적 코드 안에 포함된다.
--    또한 PL/SQL을 사용하면 SQL로 할 수 없는 절차적 작업이 가능하다.
--    여기에서 『절차적』이라는 단어가 가지는 의미는
--    어떤 것이 어떤 과정을 거쳐 어떻게 완료되는지
--    그 방법을 정확하게 코드에 기술한다는 것을 의미한다.

-- 2. PL/SQL 은 절차적으로 표현하기 위해
--    변수를 선언할 수 있는 기능,
--    참과 거짓을 구별할 수 있는 기능,
--    실행과 흐름을 컨트롤할 수 있는 기능 등을 제공한다.

-- 3. PL/SQL 은 블럭 구조로 되어 있으며
--    블럭은 선언 부분, 실행 부분, 예외 처리 부분의
--    세 부분으로 구성되어 있다.
--    또한, 반드시 실행 부분은 존재해야 하며, 구조는 다음과 같다.

-- 4. 형식 및 구조
/*
[DECLARE]
    -- 선언문(declarations)
BEGIN
    -- 실행문(statements)
    
    [EXCEPTION]
        -- 예외 처리문(exception handlers)
END;
*/

-- 5. 변수 선언
/*
DECLARE
    변수명 자료형;
    변수명 자료형 := 초기값;
BEGIN
    PL/SQL 구문;
END;
*/

SET SERVEROUTPUT ON;
--==>> 작업이 완료되었습니다.
--> 『DBMS_OUTPUT.PUT_LINE()』 을 통해
--  화면에 결과를 출력하기 위한 환경변수 설정


--○ 변수에 임의의 값을 대입하고 출력하는 구문 작성
DECLARE
    -- 선언부
    D1 NUMBER := 10;
    D2 VARCHAR2(30) := 'HELLO';
    D3 VARCHAR2(20) := 'Oracle';
BEGIN
    -- 실행부
    DBMS_OUTPUT.PUT_LINE(D1);
    DBMS_OUTPUT.PUT_LINE(D2);
    DBMS_OUTPUT.PUT_LINE(D3);
END;
--==>>
/*
10
HELLO
Oracle


PL/SQL 프로시저가 성공적으로 완료되었습니다.
*/


--○ 변수에 임의의 값을 대입하고 출력하는 구문 작성
DECLARE
    -- 선언부
    D1 NUMBER := 10;
    D2 VARCHAR2(30) := 'HELLO';
    D3 VARCHAR2(20) := 'Oracle';
BEGIN
    -- 실행부
    D1 := D1 * 10;
    D2 := D2 || ' 희진';
    D3 := D3 || ' World';
    
    DBMS_OUTPUT.PUT_LINE(D1);
    DBMS_OUTPUT.PUT_LINE(D2);
    DBMS_OUTPUT.PUT_LINE(D3);
END;
--==>>
/*
100
HELLO 희진
Oracle World


PL/SQL 프로시저가 성공적으로 완료되었습니다.
*/


--○ IF문(조건문)
-- IF ~ THEN ~ ELSE ~ END IF;

-- 1. PL/SQL 의 IF 문장은 다른 언어의 IF 조건문과 거의 유사하다.
--    일치하는 조건에 따라 선택적으로 작업을 수행할 수 있도록 한다.
--    TRUE 이면 THEN 과 ELSE 사이의 문장을 수행하고
--    FALSE 나 NULL 이면 ELSE 와 END IF 사이의 문장을 수행하게 된다.

-- 2. 형식 및 구조
/*
IF 조건
    THEN 처리구문;
ELSIF
    THEN 처리구문;
ELSE
    처리구문;    
END IF;
*/

--○ 변수에 들어가있는 값에 따라
--   Excellent, Good, Fail 로 구분하여
--   결과를 출력하는 PL/SQL 구문을 작성한다.
DECLARE
    GRADE CHAR;
BEGIN
    GRADE := 'C';
    
    IF GRADE = 'A'
        THEN DBMS_OUTPUT.PUT_LINE('Excellent');
    ELSIF GRADE = 'B'
        THEN DBMS_OUTPUT.PUT_LINE('Good');
    ELSE
        DBMS_OUTPUT.PUT_LINE('Fail');
    END IF;
END;
--==>> Fail

DECLARE
    GRADE CHAR;
BEGIN
    GRADE := 'B';
    
    IF GRADE = 'A'
        THEN DBMS_OUTPUT.PUT_LINE('Excellent');
    ELSIF GRADE = 'B'
        THEN DBMS_OUTPUT.PUT_LINE('Good');
    ELSE
        DBMS_OUTPUT.PUT_LINE('Fail');
    END IF;
END;
--==>> Good

DECLARE
    GRADE CHAR;
BEGIN
    GRADE := 'A';
    
    IF (GRADE = 'A')
        THEN DBMS_OUTPUT.PUT_LINE('Excellent');
    ELSIF (GRADE = 'B')
        THEN DBMS_OUTPUT.PUT_LINE('Good');
    ELSE
        DBMS_OUTPUT.PUT_LINE('Fail');
    END IF;
END;
--==>> Excellent


--○ CASE문 (조건문)
-- CASE ~ WHEN ~ THEN ~ ELSE ~ END CASE;

-- 1. 형식 및 구조
/*
CASE 변수
    WHEN 값1
        THEN 실행문;
    WHEN 값2
        THEN 실행문;
    ELSE
        실행문;
END CASE;
*/

--○ 변수에 들어가있는 값에 따라
--   Excellent, Good, Fail 로 구분하여
--   결과를 출력하는 PL/SQL 구문을 작성한다.
--   단, CASE 구문을 활용하여 작성한다.
DECLARE
    GRADE CHAR;
BEGIN
    GRADE := 'A';
    
    CASE GRADE
        WHEN 'A'
            THEN DBMS_OUTPUT.PUT_LINE('Excellent');
        WHEN 'B'
            THEN DBMS_OUTPUT.PUT_LINE('Good');
        ELSE
            DBMS_OUTPUT.PUT_LINE('Fail');
    END CASE;
END;
--==>> Excellent


--○ 외부 입력 처리

-- 1. ACCEPT 문
-- ACCEPT 변수명 PROMPT '메세지';
-- 외부 변수로부터 입력받은 데이터를 내부 변수에 전달할 때
-- 『&외부변수명』 형태로 접근하게 된다.

--○ 정수 2개를 외부로부터(사용자로부터) 입력받아
--   이들의 덧셈 결과를 출력하는 PL/SQL 구문을 작성한다.

ACCEPT N1 PROMPT '첫 번째 정수를 입력하세요.';
ACCEPT N2 PROMPT '두 번째 정수를 입력하세요.';

DECLARE
    -- 주요 변수 선언 및 초기화
    NUM1 NUMBER := &N1;
    NUM2 NUMBER := &N2;
    TOTAL NUMBER := 0;
BEGIN
    -- 연산 및 처리
    TOTAL := NUM1 + NUM2;
    
    -- 결과 출력
    DBMS_OUTPUT.PUT_LINE(NUM1 || ' + ' || NUM2 || ' = ' || TOTAL);
END;
--==>> 25 + 47 = 72


--○ 사용자로부터 입력받은 금액을 화폐 단위로 출력하는 프로그램을 작성한다.
--   단, 반환 금액은 편의상 1천원 미만, 10원 이상 가능하다고 가정한다.
/*
실행 예)
바인딩 변수 입력 대화창 → 금액 입력 : 990

입력받은 금액 총액 : 990 원
화폐단위 : 오백원 1, 백원 4, 오십원 1, 십원 4
*/

ACCEPT MONEY PROMPT '금액 입력(10원 이상 1천원 미만) : ';

DECLARE
    COIN NUMBER := &MONEY;
    C500 NUMBER;
    C100 NUMBER;
    C50 NUMBER;
    C10 NUMBER;
BEGIN
    C500 := TRUNC(COIN/500);
    C100 := TRUNC(MOD(COIN,500)/100);
    C50 := TRUNC(MOD(COIN,100)/50);
    C10 := TRUNC(MOD(COIN,50)/10);
    
    DBMS_OUTPUT.PUT_LINE('화폐단위 : 오백원 ' || C500 || ', 백원 ' || C100 || ', 오십원 ' || C50 || ', 십원 ' || C10);
END;

ACCEPT INPUT PROMPT '금액 입력';

DECLARE
    --○ 주요 변수 선언 및 초기화
    MONEY  NUMBER := &INPUT;    -- 연산을 위해 담아둔 변수
    MONEY2 NUMBER := &INPUT;    -- 출력을 위해 담아둔 변수(연산 과정에서 값이 변하기 때문에)
    M500   NUMBER;    -- 500원 짜리 갯수를 담아둘 변수
    M100   NUMBER;    -- 100원 짜리 갯수를 담아둘 변수
    M50    NUMBER;    --  50원 짜리 갯수를 담아둘 변수
    M10    NUMBER;    --  10원 짜리 갯수를 담아둘 변수
BEGIN
    --○ 연산 및 처리
    -- MONEY 를 500으로 나눠서 몫을 취하고 나머지는 버린다. → 500원의 갯수
    M500 := TRUNC(MONEY/500);
    
    -- MONEY 를 500으로 나눠서 몫은 버리고 나머지는 취한다.
    -- 이 결과를 MONEY에 담아낸다.
    MONEY := MOD(MONEY,500);
    
    -- MONEY 를 100으로 나눠서 몫을 취하고 나머지는 버린다. → 100원의 갯수
    M100 := TRUNC(MONEY/100);
    
    -- MONEY 를 100으로 나눠서 몫은 버리고 나머지는 취한다.
    -- 이 결과를 MONEY에 담아낸다.
    MONEY := MOD(MONEY, 100);
    
    -- MONEY 를 50으로 나눠서 몫을 취하고 나머지는 버린다. → 50원의 갯수
    M50 := TRUNC(MONEY/50);
    
    -- MOENY 를 50으로 나눠서 몫은 버리고 나머지는 취한다.
    MONEY := MOD(MONEY, 50);
    
    -- MONEY 를 10으로 나눠서 몫을 취하고 나머지는 버린다. → 10원의 갯수
    M10 := TRUNC(MONEY/10);
    
    --○ 결과 출력
    DBMS_OUTPUT.PUT_LINE('입력받은 금액 총액 : ' || MONEY2 || '원');
    DBMS_OUTPUT.PUT_LINE('화폐단위 : 오백원 ' || M500 || ', 백원 ' || M100 || ', 오십원 ' || M50 || ', 십원 ' || M10);
END;
--> 바인딩 변수 입력 대화창에 970원 입력
/*
입력받은 금액 총액 : 970원
화폐단위 : 오백원 1, 백원 4, 오십원 1, 십원 2
*/


--○ 기본 반복문
-- LOOP ~ END LOOP;

-- 1. 조건과 상관없이 무조건 반복하는 구문.

-- 2. 형식 및 구조
/*
LOOP
    -- 실행문;
    EXIT WHEN 조건;       -- 조건이 참인 경우 반복문을 빠져나간다.
    
END LOOP;
*/

--○ 1 부터 10 까지의 수 출력 (LOOP 활용)
DECLARE
    N NUMBER;
BEGIN
    N := 1;
    LOOP
        DBMS_OUTPUT.PUT_LINE(N);
        EXIT WHEN N >= 10;
        N := N + 1;     -- N++;, N+=1;
    END LOOP;
END;
--==>>
/*
1
2
3
4
5
6
7
8
9
10
*/


--○ WHILE 반복문
-- WHILE LOOP ~ END LOOP;

-- 1. 제어 조건이 TRUE 인 동안 일련의 문장을 반복하기 위해
--    WHILE LOOP 문장을 사용한다.
--    조건은 반복이 시작될 때 체크하게 되어
--    LOOP 내의 문장이 한 번도 수행되지 않을 경우도 있다.
--    LOOP 를 시작할 때 조건이 FALSE 이면 반복 문장을 탈출하게 된다.

-- 2. 형식 및 구조
/*
WHILE 조건 LOOP   -- 조건이 참인 경우 반복 수행
    -- 실행문;
END LOOP;
*/

--○ 1 부터 10 까지의 수 출력 (WHILE LOOP 활용)
DECLARE
    N   NUMBER;
BEGIN
    N := 0;
    WHILE N<10 LOOP
        N := N + 1;
        DBMS_OUTPUT.PUT_LINE(N);
    END LOOP;
END;
--==>>
/*
1
2
3
4
5
6
7
8
9
10
*/


--○ FOR 반복문
-- FOR LOOP ~ END LOOP;

-- 1. 『시작 수』에서 1씩 증가하여
--    『끝냄 수』가 될 때 까지 반복 수행한다.

-- 2. 형식 및 구조
/*
FOR 카운터 in [REVERSE] 시작수 .. 끝냄수 LOOP    -- 기본적으로 정수 기반
    -- 실행문
END LOOP;
*/

--○ 1 부터 10 까지의 수 출력 (FOR LOOP 활용)
DECLARE
    N   NUMBER;
BEGIN
    FOR N IN 1 .. 10 LOOP
        DBMS_OUTPUT.PUT_LINE(N);
    END LOOP;
END;
--==>>
/*
1
2
3
4
5
6
7
8
9
10
*/


--○ 사용자로부터 임의의 단(구구단)을 입력받아
--   해당 단수의 구구단을 출력하는 PL/SQL 구문을 작성한다.
/*
실행 예)
바인딩 변수 입력 대화창 → 단을 입력해주세요 : 2

2 * 1 = 2
    :
*/

ACCEPT INPUT PROMPT '단을 입력하세요 :';

-- LOOP
DECLARE
    DAN NUMBER := &INPUT;
    N   NUMBER;
BEGIN
    N := 1;
    LOOP
        DBMS_OUTPUT.PUT_LINE(DAN || ' * ' || N || ' = ' || DAN*N);
        EXIT WHEN N >= 9;
        N := N + 1;
    END LOOP;
END;

-- WHILE LOOP
DECLARE
    DAN NUMBER := &INPUT;
    N   NUMBER;
BEGIN
    N := 0;
    WHILE N<9 LOOP
        N := N + 1;
        DBMS_OUTPUT.PUT_LINE(DAN || ' * ' || N || ' = ' || DAN*N);
    END LOOP;
END;

-- FOR LOOP
DECLARE
    DAN NUMBER := &INPUT;
    N   NUMBER;
BEGIN
    FOR N IN 1 .. 9 LOOP
        DBMS_OUTPUT.PUT_LINE(DAN || ' * ' || N || ' = ' || DAN*N);
    END LOOP;
END;





=== 20190409_01_hr(plsql).sql ===

SELECT USER
FROM DUAL;
--==>> HR

--○ %TYPE

-- 1. 특정 테이블에 포함되어 있는 컬럼의 자료형을 참조하는 데이터타입

-- 2. 형식 및 구조
-- 변수명 테이블명.컬럼명%TYPE [ := 초기값 ];

DESC EMPLOYEES;
SET SERVEROUTPUT ON;


--○ HR.EMPLOYEES 테이블의 특정 데이터를 변수에 저장
DECLARE
    -- VNAME    VARCHAR2(20);
    VNAME   EMPLOYEES.FIRST_NAME%TYPE;  -- VARCHAR2(20)
BEGIN
    SELECT FIRST_NAME INTO VNAME
    FROM EMPLOYEES
    WHERE EMPLOYEE_ID=103;
    
    DBMS_OUTPUT.PUT_LINE(VNAME);
END;
--==>> Alexander


--○ %ROWTYPE

-- 1. 테이블의 레코드와 같은 구조의 구조체 변수를 선언(여러 개의 컬럼)

-- 2. 형식 및 구조
-- 변수명 테이블명%ROWTYPE

--○ HR.EMPLOYEES 테이블의 데이터를 여러개 변수에 저장
DECLARE
    --VNAME   VARCHAR2(20);
    --VPHONE  VARCHAR2(20);
    --VEMAIL  VARCHAR2(25);
    
    --VNAME   EMPLOYEES.FIRST_NAME%TYPE;
    --VPHONE  EMPLOYEES.PHONE_NUMBER%TYPE;
    --VEMAIL  EMPLOYEES.EMAIL%TYPE
    
    VEMP    EMPLOYEES%ROWTYPE;
BEGIN
    SELECT FIRST_NAME, PHONE_NUMBER, EMAIL
        INTO VEMP.FIRST_NAME, VEMP.PHONE_NUMBER, VEMP.EMAIL
    FROM EMPLOYEES
    WHERE EMPLOYEE_ID=103;
    
    DBMS_OUTPUT.PUT_LINE(VEMP.FIRST_NAME||' - '||VEMP.PHONE_NUMBER||' - '||VEMP.EMAIL);
END;
--==>> Alexander - 590.423.4567 - AHUNOLD


--○ HR.EMPLOYEES 테이블의 여러명 데이터 여러개를 변수에 저장
DECLARE
    VEMP EMPLOYEES%ROWTYPE;
BEGIN
    SELECT FIRST_NAME, PHONE_NUMBER, EMAIL
        INTO VEMP.FIRST_NAME, VEMP.PHONE_NUMBER, VEMP.EMAIL
    FROM EMPLOYEES;
    
    DBMS_OUTPUT.PUT_LINE(VEMP.FIRST_NAME||' - '||VEMP.PHONE_NUMBER||' - '||VEMP.EMAIL);
END;
--==>> 에러 발생
/*
ORA-01422: exact fetch returns more than requested number of rows
*/
--> 여러 개의 행(ROWS) 정보를 얻어와 담으려고 하면
--  변수에 저장하는 것 자체가 불가능한 상황

-- 불가능!!





=== 20190402_01_scott.sql ===

SELECT USER
FROM DUAL;
--==>> SCOTT

--■■■ HAVING ■■■--

--○ EMP 테이블에서 부서번호가 20, 30인 부서를 대상으로
--   부서의 총 급여가 10000 보다 적을 경우만 부서별 총 급여를 조회한다.
SELECT DEPTNO, SUM(SAL)
FROM EMP
WHERE DEPTNO IN (20, 30)
GROUP BY DEPTNO;

SELECT DEPTNO, SUM(SAL)
FROM EMP
WHERE DEPTNO IN (20, 30)
  AND SUM(SAL) < 10000
GROUP BY DEPTNO;
--==>> 에러 발생
/*
ORA-00934: group function is not allowed here
00934. 00000 -  "group function is not allowed here"
*Cause:    
*Action:
17행, 7열에서 오류 발생
*/

SELECT DEPTNO, SUM(SAL)
FROM EMP
WHERE DEPTNO IN (20, 30)
GROUP BY DEPTNO
HAVING SUM(SAL) < 10000;
--==>> 30	9400

SELECT DEPTNO, SUM(SAL)
FROM EMP
GROUP BY DEPTNO
HAVING DEPTNO IN (20, 30)           -- 일반 조건문은 WHERE에 사용할 것을 권장
   AND SUM(SAL) < 10000;
--==>> 30	9400


----------------------------------------------------------------------------------------------------------------

--■■■ 중첩 그룹함수 / 분석함수 ■■■--

-- 그룹 함수 2 LEVEL 까지 중첩해서 사용할 수 있다.
-- 이마저도 MSSQL 은 불가능하다.
SELECT MAX(SUM(SAL))
FROM EMP
GROUP BY DEPTNO;
--==>> 10875

-- RANK()
-- DENSE_RANK()
--> ORACLE 9i 부터 적용 MSSQL 2005 부터 적용

-- 하위 버전에서는 RANK() 나 DENSE_RANK() 를 사용할 수 없기 때문에
-- 이를 대체하여 연산을 수행할 수 있는 방법을 강구해야 한다.

-- 예를 들어, 급여의 순위를 구하고자 한다면
-- 해당 사원의 급여보다 더 큰 값이 몇 개인지 확인한 후
-- 확인한 숫자에 +1 을 추가 연산해주면 그것이 곧 등수가 된다.

SELECT ENAME, SAL
FROM EMP;

SELECT COUNT(*) + 1
FROM EMP
WHERE SAL > 800;
--==>> 14 → SMITH 의 급여 등수

SELECT COUNT(*) + 1
FROM EMP
WHERE SAL > 1600;
--==>> 7 → ALLEN 의 급여 등수


--※ 서브 상관 쿼리 (상관 서브 쿼리)
--   메인 쿼리에 있는 테이블의 컬럼이
--   서브 쿼리의 조건절(WHERE절, HAVING절)에 사용되는 경우
--   우리는 이 쿼리문을 서브 상관 쿼리 라고 부른다.

SELECT ENAME"사원명", SAL"급여", 1"급여등수"
FROM EMP;

SELECT ENAME"사원명", SAL"급여"
     , (SELECT COUNT(*) + 1
        FROM EMP
        WHERE SAL > E1.SAL)"급여등수"
FROM EMP E1;
--==>>
/*
SMITH	 800	14
ALLEN	1600	 7
WARD	1250	10
JONES	2975	 4
MARTIN	1250	10
BLAKE	2850	 5
CLARK	2450	 6
SCOTT	3000	 2
KING	5000	 1
TURNER	1500	 8
ADAMS	1100	12
JAMES	 950	13
FORD	3000	 2
MILLER	1300	 9
*/


SELECT ENAME"사원명", SAL"급여"
     , (SELECT COUNT(*) + 1
        FROM EMP
        WHERE SAL > E1.SAL)"급여등수"
FROM EMP E1
ORDER BY 3;
--==>>
/*
KING	5000	 1
FORD	3000	 2
SCOTT	3000	 2
JONES	2975	 4
BLAKE	2850	 5
CLARK	2450	 6
ALLEN	1600	 7
TURNER	1500	 8
MILLER	1300	 9
WARD	1250	10
MARTIN	1250	10
ADAMS	1100	12
JAMES	 950	13
SMITH	 800	14
*/


--○ EMP 테이블을 대상으로 
--   사원명, 급여, 부서번호, 부서내급여등수, 전체급여등수 항목을 조회한다.
--   단, RANK() 함수를 사용하지 않고, 상관 서브 쿼리를 활용할 수 있도록 한다.



SELECT ENAME"사원명", SAL"급여"
     , (SELECT COUNT(*) + 1
        FROM EMP
        WHERE DEPTNO = E1.DEPTNO AND SAL > E1.SAL)"부서내급여등수"
     , (SELECT COUNT(*) + 1
        FROM EMP
        WHERE SAL > E1.SAL)"전체급여등수"
FROM EMP E1
ORDER BY E1.DEPTNO, SAL DESC;
--==>>
/*
KING	5000	1	 1
CLARK	2450	2	 6
MILLER	1300	3	 9
SCOTT	3000	1	 2
FORD	3000	1	 2
JONES	2975	3	 4
ADAMS	1100	4	12
SMITH	 800	5	14
BLAKE	2850	1	 5
ALLEN	1600	2	 7
TURNER	1500	3	 8
MARTIN	1250	4	10
WARD	1250	4	10
JAMES	 950	6	13
*/

ALTER SESSION SET NLS_DATE_FORMAT = 'YYYY-MM-DD';
--==>> Session이(가) 변경되었습니다.

--○ EMP 테이블을 대상으로 다음과 같이 조회할 수 있도록 한다.
/*
----------------------------------------------------------------------------
  사원명   부서번호    입사일       급여      부서내입사별급여누적
  CLARK	     10	    1981-06-09	    2450            2450
  KING	     10	    1981-11-17	    5000            7450
  MILLER     10	    1982-01-23	    1300            8750
  SMITH	     20	    1980-12-17	     800             800
  JONES	     20	    1981-04-02	    2975            3775
  FORD	     20	    1981-12-03	    3000
  SCOTT	     20	    1987-07-13	    3000
  ADAMS	     20	    1987-07-13	    1100
  ALLEN	     30	    1981-02-20	    1600
  WARD	     30	    1981-02-22	    1250
  BLAKE	     30	    1981-05-01	    2850
  TURNER     30	    1981-09-08	    1500
  MARTIN     30	    1981-09-28	    1250
  JAMES	     30	    1981-12-03	     950
----------------------------------------------------------------------------
*/

SELECT ENAME"사원명", DEPTNO"부서번호", HIREDATE"입사일", SAL"급여"
     , (SELECT SUM(SAL)
        FROM EMP
        WHERE DEPTNO = E1.DEPTNO AND HIREDATE <= E1.HIREDATE)"부서내입사별급여누적"
FROM EMP E1
ORDER BY 2, 3;
--==>>
/*
CLARK	10	1981-06-09	2450	 2450
KING	10	1981-11-17	5000	 7450
MILLER	10	1982-01-23	1300	 8750
SMITH	20	1980-12-17	 800	  800
JONES	20	1981-04-02	2975	 3775
FORD	20	1981-12-03	3000	 6775
SCOTT	20	1987-07-13	3000	10875
ADAMS	20	1987-07-13	1100	10875
ALLEN	30	1981-02-20	1600	 1600
WARD	30	1981-02-22	1250	 2850
BLAKE	30	1981-05-01	2850	 5700
TURNER	30	1981-09-08	1500	 7200
MARTIN	30	1981-09-28	1250	 8450
JAMES	30	1981-12-03	 950	 9400
*/


--○ TBL_EMP를 기반으로 입사한 사원수가 제일 많았을 때의
--   입사년월과 인원수를 조회할 수 있는 쿼리문을 구성한다.
/*
-------------------------------------
    입사년월        인원수
-------------------------------------
    2019-04           5 
-------------------------------------
*/
SELECT *
FROM(
    SELECT TO_CHAR(HIREDATE, 'YYYY-MM')"입사년월", COUNT(*)"인원수"
    FROM TBL_EMP
    GROUP BY TO_CHAR(HIREDATE, 'YYYY-MM')
)T
WHERE T.인원수 = (SELECT MAX(COUNT(*))
                  FROM TBL_EMP
                  GROUP BY TO_CHAR(HIREDATE, 'YYYY-MM'));
--==>>
/*
입사년월  인원수
------- ----------
2019-04     5
*/


SELECT TO_CHAR(HIREDATE, 'YYYY-MM')"입사년월", COUNT(*)"인원수"
FROM EMP
GROUP BY TO_CHAR(HIREDATE, 'YYYY-MM')
HAVING COUNT(*) = (SELECT MAX(COUNT(*))
                  FROM EMP
                  GROUP BY TO_CHAR(HIREDATE, 'YYYY-MM'));
--==>>
/*
1981-12	2
1981-09	2
1981-02	2
1987-07	2
*/


-------------------------------------------------------------------------------------------------------

--■■■ ROW_NUMBER() ■■■--

SELECT ROW_NUMBER() OVER(ORDER BY SAL DESC) "테스트"
     , ENAME"사원명", SAL"급여", HIREDATE"입사일"
FROM EMP
ORDER BY ENAME;


--※ 게시판의 게시물 번호를 SEQUENCE 나 IDENTITY 를 사용하게 되면
--   게시물을 삭제했을 경우, 삭제한 게시물의 자리에 다음 번호를 가진
--   게시물이 등록되는 상황이 발생하게 된다.
--   이는 보안 측면에서나 미관상 바람직하지 않은 상황일 수 있기 때문에
--   ROW_NUMBER() 의 사용을 고려해볼 수 있다.
--   관리의 목적으로 사용할 때에는 SEQUENCE 나 IDENTITY 를 사용하지만
--   단순히 게시물을 목록화하여 사용자에게 리스트 형식으로 보여줄 때에는
--   사용하지 않는 것이 좋다.

CREATE TABLE TBL_AAA
( NO        NUMBER
, NAME      VARCHAR2(30)
, GRADE     CHAR(10)
);
--==>> Table TBL_AAA이(가) 생성되었습니다.

INSERT INTO TBL_AAA(NO, NAME, GRADE) VALUES(1, '이지혜', 'A');
INSERT INTO TBL_AAA(NO, NAME, GRADE) VALUES(2, '이기승', 'B');
INSERT INTO TBL_AAA(NO, NAME, GRADE) VALUES(3, '윤희진', 'A');
INSERT INTO TBL_AAA(NO, NAME, GRADE) VALUES(4, '권홍비', 'C');
INSERT INTO TBL_AAA(NO, NAME, GRADE) VALUES(5, '권홍비', 'A');
INSERT INTO TBL_AAA(NO, NAME, GRADE) VALUES(6, '이기승', 'A');
INSERT INTO TBL_AAA(NO, NAME, GRADE) VALUES(7, '이기승', 'A');
--==>> 1 행 이(가) 삽입되었습니다. * 7

COMMIT;
--==>> 커밋 완료.

SELECT *
FROM TBL_AAA;
--==>>
/*
1	이지혜	A         
2	이기승	B         
3	윤희진	A         
4	권홍비	C         
5	권홍비	A         
6	이기승	A         
7	이기승	A         
*/

UPDATE TBL_AAA
SET GRADE = 'C'
WHERE NO=6;


SELECT *
FROM TBL_AAA
WHERE NO=6;
--==>> 6	이기승	A         


--○ SEQUENCE (시퀀스 : 주문번호) 생성
--   → 사전적인 의미 : 1.(일련의) 연속적인 사건들  2.(사건, 행동 등의) 순서

CREATE SEQUENCE SEQ_BOARD   -- 시퀀스 생성 기본 구문(MSSQL 의 IDENTITY 와 동일한 개념)
START WITH 1                -- 시작값
INCREMENT BY 1              -- 증가값
NOMAXVALUE                  -- 최대값 제한 없음
NOCACHE;                    -- 캐시 사용 안함(없음)
--==>> Sequence SEQ_BOARD이(가) 생성되었습니다.


--○ 테이블 생성(TBL_BOARD)
CREATE TABLE TBL_BOARD              -- TBL_BOARD 이름의 테이블 생성 → 게시판
( NO        NUMBER                  -- 게시물 번호       Ⅹ
, TITLE     VARCHAR2(50)            -- 게시물 제목       ○
, CONTENTS  VARCHAR2(2000)          -- 게시물 내용       ○
, NAME      VARCHAR2(20)            -- 게시물 작성자     △
, PW        VARCHAR2(20)            -- 게시물 패스워드   △
, CREATED   DATE DEFAULT SYSDATE    -- 게시물 작성일     Ⅹ
);
--==>> Table TBL_BOARD이(가) 생성되었습니다.


--○ 데이터 입력 → 게시판에 게시물 작성
INSERT INTO TBL_BOARD VALUES(SEQ_BOARD.NEXTVAL, '앗싸~1등', '내가 1등이지롱', '전훈의', 'JAVA006$', DEFAULT);
--==>> 1 행 이(가) 삽입되었습니다.

INSERT INTO TBL_BOARD VALUES(SEQ_BOARD.NEXTVAL, '건강관리', '다들 건강 챙깁시당', '유진석', 'JAVA006$', DEFAULT);
--==>> 1 행 이(가) 삽입되었습니다.

INSERT INTO TBL_BOARD VALUES(SEQ_BOARD.NEXTVAL, '오늘은', '점심 뭐먹지...', '최보라', 'JAVA006$', DEFAULT);
--==>> 1 행 이(가) 삽입되었습니다.

INSERT INTO TBL_BOARD VALUES(SEQ_BOARD.NEXTVAL, '오늘은', '미세먼지 없나?', '정임혜', 'JAVA006$', DEFAULT);
--==>> 1 행 이(가) 삽입되었습니다.

INSERT INTO TBL_BOARD VALUES(SEQ_BOARD.NEXTVAL, '공부히고싶은데', '뒤에서 잘 안보여요', '조현우', 'JAVA006$', DEFAULT);
--==>> 1 행 이(가) 삽입되었습니다.

INSERT INTO TBL_BOARD VALUES(SEQ_BOARD.NEXTVAL, '질문있습니다', '쉬었다 한면 안되나요', '남상현', 'JAVA006$', DEFAULT);
--==>> 1 행 이(가) 삽입되었습니다.

INSERT INTO TBL_BOARD VALUES(SEQ_BOARD.NEXTVAL, '질문있습니다', '생각나면 다시 질문할께요', '한승원', 'JAVA006$', DEFAULT);
--==>> 1 행 이(가) 삽입되었습니다.

--○ 확인
SELECT *
FROM TBL_BOARD;

--○ 커밋
COMMIT;
--==>> 커밋 완료.

--○ 게시물 삭제
DELETE
FROM TBL_BOARD
WHERE NO=4;
--==>> 1 행 이(가) 삭제되었습니다.

--○ 게시물 작성
INSERT INTO TBL_BOARD VALUES (SEQ_BOARD.NEXTVAL, '졸려요', '전 그냥 잘래요', '윤희진', 'JAVA006$', DEFAULT);
--==>> 1 행 이(가) 삽입되었습니다.

SELECT *
FROM TBL_BOARD;

--○ 게시물 삭제
DELETE
FROM TBL_BOARD
WHERE NO=2;
--==>> 1 행 이(가) 삭제되었습니다.

DELETE
FROM TBL_BOARD
WHERE NO=8;
--==>> 1 행 이(가) 삭제되었습니다.

--○ 게시물 작성
INSERT INTO TBL_BOARD VALUES (SEQ_BOARD.NEXTVAL, '저는요', '잘 지내고 있습니다.', '이원영', 'JAVA006$', DEFAULT);
--==>> 1 행 이(가) 삽입되었습니다.

--○ 커밋
COMMIT;
--==>> 커밋 완료.

SELECT *
FROM TBL_BOARD;
--==>>
/*
1	앗싸~1등	    내가 1등이지롱	            전훈의	JAVA006$	2019-04-02
3	오늘은	        점심 뭐먹지...	            최보라	JAVA006$	2019-04-02
5	공부히고싶은데	뒤에서 잘 안보여요	        조현우	JAVA006$	2019-04-02
6	질문있습니다	쉬었다 한면 안되나요	    남상현	JAVA006$	2019-04-02
7	질문있습니다	생각나면 다시 질문할께요	한승원	JAVA006$	2019-04-02
9	저는요	        잘 지내고 있습니다.	        이원영	JAVA006$	2019-04-02
*/

SELECT ROW_NUMBER() OVER(ORDER BY CREATED) "글번호"
     , TITLE "제목", NAME "작성자", CREATED "작성일"
FROM TBL_BOARD
ORDER BY 4 DESC;
--==>>
/*
6	저는요	        이원영	2019-04-02
5	질문있습니다	한승원	2019-04-02
4	질문있습니다	남상현	2019-04-02
3	공부히고싶은데	조현우	2019-04-02
2	오늘은	        최보라	2019-04-02
1	앗싸~1등	    전훈의	2019-04-02
*/

--○ 게시물 작성
INSERT INTO TBL_BOARD VALUES (SEQ_BOARD.NEXTVAL, '오빠', '저 맘에 안들죠', '김선아', 'JAVA006$', DEFAULT);
--==>> 1 행 이(가) 삽입되었습니다.

SELECT ROW_NUMBER() OVER(ORDER BY CREATED) "글번호"
     , TITLE "제목", NAME "작성자", CREATED "작성일"
FROM TBL_BOARD
ORDER BY 4 DESC;

--○ 게시물 삭제
DELETE
FROM TBL_BOARD
WHERE NO=7;
--==>> 1 행 이(가) 삭제되었습니다.

--○ 커밋
COMMIT;
--==>> 커밋 완료.


SELECT ROW_NUMBER() OVER(ORDER BY CREATED) "글번호"
     , TITLE "제목", NAME "작성자", CREATED "작성일"
FROM TBL_BOARD
ORDER BY 4 DESC;
--==>>
/*
6	오빠	        김선아	2019-04-02
5	저는요	        이원영	2019-04-02
4	질문있습니다	남상현	2019-04-02
3	공부히고싶은데	조현우	2019-04-02
2	오늘은	        최보라	2019-04-02
1	앗싸~1등	    전훈의	2019-04-02
*/


------------------------------------------------------------------------------------------------------

--■■■ JOIN(조인) ■■■--        ★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★

-- 1. SQL 1992 CODE
SELECT *
FROM EMP, DEPT;
--> 수학에서 말하는 데카르트 곱(Catersian Product)
--  두 테이블을 합친(결합한) 모든 경우의 수

-- Equi join : 서로 정확히 일치하는 데이터들끼리 연결시키는 결합
SELECT *
FROM EMP, DEPT
WHERE EMP.DEPTNO = DEPT.DEPTNO;

SELECT *
FROM EMP E, DEPT D
WHERE E.DEPTNO = D.DEPTNO;


-- Non Equi join : 범위 안에 적합한 데이터들끼리 연결시키는 결합
SELECT *
FROM SALGRADE;
SELECT *
FROM EMP;

SELECT *
FROM EMP E, SALGRADE S
WHERE E.SAL BETWEEN S.LOSAL AND S.HISAL;


-- Equi Join 시 『(+)』 를 활용한 결합 방법
SELECT *
FROM TBL_EMP E, TBL_DEPT D
WHERE E.DEPTNO = D.DEPTNO;
--> 총 14건의 데이터가 결합되어 조회된 상황
--  즉, 부서번호를 갖지 못한 사원들(5)은 모두 나락!!

SELECT *
FROM TBL_EMP E, TBL_DEPT D
WHERE E.DEPTNO = D.DEPTNO(+);       
--> 총 19 건의 데이터가 결합되어 조회된 상황
--  즉, 부서번호를 갖지 못한 사원들도 모두 조회된 상황

SELECT *
FROM TBL_EMP E, TBL_DEPT D
WHERE E.DEPTNO(+) = D.DEPTNO; 
--> 총 16 건의 데이터가 결합되어 조회된 상황
--  즉, 부서에 소속된 사원이 아무도 없는 부서도 모두 조회된 상황

--※ (+)가 없는 쪽 데이블의 데이터를 모두 메모리에 적재한 후
--   (+)가 있는 쪽 테이블의 데이터를 하나한 확인하여 결합시키는 형태로
--   JOIN 이 이루어진다.

SELECT *
FROM TBL_EMP E, TBL_DEPT D
WHERE E.DEPTNO(+) = D.DEPTNO(+);
--> 위와 같은 이유로 이러한 형식의 JOIN 구문은 존재하지 않는다.


-- 2. SQL 1999 CODE → 『JOIN』 키워드 등장 → JOIN 유형 명시
--                     결합 조건은 『WHERE』 대신 『ON』 사용

-- CROSS JOIN
SELECT *
FROM EMP CROSS JOIN DEPT;

-- INNER JOIN
SELECT *
FROM EMP E INNER JOIN DEPT D
ON E.DEPTNO = D.DEPTNO;

SELECT *
FROM EMP E INNER JOIN SALGRADE S
ON E.SAL BETWEEN S.LOSAL AND S.HISAL;

--※ INNER JOIN 시 INNER 는 생략 가능
SELECT *
FROM EMP E JOIN DEPT D
ON E.DEPTNO = D.DEPTNO;

SELECT *
FROM EMP E JOIN SALGRADE S
ON E.SAL BETWEEN S.LOSAL AND S.HISAL;


-- OUTER JOIN 
SELECT *
FROM TBL_EMP E LEFT OUTER JOIN TBL_DEPT D
ON E.DEPTNO = D.DEPTNO;

--※ 방향이 지정된 쪽 테이블(→ LEFT) 의 데이터를 모두 메모리에 적재한 후
--   방향이 지정되지 않은 쪽 테이블들의 데이터를 각각 확인하여 결합시키는 형태로
--   JOIN 이 이루어진다.

SELECT *
FROM TBL_EMP E RIGHT OUTER JOIN TBL_DEPT D
ON E.DEPTNO = D.DEPTNO;


SELECT *
FROM TBL_EMP E FULL OUTER JOIN TBL_DEPT D
ON E.DEPTNO = D.DEPTNO;

--※ OUTER JOIN 에서 OUTER 는 생략 가능

SELECT *
FROM TBL_EMP E LEFT JOIN TBL_DEPT D     -- OUTER JOIN
ON E.DEPTNO = D.DEPTNO;

SELECT *
FROM TBL_EMP E RIGHT JOIN TBL_DEPT D    -- OUTER JOIN
ON E.DEPTNO = D.DEPTNO;

SELECT *
FROM TBL_EMP E FULL JOIN TBL_DEPT D     -- OUTER JOIN
ON E.DEPTNO = D.DEPTNO;

SELECT *
FROM TBL_EMP E JOIN TBL_DEPT            -- INNER JOIN
ON E.DEPTNO = D.DEPTNO;

-------------------------------------------------------------------------------------------------------
SELECT *
FROM EMP E JOIN DEPT D
ON E.DEPTNO = D.DEPTNO;
-- 이 결과에서 직종이 CLERK 인 사원들만 조회

SELECT *
FROM EMP E JOIN DEPT D
ON E.DEPTNO = D.DEPTNO
AND JOB = 'CLERK';
-- 이렇게 쿼리문을 구성해도 조회하는 데는 문제가 없다.

SELECT *
FROM EMP E JOIN DEPT D
ON E.DEPTNO = D.DEPTNO
WHERE JOB = 'CLERK';
-- 하지만, 이와 같이 구성하여 조회할 수 있도록 권장한다.
-------------------------------------------------------------------------------------------------------

--○ EMP 테이블과 DEPT 테이블에서
--   직종이 MANAGER 와 CLERK 인 사원들만
--   부서번호, 부서명, 사원명, 직종명, 급여 항목을 조회한다.

SELECT D.DEPTNO"부서번호", D.DNAME"부서명", E.ENAME"사원명", E.JOB"직종명", E.SAL"급여"
FROM EMP E JOIN DEPT D
ON E.DEPTNO = D.DEPTNO
WHERE JOB = 'MANAGER' OR JOB = 'CLERK'
ORDER BY 4;
-- DEPTNO 는 EMP, DEPT 둘 다 해당되지만 부모자식을 구분하여 작성 (일 대 다수)
-->
SELECT DEPTNO           -- → EMP 테이블의 DEPTNO(다수)
FROM EMP;
--==>>
/*
20
30
30
20
30
30
10
20
10
30
20
30
20
10
*/

SELECT DEPTNO           -- → DEPT 테이블의 DEPTNO
FROM DEPT;
--==>>
/*
10
20
30
40
*/

SELECT DEPTNO, DNAME, ENAME, JOB, SAL
FROM EMP E, DEPT D
WHERE E.DEPTNO = D.DEPTNO;
--==>> 에러 발생
/*
ORA-00918: column ambiguously defined
00918. 00000 -  "column ambiguously defined"
*Cause:    
*Action:
649행, 8열에서 오류 발생
*/
--> 두 테이블 간 중복되는 컬럼에 대한 소속 테이블을
--  정해줘야(명시해 줘야)한다.

SELECT DNAME, ENAME, JOB, SAL
FROM EMP E, DEPT D
WHERE E.DEPTNO = D.DEPTNO;
--> 두 테이블 간 중복되는 컬럼이 존재하지 않는 조회 구문은
--  에러 발생하지 않는다.
--==>> 
/*
RESEARCH	SMITH	CLERK	     800
SALES	    ALLEN	SALESMAN	1600
SALES	    WARD	SALESMAN	1250
RESEARCH	JONES	MANAGER	    2975
SALES	    MARTIN	SALESMAN	1250
SALES	    BLAKE	MANAGER	    2850
ACCOUNTING	CLARK	MANAGER	    2450
RESEARCH	SCOTT	ANALYST	    3000
ACCOUNTING	KING	PRESIDENT	5000
SALES	    TURNER	SALESMAN	1500
RESEARCH	ADAMS	CLERK	    1100
SALES	    JAMES	CLERK	     950
RESEARCH	FORD	ANALYST	    3000
ACCOUNTING	MILLER	CLERK	    1300
*/


SELECT D.DEPTNO, DNAME, ENAME, JOB, SAL
-- SELECT E.DEPTNO, DNAME, ENAME, JOB, SAL
FROM EMP E, DEPT D
WHERE E.DEPTNO = D.DEPTNO;
--> 두 테이블 간 중복되는 컬럼에 대해 소속 테이블을 명시하는 경우
--  부서(DEPT), 사원(EMP) 중 어떤 테이블을 지정해도
--  쿼리문 수행에 대한 결과 반환에 문제가 없다.

--※ 하지만 두 테이블 간 중복되는 컬럼에 대해 소속 테이블을 명시하는 경우
--   부모 테이블의 컬럼을 참조할 수 있도록 해야 한다.

SELECT *
FROM DEPT;      -- 부모 테이블
SELECT *
FROM EMP;       -- 자식 테이블

--※ 부모 자식 테이블 관계를 명확히 정리할 수 있도록 한다. ★★★★★★

SELECT D.DEPTNO, D.DNAME, E.ENAME, E.JOB, E.SAL
FROM EMP E, DEPT D
WHERE E.DEPTNO = D.DEPTNO;
--> 두 테이블 간 중복된 컬럼이 아니더라도
--  소속 테이블을 명시할 수 있도록 권장한다.

SELECT D.DEPTNO, D.DNAME, E.ENAME, E.JOB, E.SAL
FROM EMP E LEFT JOIN DEPT D
ON E.DEPTNO = D.DEPTNO;

SELECT E.DEPTNO, D.DNAME, E.ENAME, E.JOB, E.SAL
FROM EMP E LEFT JOIN DEPT D
ON E.DEPTNO = D.DEPTNO;

---

SELECT D.DEPTNO, D.DNAME, E.ENAME, E.JOB, E.SAL
FROM EMP E RIGHT JOIN DEPT D
ON E.DEPTNO = D.DEPTNO;

SELECT E.DEPTNO, D.DNAME, E.ENAME, E.JOB, E.SAL
FROM EMP E RIGHT JOIN DEPT D
ON E.DEPTNO = D.DEPTNO;


--○ SELF JOIN (자기 조인)

-- EMP 테이블의 정보를 다음과 같이 조회할 수 있도록 한다.
/*
E         E       E       E           E         E
EMPNO     ENAME   JOB     MGR, EMPNO  ENAME     JOB
------------------------------------------------------------
사원번호  사원명  직종명  관리자번호  관리자명  관리자직종명
------------------------------------------------------------
7369      SMITH   CLERK   7902        FORD      ANALYST

EMP       EMP     EMP     EMP                                       --> ①
                          EMP         EMP       EMP                 --> ②
------------------------------------------------------------
*/

SELECT E1.EMPNO"사원번호", E1.ENAME"사원명", E1.JOB"직종명", E2.EMPNO"관리자번호", E2.ENAME"관리자명", E2.JOB"관리자직종명"
FROM EMP E1 LEFT JOIN EMP E2
ON E1.MGR = E2.EMPNO
ORDER BY 1;
/*
7369	SMITH	CLERK	    7902	FORD	ANALYST
7499	ALLEN	SALESMAN	7698	BLAKE	MANAGER
7521	WARD	SALESMAN	7698	BLAKE	MANAGER
7566	JONES	MANAGER	    7839	KING	PRESIDENT
7654	MARTIN	SALESMAN	7698	BLAKE	MANAGER
7698	BLAKE	MANAGER	    7839	KING	PRESIDENT
7782	CLARK	MANAGER	    7839	KING	PRESIDENT
7788	SCOTT	ANALYST	    7566	JONES	MANAGER
7839	KING	PRESIDENT			
7844	TURNER	SALESMAN	7698	BLAKE	MANAGER
7876	ADAMS	CLERK	    7788	SCOTT	ANALYST
7900	JAMES	CLERK	    7698	BLAKE	MANAGER
7902	FORD	ANALYST	    7566	JONES	MANAGER
7934	MILLER	CLERK	    7782	CLARK	MANAGER
*/

SELECT *
FROM EMP;


--○ 커밋
COMMIT;
--==>> 커밋 완료.





=== 20190409_03_scott.sql ===

SELECT USER
FROM DUAL;
--==>> SCOTT

--○ 생성한 함수(FN_GENDER)가 제대로 작동하는지의 여부 확인
SELECT NAME, SSN, FN_GENDER(SSN)"함수호출결과"
FROM TBL_INSA;
--==>>
/*
홍길동	771212-1022432	남자
이순신	801007-1544236	남자
이순애	770922-2312547	여자
김정훈	790304-1788896	남자
한석봉	811112-1566789	남자
이기자	780505-2978541	여자
장인철	780506-1625148	남자
김영년	821011-2362514	여자
나윤균	810810-1552147	남자
김종서	751010-1122233	남자
유관순	801010-2987897	여자
정한국	760909-1333333	남자
조미숙	790102-2777777	여자
황진이	810707-2574812	여자
이현숙	800606-2954687	여자
이상헌	781010-1666678	남자
엄용수	820507-1452365	남자
이성길	801028-1849534	남자
박문수	780710-1985632	남자
유영희	800304-2741258	여자
홍길남	801010-1111111	남자
이영숙	800501-2312456	여자
김인수	731211-1214576	남자
김말자	830225-2633334	여자
우재옥	801103-1654442	남자
김숙남	810907-2015457	여자
김영길	801216-1898752	남자
이남신	810101-1010101	남자
김말숙	800301-2020202	여자
정정해	790210-2101010	여자
지재환	771115-1687988	남자
심심해	810206-2222222	여자
김미나	780505-2999999	여자
이정석	820505-1325468	남자
정영희	831010-2153252	여자
이재영	701126-2852147	여자
최석규	770129-1456987	남자
손인수	791009-2321456	여자
고순정	800504-2000032	여자
박세열	790509-1635214	남자
문길수	721217-1951357	남자
채정희	810709-2000054	여자
양미옥	830504-2471523	여자
지수환	820305-1475286	남자
홍원신	690906-1985214	남자
허경운	760105-1458752	남자
산마루	780505-1234567	남자
이기상	790604-1415141	남자
이미성	830908-2456548	여자
이미인	810403-2828287	여자
권영미	790303-2155554	여자
권옥경	820406-2000456	여자
김싱식	800715-1313131	남자
정상호	810705-1212141	남자
정한나	820506-2425153	여자
전용재	800605-1456987	남자
이미경	780406-2003214	여자
김신제	800709-1321456	남자
임수봉	810809-2121244	여자
김신애	810809-2111111	여자
*/


--○ 생성한 함수(FN_POW())가 제대로 작동하는지의 여부 확인
SELECT FN_POW(10, 3)
FROM DUAL;
--==>> 1000

SELECT FN_POW(2, 24)
FROM DUAL;
--==>> 16777216

SELECT FN_POW(2, 8)
FROM DUAL;
--==>> 256

SELECT FN_POW(3, 3)
FROM DUAL;
--==>> 27





=== 20190409_04_scott(plsql) ===

SELECT USER
FROM DUAL;
--==>> SCOTT

--------------------------------------------------------------------------------------------------------------------------------

--※ 참고

-- 1. INSERT, UPDATE, DELETE, (MERGE)
--==>> DML(Data, Manipulation Language)
-- COMMIT / ROLLBACK 이 필요하다.

-- 2. CREATE, DROP, ALTER, (TRUNCATE)
--==>> DDL(Data Definition Language)
-- 실행하면 자동으로 COMMIT 된다.

-- 3. GRANT, REVOKE
--==>> DCL(Data Control Language)
-- 실행하면 자동으로 COMMIT 된다.

-- 4. COMMIT, ROLLBACK
--==>> TCL(Transaction Control Language)

-- 정적 PL/SQL문 → DML문, TCL문만 사용 가능하다.
-- 동적 PL/SQL문 → DML문 DDL문, DCL문, TCL문 사용 가능하다.

--------------------------------------------------------------------------------------------------------------------------------

--■■■ PROCECURE(프로시저) ■■■--

-- 1. PL/SQL 에서 가장 대표적인 구조인 스토어드 프로시저는
--    개발자가 자꾸 작성해야 하는 업무의 흐름을
--    미리 작성하여 데이터베이스 내에 저장해 두었다가
--    필요할 때 마다 호출하여 실행할 수 있도록 처리해 주는 구문이다.

-- 2. 형식 및 구조
/*
CREATE [OR REPLACE] PROCEDURE 프로시저 명
[(
     매개변수 IN 데이터타입
   , 매개변수 OUT 데이터타입
   , 매개변수 INOUT 데이터타입
)]
IS
    [-- 주요 변수 선언;]
BEGIN 
    -- 실행 구문
    ...
    [EXCEPTOPM
        -- 예외 처리 구문;]
END;
*/

--※ FUNCTION 과 비교했을 때
--   『RETURN 반환자료형』 부분이 존재하지 않으며
--   『RETURN』문 자체도 존재하지 않으며,
--   프로시저 실행시 넘겨주게 되는 매개변수의 종류는
--   IN, OUT, INOUT 으로 구분된다.

-- 3. 실행(호출)
/*
EXEC[UTE] 프로시저명[(인수1, 인수2, ...)];
*/


--○ INSERT 쿼리 실행을 프로시저로 작성 (INSERT 프로시저)

-- 실습 테이블 생성(TBL_STUDENTS)
CREATE TABLE TBL_STUDENTS
( ID    VARCHAR2(10)
, NAME  VARCHAR2(40)
, TEL   VARCHAR2(20)
, ADDR  VARCHAR2(100)
);
--==>> Table TBL_STUDENTS이(가) 생성되었습니다.

-- 실습 테이블 생성(TBL_IDPW)
CREATE TABLE TBL_IDPW
( ID    VARCHAR2(10)
, PW    VARCHAR2(20)
, CONSTRAINT IDPW_ID_PK PRIMARY KEY(ID)
);
--==>> Table TBL_IDPW이(가) 생성되었습니다.


-- 두 테이블에 데이터 입력
INSERT INTO TBL_STUDENTS(ID, NAME, TEL, ADDR)
VALUES('superman', '전춘희', '010-1111-1111', '제주도 서귀포시');
INSERT INTO TBL_IDPW(ID, PW)
VALUES('superman', 'java006$');
--==>> 1 행 이(가) 삽입되었습니다. * 2

SELECT *
FROM TBL_STUDENTS;
--==>> superman	전춘희	010-1111-1111	제주도 서귀포시

SELECT *
FROM TBL_IDPW;
--==>> superman	java006$

-- 위의 업무를 프로시저(INSERT 프로시저, 입력 프로시저)를 생성하게 되면
EXEC PRC_STUDENTS_INSERT('batman', 'java006$', '남상현', '010-2222-2222', '서울');
-- 이와 같은 구문 한 줄로 양쪽 테이블에 데이터를 모두 제대로 입력할 수 있다.

-- 프로시저 생성(작성)
CREATE OR REPLACE PROCEDURE PRC_STUDENTS_INSERT
( V_ID      IN TBL_IDPW.ID%TYPE
, V_PW      IN TBL_IDPW.PW%TYPE
, V_NAME    IN TBL_STUDENTS.NAME%TYPE
, V_TEL     IN TBL_STUDENTS.TEL%TYPE
, V_ADDR    IN TBL_STUDENTS.ADDR%TYPE
)
IS
BEGIN
    -- TBL_IDPW 테이블에 데이터 입력
    INSERT INTO TBL_IDPW(ID, PW)
    VALUES(V_ID, V_PW);
    
    -- TBL_STUDENTS 테이블에 데이터 입력
    INSERT INTO TBL_STUDENTS(ID, NAME, TEL, ADDR)
    VALUES(V_ID, V_NAME, V_TEL, V_ADDR);
    
    -- 커밋
    COMMIT;
END;
--==>> Procedure PRC_STUDENTS_INSERT이(가) 컴파일되었습니다.


--○ 데이터 입력 시 특정 항목의 데이터(학번, 이름, 국어점수, 영어점수, 수학점수)만 입력하면
--   내부적으로 총점, 평균, 등급 항목이 함께 입력 처리될 수 있도록 하는 프로시저를 생성한다.
--   프로시저 명 : PRC_SUNGJUK_INSERT()
/*
실행 예)
EXEC PRC_SUNGJUK_INSERT(1, '이원영', 90, 80, 70);

프로시저 호출로 처리된 결과)
학번  이름  국어점수    영어점수    수학점수    총점  평균  등급
1    이원영    90          80          70       240    80    B
*/

CREATE OR REPLACE PROCEDURE PRC_SUNGJUK_INSERT
( V_HAKBUN  IN TBL_SUNGJUK.HAKBUN%TYPE
, V_NAME    IN TBL_SUNGJUK.NAME%TYPE
, V_KOR     IN TBL_SUNGJUK.KOR%TYPE
, V_ENG     IN TBL_SUNGJUK.ENG%TYPE          
, V_MAT     IN TBL_SUNGJUK.MAT%TYPE
)
IS
    -- INSERT 쿼리문을 수행하는데 필요한 주요 변수 선언
    V_TOT   TBL_SUNGJUK.TOT%TYPE;
    V_AVG   TBL_SUNGJUK.AVG%TYPE;
    V_GRADE TBL_SUNGJUK.GRADE%TYPE;
BEGIN
    -- 아래의 쿼리문 실행을 위해서는
    -- 선언한 변수들에 값을 담아내야 한다.
    V_TOT := V_KOR + V_ENG + V_MAT;
    
    V_AVG := V_TOT / 3;
    
    IF V_AVG>=90
        THEN V_GRADE := 'A';
    ELSIF V_AVG>=80
        THEN V_GRADE := 'B';
    ELSIF V_AVG>=70
        THEN V_GRADE := 'C';
    ELSIF V_AVG>=60
        THEN V_GRADE := 'D';
    ELSE
        V_GRADE := 'F';
    END IF; 
    
    -- INSERT 쿼리문 실행
    INSERT INTO TBL_SUNGJUK(HAKBUN, NAME, KOR, ENG, MAT, TOT, AVG, GRADE)
    VALUES(V_HAKBUN, V_NAME, V_KOR, V_ENG, V_MAT, V_TOT, V_AVG, V_GRADE);
    
    -- 커밋
    COMMIT;
END;


--○ TBL_SUNGJUK 테이블에서 특정 학생의 점수(학번, 국어점수, 영어점수, 수학점수)
--   데이터 수정 시 총점, 평균, 등급까지 수정하는 프로시저를 작성한다.
--   프로시저 명 : PRC_SUNGJUK_UPDATE()
/*
실행 예)
EXEC PRC_SUNGJUK_UPDATE(1, 50, 50, 50);
프로시저 호출로 처리된 결과)
학번  이름  국어점수    영어점수    수학점수    총점  평균  등급
1    이원영    50          50          50       150    50    F
*/

CREATE OR REPLACE PROCEDURE PRC_SUNGJUK_UPDATE
( V_HAKBUN  IN TBL_SUNGJUK.HAKBUN%TYPE
, V_KOR     IN TBL_SUNGJUK.KOR%TYPE
, V_ENG     IN TBL_SUNGJUK.ENG%TYPE          
, V_MAT     IN TBL_SUNGJUK.MAT%TYPE
)
IS
    -- UPDATE 쿼리문을 수행하는데 필요한 주요 변수 선언
    V_TOT   TBL_SUNGJUK.TOT%TYPE;
    V_AVG   TBL_SUNGJUK.AVG%TYPE;
    V_GRADE TBL_SUNGJUK.GRADE%TYPE;
BEGIN
    -- 아래의 쿼리문 실행을 위해서는
    -- 선언한 변수들에 값을 담아내야 한다.
    V_TOT := V_KOR + V_ENG + V_MAT;
    
    V_AVG := V_TOT / 3;
    
    IF V_AVG>=90
        THEN V_GRADE := 'A';
    ELSIF V_AVG>=80
        THEN V_GRADE := 'B';
    ELSIF V_AVG>=70
        THEN V_GRADE := 'C';
    ELSIF V_AVG>=60
        THEN V_GRADE := 'D';
    ELSE
        V_GRADE := 'F';
    END IF; 
    
    -- UPDATE 쿼리문 실행
    UPDATE TBL_SUNGJUK
    SET KOR = V_KOR, ENG = V_ENG, MAT = V_MAT, TOT = V_TOT, AVG = V_AVG, GRADE = V_GRADE
    WHERE HAKBUN = V_HAKBUN;
    
    -- 커밋
    COMMIT;
END;
--==>> Procedure PRC_SUNGJUK_INSERT이(가) 컴파일되었습니다.


--○ TBL_STUDENTS 테이블에서 
--   전화번호와 주소 데이터를 수정하는(변경하는) 프로시저를 작성한다.
--   단, ID 와 PW 가 일치하는 경우에만 수정을 진핼할 수 있도록 한다.
--   프로시저 명 : PRC_STUDENTS_UPDATE()
/*
실행 예)
EXEC PRC_STUDENTS_UPDATE('superman', 'java006$', '010-9999-9999', '경기');

프로시저 호출로 처리된 결과
superman	전훈의	010-9999-9999	경기
*/

CREATE OR REPLACE PROCEDURE PRC_STUDENTS_UPDATE
( V_ID      IN TBL_IDPW.ID%TYPE
, V_PW      IN TBL_IDPW.PW%TYPE
, V_TEL     IN TBL_STUDENTS.TEL%TYPE
, V_ADDR    IN TBL_STUDENTS.ADDR%TYPE
)
IS
BEGIN
    -- UPDATE 쿼리문 실행
    UPDATE TBL_STUDENTS
    SET TEL = V_TEL, ADDR = V_ADDR
    WHERE V_ID = ID AND V_PW = (SELECT PW FROM TBL_IDPW WHERE ID = V_ID);
    
    -- 커밋
    COMMIT;
END;
--==>> Procedure PRC_SUNGJUK_INSERT이(가) 컴파일되었습니다.


CREATE OR REPLACE PROCEDURE PRC_STUDENTS_UPDATE
( V_ID      IN TBL_IDPW.ID%TYPE
, V_PW      IN TBL_IDPW.PW%TYPE
, V_TEL     IN TBL_STUDENTS.TEL%TYPE
, V_ADDR    IN TBL_STUDENTS.ADDR%TYPE
)
IS
BEGIN
    -- UPDATE 쿼리문 실행
    UPDATE (SELECT I.ID, I.PW, S.TEL, S.ADDR
        FROM TBL_IDPW I JOIN TBL_STUDENTS S
        ON I.ID = S.ID) T
    SET T.TEL=V_TEL, T.ADDR = V_ADDR
    WHERE T.ID = V_ID AND T.PW = V_PW;
    -- 커밋
    COMMIT;
END;
--==>> Procedure PRC_SUNGJUK_INSERT이(가) 컴파일되었습니다.


--○ TBL_INSA 테이블을 대상으로 신규 데이터 입력 프로시저를 작성한다.
--   NUM, NAME, SSN, IBSADATE, CITY, TEL, BUSEO, JIKWI, BASICPAY, SUDANG
--   구조를 갖고 있는 대상 테이블에 데이터 입력 시
--   NUM 컬럼(사원번호)의 값은
--   기존 부여된 사원번호 마지막 번호의 그 다음 번호를 자동으로
--   입력 처리할 수 있는 프로시저로 구성한다.
--   프로시저 명 : PRC_INSA_INSERT(NAME, SSN, IBSADATE, CITY, TEL, BUSEO, JIKWI, BASICPAY, SUDANG
/*
실행 예)
EXEC PRC_INSA_INSERT('김선아','901212-2234567',SYSDATE,'서울','010-5555-5555','영업부','대리',1000000,200000);

프로시저 호출로 처리된 결과)
1061 김선아 901212-2234567 SYSDATE 서울 010-5555-5555 영업부 대리 1000000,200000
*/
CREATE OR REPLACE PROCEDURE PRC_INSA_INSERT
( V_NAME        IN TBL_INSA.NAME%TYPE
, V_SSN         IN TBL_INSA.SSN%TYPE
, V_IBSADATE    IN TBL_INSA.IBSADATE%TYPE    
, V_CITY        IN TBL_INSA.CITY%TYPE
, V_TEL         IN TBL_INSA.TEL%TYPE
, V_BUSEO       IN TBL_INSA.BUSEO%TYPE
, V_JIKWI       IN TBL_INSA.JIKWI%TYPE
, V_BASICPAY    IN TBL_INSA.BASICPAY%TYPE
, V_SUDANG      IN TBL_INSA.SUDANG%TYPE
)
IS 
    V_NUM   NUMBER;
BEGIN
    SELECT MAX(NUM) INTO V_NUM FROM TBL_INSA;
    
    INSERT INTO TBL_INSA(NUM, NAME, SSN, IBSADATE, CITY, TEL, BUSEO, JIKWI, BASICPAY, SUDANG)
    VALUES(V_NUM+1, V_NAME, V_SSN, V_IBSADATE, V_CITY, V_TEL, V_BUSEO, V_JIKWI, V_BASICPAY, V_SUDANG);
    
    COMMIT;
END;
--==>> Procedure PRC_INSA_INSERT이(가) 컴파일되었습니다.





=== 20190409_05_scott.sql ===

SELECT USER
FROM DUAL;
--==>> SCOTT

--○ 생성한 프로시저(PRC_STUDENTS_INSERT())가 제대로 작동하는지의
--   여부 확인 → 프로시저 호출
EXEC PRC_STUDENTS_INSERT('batman', 'java006$', '남상현', '010-2222-2222', '서울');
--==>> PL/SQL 프로시저가 성공적으로 완료되었습니다.

SELECT *
FROM TBL_IDPW;
--==>>
/*
superman	java006$
batman	    java006$
*/

SELECT *
FROM TBL_STUDENTS;
--==>>
/*
superman	전춘희	010-1111-1111	제주도 서귀포시
batman	    남상현	010-2222-2222	서울
*/


--○ 학번, 이름, 국어점수, 영어점수, 수학점수 데이터를
--   입력받을 수 있는 실습 테이블 생성(TBL_SUNGJUK)
CREATE TABLE TBL_SUNGJUK
( HAKBUN    NUMBER
, NAME      VARCHAR2(40)
, KOR       NUMBER(3)
, ENG       NUMBER(3)
, MAT       NUMBER(3)
, CONSTRAINT SUNGJUK_HAKBUN_PK PRIMARY KEY(HAKBUN)
);
--==>> Table TBL_SUNGJUK이(가) 생성되었습니다.

--○ 생성된 테이블에 컬럼 구조 추가
--   (총점→TOT, 평균→AVG, 등급→GRADE)
ALTER TABLE TBL_SUNGJUK
ADD ( TOT NUMBER(3), AVG NUMBER(4,1), GRADE CHAR );
--==>> Table TBL_SUNGJUK이(가) 변경되었습니다.

--※ 여기서 추가한 컬럼에 대한 항목들은
--   프로시저 실습을 위해 추가한 것일 뿐
--   실제 테이블 구조에 적합하지도, 바람직하지도 않은 내용이다.


--○ 변경된 테이블 구조 호가인
DESC TBL_SUNGJUK;
--==>>
/*

이름     널?       유형           
------ -------- ------------ 
HAKBUN NOT NULL NUMBER       
NAME            VARCHAR2(40) 
KOR             NUMBER(3)    
ENG             NUMBER(3)    
MAT             NUMBER(3)    
TOT             NUMBER(3)    
AVG             NUMBER(4,1)     -- 정수 3자리 소수 1자리
GRADE           CHAR(1)      
*/

--○ 데이터 입력 시 특정 항목의 데이터(학번, 이름, 국어점수, 영어점수, 수학점수)만 입력하면
--   내부적으로 총점, 평균, 등급 항목이 함께 입력 처리될 수 있도록 하는 프로시저를 생성한다.
--   프로시저 명 : PRC_SUNGJUK_INSERT()
/*
실행 예)
EXEC PRC_SUNGJUK_INSERT(1, '이원영', 90, 80, 70);

프로시저 호출로 처리된 결과)
학번  이름  국어점수    영어점수    수학점수    총점  평균  등급
1    이원영    90          80          70       240    80    B
*/
--○ 생성한 프로시저(PRC_STUDENTS_INSERT())가 제대로 작동하는지의
--   여부 확인 → 프로시저 호출
EXEC PRC_SUNGJUK_INSERT(1, '이원영', 90, 80, 70);
--==>> PL/SQL 프로시저가 성공적으로 완료되었습니다.

SELECT *
FROM TBL_SUNGJUK;
--==>> 1	이원영	90	80	70	240	80	B


--○ TBL_SUNGJUK 테이블에서 특정 학생의 점수(학번, 국어점수, 영어점수, 수학점수)
--   데이터 수정 시 총점, 평균, 등급까지 수정하는 프로시저를 작성한다.
--   프로시저 명 : PRC_SUNGJUK_UPDATE()
/*
실행 예)
EXEC PRC_SUNGJUK_UPDATE(1, 50, 50, 50);
프로시저 호출로 처리된 결과)
학번  이름  국어점수    영어점수    수학점수    총점  평균  등급
1    이원영    50          50          50       150    50    F
*/
--○ 생성한 프로시저(PRC_STUDENTS_INSERT())가 제대로 작동하는지의
--   여부 확인 → 프로시저 호출
EXEC PRC_SUNGJUK_UPDATE(1, 50, 50, 50);
--==>> PL/SQL 프로시저가 성공적으로 완료되었습니다.

SELECT *
FROM TBL_SUNGJUK;
--==>> 1	이원영	50	50	50	150	50	F


--○ TBL_STUDENTS 테이블에서 
--   전화번호와 주소 데이터를 수정하는(변경하는) 프로시저를 작성한다.
--   단, ID 와 PW 가 일치하는 경우에만 수정을 진핼할 수 있도록 한다.
--   프로시저 명 : PRC_STUDENTS_UPDATE()
/*
실행 예)
EXEC PRC_STUDENTS_UPDATE('superman', 'java006$', '010-9999-9999', '경기');

프로시저 호출로 처리된 결과
superman	전훈의	010-9999-9999	경기
*/
--○ 생성한 프로시저(PRC_STUDENTS_INSERT())가 제대로 작동하는지의
--   여부 확인 → 프로시저 호출
EXEC PRC_STUDENTS_UPDATE('supermen', 'java006$', '010-9999-9999', '경기');
--==>> PL/SQL 프로시저가 성공적으로 완료되었습니다.
--> ID가 다르므로 내용이 변경되지 않는다.

EXEC PRC_STUDENTS_UPDATE('supermen', 'net006$', '010-9999-9999', '경기');
--==>> PL/SQL 프로시저가 성공적으로 완료되었습니다.
--> PW가 다르므로 내용이 변경되지 않는다.

EXEC PRC_STUDENTS_UPDATE('superman', 'java006$', '010-9999-9999', '경기');
--==>> PL/SQL 프로시저가 성공적으로 완료되었습니다.
--> ID 와 PW 가 모두 유효한 데이터로 테스트한 결과 데이터 변경 선공

SELECT *
FROM TBL_STUDENTS;
--==>>
/*
superman	전훈의	010-9999-9999	경기
batman	    남상현	010-2222-2222	서울
*/


--○ TBL_INSA 테이블을 대상으로 신규 데이터 입력 프로시저를 작성한다.
--   NUM, NAME, SSN, IBSADATE, CITY, TEL, BUSEO, JIKWI, BASICPAY, SUDANG
--   구조를 갖고 있는 대상 테이블에 데이터 입력 시
--   NUM 컬럼(사원번호)의 값은
--   기존 부여된 사원번호 마지막 번호의 그 다음 번호를 자동으로
--   입력 처리할 수 있는 프로시저로 구성한다.
--   프로시저 명 : PRC_INSA_INSERT(NAME, SSN, IBSADATE, CITY, TEL, BUSEO, JIKWI, BASICPAY, SUDANG
/*
실행 예)
EXEC PRC_INSA_INSERT('김선아','901212-2234567',SYSDATE,'서울','010-5555-5555','영업부','대리',1000000,200000);

프로시저 호출로 처리된 결과)
1061 김선아 901212-2234567 SYSDATE 서울 010-5555-5555 영업부 대리 1000000,200000
*/
--○ 생성한 프로시저(PRC_STUDENTS_INSERT())가 제대로 작동하는지의
--   여부 확인 → 프로시저 호출
EXEC PRC_INSA_INSERT('김선아','901212-2234567',SYSDATE,'서울','010-5555-5555','영업부','대리',1000000,200000);
--==>> PL/SQL 프로시저가 성공적으로 완료되었습니다.

SELECT *
FROM TBL_INSA;
/*
                                                :
                                                :
1056	전용재	800605-1456987	04/08/13	인천	010-7549-8654	영업부	대리	1950000	200000
1057	이미경	780406-2003214	98/02/11	경기	016-6542-7546	자재부	부장	2520000	160000
1058	김신제	800709-1321456	03/08/08	인천	010-2415-5444	기획부	대리	1950000	180000
1059	임수봉	810809-2121244	01/10/10	서울	011-4151-4154	개발부	사원	890000	102000
1060	김신애	810809-2111111	01/10/10	서울	011-4151-4444	개발부	사원	900000	102000
1061	김선아	901212-2234567	19/04/09	서울	010-5555-5555	영업부	대리	1000000	200000
*/





=== 20190410_01_scott(plsql).sql ===

SELECT USER
FROM DUAL;
--==>> SCOTT


--○ TBL_INSA 테이블을 대상으로 신규 데이터 입력 프로시저를 작성한다.
--   NUM, NAME, SSN, IBSADATE, CITY, TEL, BUSEO, JIKWI, BASICPAY, SUDANG
--   구조를 갖고 있는 대상 테이블에 데이터 입력 시
--   NUM 컬럼(사원번호)의 값은
--   기존 부여된 사원번호 마지막 번호의 그 다음 번호를 자동으로
--   입력 처리할 수 있는 프로시저로 구성한다.
--   프로시저 명 : PRC_INSA_INSERT(NAME, SSN, IBSADATE, CITY, TEL, BUSEO, JIKWI, BASICPAY, SUDANG
/*
실행 예)
EXEC PRC_INSA_INSERT('김선아','901212-2234567',SYSDATE,'서울','010-5555-5555','영업부','대리',1000000,200000);

프로시저 호출로 처리된 결과)
1061 김선아 901212-2234567 SYSDATE 서울 010-5555-5555 영업부 대리 1000000,200000
*/
CREATE OR REPLACE PROCEDURE PRC_INSA_INSERT
( V_NAME        IN TBL_INSA.NAME%TYPE
, V_SSN         IN TBL_INSA.SSN%TYPE
, V_IBSADATE    IN TBL_INSA.IBSADATE%TYPE    
, V_CITY        IN TBL_INSA.CITY%TYPE
, V_TEL         IN TBL_INSA.TEL%TYPE
, V_BUSEO       IN TBL_INSA.BUSEO%TYPE
, V_JIKWI       IN TBL_INSA.JIKWI%TYPE
, V_BASICPAY    IN TBL_INSA.BASICPAY%TYPE
, V_SUDANG      IN TBL_INSA.SUDANG%TYPE
)
IS 
    -- INSERT 쿼리문 수행에 필요한 변수 추가 선언
    V_NUM   NUMBER;
BEGIN
    -- 선언한 변수에 값 담아내기
    SELECT MAX(NUM)+1 INTO V_NUM FROM TBL_INSA;
    
    -- INSERT 쿼리문 구성
    INSERT INTO TBL_INSA(NUM, NAME, SSN, IBSADATE, CITY, TEL, BUSEO, JIKWI, BASICPAY, SUDANG)
    VALUES(V_NUM, V_NAME, V_SSN, V_IBSADATE, V_CITY, V_TEL, V_BUSEO, V_JIKWI, V_BASICPAY, V_SUDANG);
    
    -- 커밋
    COMMIT;
END;
--==>> Procedure PRC_INSA_INSERT이(가) 컴파일되었습니다.


--○ TBL_상품, TBL_입고 테이블을 대상으로 
--   TBL_입고 테이블에 데이터 입력 시(즉, 입고 이벤트 발생 시)
--   TBL_상품 테이블의 재고수량이 함께 변동될 수 있는 기능을 가진
--   프로시저를 작성한다.
--   단, 이 과정에서 입고번호는 자동 증가 처리한다. (시퀀스 사용 X)
--   TBL_입고 테이블 구성 컬럼
--   → 입고번호, 상품코드, 입고일자, 입고수량, 입고단가
--   프로시저 명 : PRC_입고_INSERT(상품코드, 입고수량,  입고단가)

--※ TBL_입고 테이블에 입고 이벤트 발생 시
--   관련 테이블에서 수행되어야 하는 내용
--   ① INSERT → TBL_입고
--      INSERT INTO TBL_입고(입고번호, 상품코드, 입고일자, 입고수량, 입고단가)
--      VALUES(1, 'HOO1', SYSDATE, 20, 900);
--   ② UPDATE → TBL_상품
--      UPDATE TBL_상품
--      SET 재고수량 = 기존재고수량 + 20(←입고수량)
--      WHERE 상품코드 = 'H001';

CREATE OR REPLACE PROCEDURE PRC_입고_INSERT
( V_상품코드    IN TBL_상품.상품코드%TYPE
, V_입고수량    IN TBL_입고.입고수량%TYPE
, V_입고단가    IN TBL_입고.입고단가%TYPE
)
IS
    V_입고번호  NUMBER;
BEGIN
    SELECT MAX(입고번호) INTO V_입고번호 FROM TBL_입고;
    
    IF V_입고번호 IS NULL
        THEN V_입고번호 := 0;
    END IF;
    
    INSERT INTO TBL_입고(입고번호, 상품코드, 입고수량, 입고단가) VALUES(V_입고번호+1, V_상품코드, V_입고수량, V_입고단가);
    
    UPDATE TBL_상품
    SET 재고수량 = 재고수량 + V_입고수량
    WHERE 상품코드 = V_상품코드;
    
    -- 커밋
    COMMIT;
    
    -- 예외 처리
    EXCEPTION 
        WHEN OTHERS THEN ROLLBACK;
END;
--==>> Procedure PRC_입고_INSERT이(가) 컴파일되었습니다.

-- 풀이
CREATE OR REPLACE PROCEDURE PRC_입고_INSERT
( V_상품코드    IN TBL_상품.상품코드%TYPE
, V_입고수량    IN TBL_입고.입고수량%TYPE
, V_입고단가    IN TBL_입고.입고단가%TYPE
)
IS
    -- 아래의 쿼리문을 수행하기 위해 필요한 데이터 변수로 선언
    V_입고번호  TBL_입고.입고번호%TYPE;
BEGIN
    -- 선언한 변수에 값 담아내기
    SELECT NVL(MAX(입고번호), 0) INTO V_입고번호
    FROM TBL_입고;
    
    -- 쿼리문 구성
    -- ① INSERT → TBL_입고
    INSERT INTO TBL_입고(입고번호, 상품코드, 입고수량, 입고단가) 
    VALUES((V_입고번호+1), V_상품코드, V_입고수량, V_입고단가);
    
    -- ② UPDATE → TBL_상품
    UPDATE TBL_상품
    SET 재고수량 = 재고수량 + V_입고수량
    WHERE 상품코드 = V_상품코드;
    
    -- 커밋
    COMMIT;
    
    -- 예외 처리
    EXCEPTION 
        WHEN OTHERS THEN ROLLBACK;
END;
--==>> Procedure PRC_입고_INSERT이(가) 컴파일되었습니다.


--■■■ 프로시저 내에서의 예외 처리 ■■■--

--○ TBL_MEMBER 테이블에 데이터를 입력하는 프로시저를 생성
--   단, 이 프로시저를 통해 데이터를 입력할 경우
--   CITY(지역) 항목에 '서울', '인천', '경기' 만 입력이 가능하도록 구성한다.
--   이 지역 외의 지역을 프로시저 호출을 통해 입력하려고 하는 경우
--   예외 처리를 하려고 한다.
--   프로시저 명 : PRC_MEMBER_INSERT(이름, 전화번호, 지역)

-- 프로시저 생성
CREATE OR REPLACE PROCEDURE PRC_MEMBER_INSERT
( V_NAME    IN TBL_MEMBER.NAME%TYPE
, V_TEL     IN TBL_MEMBER.TEL%TYPE
, V_CITY    IN TBL_MEMBER.CITY%TYPE
)
IS
    -- 실행 영역의 쿼리문 수행을 위해 필요한 데이터 변수 선언
    V_NUM   TBL_MEMBER.NUM%TYPE;
    
    -- 사용자 정의 예외에 대한 변수 선언 CHECK!!
    USER_DEFINE_ERROR EXCEPTION;
BEGIN
    
    -- 프로시저를 통해 입력 처리를 정상적으로 진행해야 할 데이터인지
    -- 아닌지의 여부를 가장 먼저 확인할 수 있도록 코드 구성
    IF (V_CITY NOT IN ('서울','인천','경기'))
        -- 예외 발생!! CHECK!!!
        THEN RAISE USER_DEFINE_ERROR;
    END IF;

    -- 선언한 변수에 값 담아내기
    SELECT NVL(MAX(NUM), 0) INTO V_NUM
    FROM TBL_MEMBER;
    
    -- 쿼리문 구성(INSERT)
    INSERT INTO TBL_MEMBER(NUM, NAME, TEL, CITY)
    VALUES((V_NUM+1), V_NAME, V_TEL, V_CITY);
    
    -- 커밋
    COMMIT;
    
    -- 예외 처리 구문
    EXCEPTION 
        WHEN USER_DEFINE_ERROR
            THEN RAISE_APPLICATION_ERROR(-20001, '서울, 인천, 경기만 입력 가능합니다.');     -- 마이너스가 아니라 하이푼개념
                ROLLBACK;
        WHEN OTHERS
            THEN ROLLBACK;
END;
--==>> Procedure PRC_MEMBER_INSERT이(가) 컴파일되었습니다.


--○ TBL_출고 테이블에 데이터 입력 시(즉, 출고 이벤트 발생 시)
--   TBL_상품 테이블의 재고수량이 변동되는 프로시저를 작성한다.
--   단, 출고번호는 입고번호와 마찬가지로 자동 증가.
--   또한, 출고 수량이 재고 수량보다 많은 경우
--   출고 액션을 취소할 수 있도록 처리한다. (출고가 이루어지지 않도록)
--   프로시저 명 : PRC_출고_INSERT(상품코드, 출고수량, 출고단가);
CREATE OR REPLACE PROCEDURE PRC_출고_INSERT
( V_상품코드    IN TBL_상품.상품코드%TYPE
, V_출고수량    IN TBL_출고.출고수량%TYPE
, V_출고단가    IN TBL_출고.출고단가%TYPE
)
IS
    -- 주요 변수 선언
    V_출고번호  TBL_출고.출고번호%TYPE;
    V_재고수량  TBL_상품.재고수량%TYPE;
    
    -- 사용자 정의 예외에 대한 변수 선언 CHECK!!
    USER_DEFINE_ERROR EXCEPTION;
BEGIN

    -- 쿼리문 수행 이전에 수행 여부 확인 → 기존 재고 확인 → 출고수량과 비교
    SELECT 재고수량 INTO V_재고수량
    FROM TBL_상품
    WHERE 상품코드 = V_상품코드;
    
    -- 출고를 정상적으로 진행해 줄 것인지에 대한 여부 확인
    -- (파악한 재고수량보다 출고수량이 많으면 예외발생)
    IF V_재고수량<V_출고수량
        THEN RAISE USER_DEFINE_ERROR;
    END IF;

    -- 선언한 변수에 값 담아내기
    SELECT NVL(MAX(출고번호), 0) INTO V_출고번호
    FROM TBL_출고;
    
    -- 쿼리문 구성
    -- ① INSERT → TBL_출고
    INSERT INTO TBL_출고(출고번호, 상품코드, 출고수량, 출고단가) 
    VALUES((V_출고번호+1), V_상품코드, V_출고수량, V_출고단가);
    
    -- ② UPDATE → TBL_상품
    UPDATE TBL_상품
    SET 재고수량 = 재고수량 - V_출고수량
    WHERE 상품코드 = V_상품코드;
    
    -- 커밋
    COMMIT;
    
    -- 예외 처리
    EXCEPTION 
        WHEN USER_DEFINE_ERROR
            THEN RAISE_APPLICATION_ERROR(-20002, '재고수량이 부족합니다.');     -- 마이너스가 아니라 하이푼개념
                 ROLLBACK;
        WHEN OTHERS
            THEN ROLLBACK;
END;
--==>> Procedure PRC_출고_INSERT이(가) 컴파일되었습니다.


--○ TBL_출고 테이블에서 출고 수량을 수정(변경)하는 프로시저를 작성한다.
--   프로시저 명 : PRC_출고_UPDATE(출고번호, 변경할 수량);
CREATE OR REPLACE PROCEDURE PRC_출고_UPDATE
( V_출고번호    IN TBL_출고.출고번호%TYPE
, V_변경수량    IN TBL_출고.출고수량%TYPE
)
IS
    V_재고수량      TBL_상품.재고수량%TYPE;
    V_출고수량      TBL_출고.출고수량%TYPE;
    V_상품코드      TBL_상품.상품코드%TYPE;
    
    -- 사용자 정의 예외에 대한 변수 선언 CHECK!!
    USER_DEFINE_ERROR EXCEPTION;
BEGIN
    
    -- 쿼리문 수행 이전에 수행 여부 확인 → 기존 재고 확인 → 출고수량과 비교
    SELECT 상품코드 INTO V_상품코드 FROM TBL_출고 WHERE 출고번호 = V_출고번호;
    SELECT 재고수량 INTO V_재고수량 FROM TBL_상품 WHERE 상품코드 = V_상품코드;
    SELECT 출고수량 INTO V_출고수량 FROM TBL_출고 WHERE 상품코드 = V_상품코드;
    
    IF V_변경수량>(V_재고수량+V_출고수량)
        THEN RAISE USER_DEFINE_ERROR; 
    END IF;
    
    -- 쿼리문 구성
    -- ① UPDATE → TBL_출고
    UPDATE TBL_출고
    SET 출고수량 = V_변경수량
    WHERE 출고번호 = V_출고번호;
    
    -- ② UPDATE → TBL_상품
    UPDATE TBL_상품
    SET 재고수량 = V_변경수량 - V_출고수량 - 재고수량
    WHERE 상품코드 = V_상품코드;
    
    -- 커밋
    COMMIT;
    
    -- 예외 처리
    EXCEPTION 
        WHEN USER_DEFINE_ERROR
            THEN RAISE_APPLICATION_ERROR(-20003, '재고수량이 부족합니다.');     -- 마이너스가 아니라 하이푼개념
                 ROLLBACK;
        WHEN OTHERS
            THEN ROLLBACK;
END;
--==>> Procedure PRC_출고_UPDATE이(가) 컴파일되었습니다.

-- 풀이
CREATE OR REPLACE PROCEDURE PRC_출고_UPDATE
( 
  --① 매개변수 구성
  V_출고번호   IN TBL_출고.출고번호%TYPE
, V_출고수량   IN TBL_출고.출고수량%TYPE
)
IS
    --③ 주요 변수 추가 선언
    V_상품코드      TBL_상품.상품코드%TYPE;
    
    --⑤ 주요 변수 추가 선언
    V_이전출고수량  TBL_출고.출고수량%TYPE;
    
    --⑦ 주요 변수 추가 선언
    V_재고수량      TBL_상품.재고수량%TYPE;
    
    --⑨ 주요 변수(사용자 정의 예외) 추가 선언
    USER_DEFINE_ERROR EXCEPTION;
BEGIN
    
    --④ 상품코드와 이전출고수량 파악을 위해 변경 이전의 출고 내역 확인
    SELECT 상품코드, 출고수량 INTO V_상품코드, V_이전출고수량
    FROM TBL_출고 
    WHERE 출고번호 = V_출고번호;
    
    --⑥ 출고를 정상적으로 수행해야 하는지의 여부 판단 필요
    --   변경 이전 출고수량 및 현재의 재고수량 확인
    SELECT 재고수량 INTO V_재고수량
    FROM TBL_상품
    WHERE 상품코드 = V_상품코드;
    
    --⑧ 파악한 재고수량에 따라 데이터 변경 실시 여부 판단
    --   (『재고수량+이전출고수량 < 현재출고수량』인 상황이라면 사용자 정의 예외 발생)
    IF V_출고수량>(V_재고수량+V_이전출고수량)
        THEN RAISE USER_DEFINE_ERROR; 
    END IF;
    
    --② 수행될 쿼리문 체크(UPDATE→TBL_출고 / UPDATE→TBL_상품)
    UPDATE TBL_출고
    SET 출고수량 = V_출고수량
    WHERE 출고번호 = V_출고번호;
    
    UPDATE TBL_상품
    SET 재고수량 = 재고수량 + V_이전출고수량 - V_출고수량
    WHERE 상품코드 = V_상품코드;
    
    --⑩ 커밋
    COMMIT;
    
    --⑪ 예외 처리
    EXCEPTION 
        WHEN USER_DEFINE_ERROR
            THEN RAISE_APPLICATION_ERROR(-20002, '재고수량이 부족합니다.');     -- 마이너스가 아니라 하이푼개념
                 ROLLBACK;
        WHEN OTHERS
            THEN ROLLBACK;
END;
--==>> Procedure PRC_출고_UPDATE이(가) 컴파일되었습니다.





=== 20190410_02_scott.sql ===

SELECT USER
FROM DUAL;
--==>> SCOTT

--○ 생성한 프로시저(PRC_STUDENTS_INSERT())가 제대로 작동하는지의
--   여부 확인 → 프로시저 호출
EXEC PRC_INSA_INSERT('김선아','901212-2234567',SYSDATE,'서울','010-5555-5555','영업부','대리',1000000,200000);
--==>> PL/SQL 프로시저가 성공적으로 완료되었습니다.

SELECT *
FROM TBL_INSA;
--==>> 1061	김선아	901212-2234567	19/04/09	서울	010-5555-5555	영업부	대리	1000000	200000


EXEC PRC_INSA_INSERT('한승원','910101-1234567',SYSDATE,'인천','010-1212-1212','기획부','대리',1000000,200000);
--==>> PL/SQL 프로시저가 성공적으로 완료되었습니다.

SELECT *
FROM TBL_INSA;
--==>> 1062	한승원	910101-1234567	19/04/10	인천	010-1212-1212	기획부	대리	1000000	200000


--------------------------------------------------------------------------------------------------------------------------------

--○ 실습 테이블 생성(TBL_상품)
CREATE TABLE TBL_상품
( 상품코드      VARCHAR2(20)
, 상품명        VARCHAR2(100)
, 소비자가격    NUMBER
, 재고수량      NUMBER DEFAULT 0
, CONSTRAINT 상품_상품코드_PK PRIMARY KEY(상품코드)
);
--==>> Table TBL_상품이(가) 생성되었습니다.
-- TBL_상품 테이블의 상품코드를 기본키(PK) 제약조건 설정


--○ 실습 테이블 생성(TBL_입고)
CREATE TABLE TBL_입고
( 입고번호  NUMBER
, 상품코드  VARCHAR2(20)
, 입고일자  DATE DEFAULT SYSDATE
, 입고수량  NUMBER
, 입고단가  NUMBER
, CONSTRAINT 입고_입고번호_PK PRIMARY KEY(입고번호)
, CONSTRAINT 입고_상품코드_FK FOREIGN KEY(상품코드)
                    REFERENCES TBL_상품(상품코드)
);
--==>> Table TBL_입고이(가) 생성되었습니다.
-- TBL_입고 테이블의 입고번호를 기본키(PK) 제약조건 설정
-- TBL_입고 테이블의 상품코드는 TBL_상품 테이블의 상품코드를
-- 참조할 수 있도록 외래키(FK) 제약조건 설정


--○ TBL_상품 테이블에 상품 데이터 입력
INSERT INTO TBL_상품(상품코드, 상품명, 소비자가격) VALUES('H001', '홈런볼', 1000);
INSERT INTO TBL_상품(상품코드, 상품명, 소비자가격) VALUES('H002', '새우깡', 900);
INSERT INTO TBL_상품(상품코드, 상품명, 소비자가격) VALUES('H003', '자갈치', 800);
INSERT INTO TBL_상품(상품코드, 상품명, 소비자가격) VALUES('H004', '감자깡', 900);
INSERT INTO TBL_상품(상품코드, 상품명, 소비자가격) VALUES('H005', '꼬깔콘', 1200);
INSERT INTO TBL_상품(상품코드, 상품명, 소비자가격) VALUES('H006', '포카칩', 1500);
INSERT INTO TBL_상품(상품코드, 상품명, 소비자가격) VALUES('H007', '뽀빠이', 2000);
--==>> 1 행 이(가) 삽입되었습니다. * 7

INSERT INTO TBL_상품(상품코드, 상품명, 소비자가격) VALUES('C001', '초코칩', 1800);
INSERT INTO TBL_상품(상품코드, 상품명, 소비자가격) VALUES('C002', '다이제', 2500);
INSERT INTO TBL_상품(상품코드, 상품명, 소비자가격) VALUES('C003', '버터링', 1500);
INSERT INTO TBL_상품(상품코드, 상품명, 소비자가격) VALUES('C004', '에이스', 1700);
INSERT INTO TBL_상품(상품코드, 상품명, 소비자가격) VALUES('C005', '오레오', 1900);
INSERT INTO TBL_상품(상품코드, 상품명, 소비자가격) VALUES('C006', '비인츠', 900);
INSERT INTO TBL_상품(상품코드, 상품명, 소비자가격) VALUES('C007', '빠다코', 2900);
--==>> 1 행 이(가) 삽입되었습니다. * 7

INSERT INTO TBL_상품(상품코드, 상품명, 소비자가격) VALUES('E001', '엠엔엠', 600);
INSERT INTO TBL_상품(상품코드, 상품명, 소비자가격) VALUES('E002', '부푸러', 900);
INSERT INTO TBL_상품(상품코드, 상품명, 소비자가격) VALUES('E003', '아폴로', 300);
INSERT INTO TBL_상품(상품코드, 상품명, 소비자가격) VALUES('E004', '쫀드기', 400);
INSERT INTO TBL_상품(상품코드, 상품명, 소비자가격) VALUES('E005', '비틀즈', 800);
INSERT INTO TBL_상품(상품코드, 상품명, 소비자가격) VALUES('E006', '마이쮸', 1100);
INSERT INTO TBL_상품(상품코드, 상품명, 소비자가격) VALUES('E007', '트윅스', 1200);
--==>> 1 행 이(가) 삽입되었습니다. * 7


--○ 확인
SELECT *
FROM TBL_상품;
--==>>
/*
H001	홈런볼	1000	0
H002	새우깡	 900	0
H003	자갈치	 800	0
H004	감자깡	 900	0
H005	꼬깔콘	1200	0
H006	포카칩	1500	0
H007	뽀빠이	2000	0
C001	초코칩	1800	0
C002	다이제	2500	0
C003	버터링	1500	0
C004	에이스	1700	0
C005	오레오	1900	0
C006	비인츠	 900	0
C007	빠다코	2900	0
E001	엠엔엠	 600	0
E002	부푸러	 900	0
E003	아폴로	 300	0
E004	쫀드기	 400	0
E005	비틀즈	 800	0
E006	마이쮸	1100	0
E007	트윅스	1200	0
*/

SELECT COUNT(*)
FROM TBL_상품;
--==>> 21


--○ 커밋
COMMIT;
--==>> 커밋 완료.


--○ 날짜 세션 설정 변경
ALTER SESSION SET NLS_DATE_FORMAT = 'YYYY-MM-DD';
--==>> Session이(가) 변경되었습니다.


--○ 생성된 프로시저(PRC_입고_INSERT())가 제대로 작동하는지의 여부 확인
SELECT *
FROM TBL_상품;
SELECT *
FROM TBL_입고
ORDER BY 입고번호;

EXEC PRC_입고_INSERT('H005', 200, 1000);
--==>> PL/SQL 프로시저가 성공적으로 완료되었습니다.
EXEC PRC_입고_INSERT('C001', 50, 1500);
--==>> PL/SQL 프로시저가 성공적으로 완료되었습니다.
EXEC PRC_입고_INSERT('C001', 20, 1600);
--==>> PL/SQL 프로시저가 성공적으로 완료되었습니다.
EXEC PRC_입고_INSERT('E001', 80, 500);
--==>> PL/SQL 프로시저가 성공적으로 완료되었습니다.
EXEC PRC_입고_INSERT('E001', 200, 400);
--==>> PL/SQL 프로시저가 성공적으로 완료되었습니다.
EXEC PRC_입고_INSERT('H007', 100, 1800);
--==>> PL/SQL 프로시저가 성공적으로 완료되었습니다.
EXEC PRC_입고_INSERT('E006', 50, 1000);
--==>> PL/SQL 프로시저가 성공적으로 완료되었습니다.
EXEC PRC_입고_INSERT('E006', 250, 900);
--==>> PL/SQL 프로시저가 성공적으로 완료되었습니다.
EXEC PRC_입고_INSERT('E006', 80, 900);
--==>> PL/SQL 프로시저가 성공적으로 완료되었습니다.
EXEC PRC_입고_INSERT('H002', 40, 800);
--==>> PL/SQL 프로시저가 성공적으로 완료되었습니다.

--○ 확인
SELECT *
FROM TBL_입고
ORDER BY 입고번호;
--==>>
/*
1	H005	2019-04-10	200	1000
2	C001	2019-04-10	 50	1500
3	C001	2019-04-10	 20	1600
4	E001	2019-04-10	 80	 500
5	E001	2019-04-10	200	 400
6	H007	2019-04-10	100	1800
7	E006	2019-04-10	 50	1000
8	E006	2019-04-10	250	 900
9	E006	2019-04-10	 80	 900
10	H002	2019-04-10	 40	 800
*/
SELECT *
FROM TBL_상품;
--==>>
/*
H001	홈런볼	1000	  0
H002	새우깡	 900	 40
H003	자갈치	 800	  0
H004	감자깡	 900	  0
H005	꼬깔콘	1200	200
H006	포카칩	1500	  0
H007	뽀빠이	2000	100
C001	초코칩	1800	 70
C002	다이제	2500	  0
C003	버터링	1500	  0
C004	에이스	1700	  0
C005	오레오	1900	  0
C006	비인츠	 900	  0
C007	빠다코	2900	  0
E001	엠엔엠	 600	280
E002	부푸러	 900	  0
E003	아폴로	 300	  0
E004	쫀드기	 400	  0
E005	비틀즈	 800	  0
E006	마이쮸	1100	380
E007	트윅스	1200	  0
*/


--■■■ 프로시저 내에서의 예외 처리 ■■■--

--○ 테이블 생성(TBL_MEMBER)
CREATE TABLE TBL_MEMBER
( NUM   NUMBER
, NAME  VARCHAR2(30)
, TEL   VARCHAR2(60)
, CITY  VARCHAR2(60)
);
--==>> Table TBL_MEMBER이(가) 생성되었습니다.

--○ 생성한 프로시저(PRC_MEMBER_INSERT()) 정상 작동여부 확인
EXEC PRC_MEMBER_INSERT('유진석', '010-1111-1111', '서울');
--==>> PL/SQL 프로시저가 성공적으로 완료되었습니다.
EXEC PRC_MEMBER_INSERT('이기승', '010-2222-2222', '인천');
--==>> PL/SQL 프로시저가 성공적으로 완료되었습니다.
EXEC PRC_MEMBER_INSERT('곽한얼', '010-3333-3333', '경기');
--==>> PL/SQL 프로시저가 성공적으로 완료되었습니다.
EXEC PRC_MEMBER_INSERT('이승희', '010-4444-4444', '대구');
--==>> ORA-20001: 서울, 인천, 경기만 입력 가능합니다.

--○ 확인
SELECT *
FROM TBL_MEMBER;
--==>>
/*
1	유진석	010-1111-1111	서울
2	이기승	010-2222-2222	인천
3	곽한얼	010-3333-3333	경기
*/


--○ 실습 테이블 생성(TBL_출고)
CREATE TABLE TBL_출고
( 출고번호  NUMBER
, 상품코드  VARCHAR(20)
, 출고일자  DATE DEFAULT SYSDATE
, 출고수량  NUMBER
, 출고단가  NUMBER
);
--==>> Table TBL_출고이(가) 생성되었습니다.

--○ TBL_출고 테이블의 출고번호에 PK 제약조건 지정
ALTER TABLE TBL_출고
ADD CONSTRAINT 출고_출고번호_PK PRIMARY KEY(출고번호);
--==>> Table TBL_출고이(가) 변경되었습니다.

--○ TBL_출고 테이블의 상품코드는 TBL_상품 테이블의 상품코드를 
--   참조할 수 있도록 외래키(FK) 제약조건 지정
ALTER TABLE TBL_출고
ADD CONSTRAINT 출고_상품코드_FK FOREIGN KEY(상품코드)
                    REFERENCES TBL_상품(상품코드);
--==>> Table TBL_출고이(가) 변경되었습니다.


--○ TBL_출고 테이블에 데이터 입력 시(즉, 출고 이벤트 발생 시)
--   TBL_상품 테이블의 재고수량이 변동되는 프로시저를 작성한다.
--   단, 출고번호는 입고번호와 마찬가지로 자동 증가.
--   또한, 출고 수량이 재고 수량보다 많은 경우
--   출고 액션을 취소할 수 있도록 처리한다. (출고가 이루어지지 않도록)
--   프로시저 명 : PRC_출고_INSERT(상품코드, 출고수량, 출고단가);


--○ 생성된 프로시저(PRC_출고_INSERT())가 제대로 작동하는지의 여부 확인
EXEC PRC_출고_INSERT('C001', 60, 1800);
--==>> PL/SQL 프로시저가 성공적으로 완료되었습니다.

SELECT *
FROM TBL_상품;
--==>> C001	초코칩	1800	10
SELECT *
FROM TBL_출고;
--==>> 1	C001	2019-04-10	60	1800

EXEC PRC_출고_INSERT('C001', 20, 1800);
--==>> ORA-20002: 재고수량이 부족합니다. 


--○ TBL_출고 테이블에서 출고 수량을 수정(변경)하는 프로시저를 작성한다.
--   프로시저 명 : PRC_출고_UPDATE(출고번호, 변경할 수량);


------------------------
--○ 실습 환경 구성
EXEC PRC_입고_INSERT('C004', 200, 1500);
--==>> PL/SQL 프로시저가 성공적으로 완료되었습니다.

SELECT *
FROM TBL_상품;
--==>> C004	에이스	1700	200

EXEC PRC_출고_INSERT('C004', 150, 1800);
--==>> PL/SQL 프로시저가 성공적으로 완료되었습니다.
SELECT *
FROM TBL_출고;
--==>> 1	C004	2019-04-10	150	1800
SELECT *
FROM TBL_상품;
--==>> C004	에이스	1700	50

EXEC PRC_출고_UPDATE(1, 50);
--==>> PL/SQL 프로시저가 성공적으로 완료되었습니다.
SELECT *
FROM TBL_출고;
--==>> 1	C004	2019-04-10	50	1800
SELECT *
FROM TBL_상품;
--==>> C004	에이스	1700	150

EXEC PRC_출고_UPDATE(1, 200);
--==>> PL/SQL 프로시저가 성공적으로 완료되었습니다.
SELECT *
FROM TBL_출고;
--==>> 1	C004	2019-04-10	200	1800
SELECT *
FROM TBL_상품;
--==>> C004	에이스	1700	0

EXEC PRC_출고_UPDATE(1, 201);
--==>> ORA-20002: 재고수량이 부족합니다.
SELECT *
FROM TBL_출고;
--==>> 1	C004	2019-04-10	200	1800
SELECT *
FROM TBL_상품;
--==>> C004	에이스	1700	0





=== 20190411_01_scott(plsql).sql ===

SELECT USER
FROM DUAL;
--==>> SCOTT

--○ TBL_입고 테이블에서 입고수량을 수정(변경)하는 프로시저를 작성한다.
--   프로시저 명 : PRC_입고_UPDATE(입고번호, 변경할입고수량);
CREATE OR REPLACE PROCEDURE PRC_입고_UPDATE
( V_입고번호    IN TBL_입고.입고번호%TYPE
, V_입고수량    IN TBL_입고.입고수량%TYPE
)
IS
    V_상품코드      TBL_상품.상품코드%TYPE;
    V_이전입고수량  TBL_입고.입고수량%TYPE;
    V_재고수량      TBL_상품.재고수량%TYPE;
    
    USER_DEFINE_ERROR EXCEPTION;
BEGIN
    SELECT 상품코드, 입고수량 INTO V_상품코드, V_이전입고수량
    FROM TBL_입고 
    WHERE 입고번호 = V_입고번호;
    
    SELECT 재고수량 INTO V_재고수량
    FROM TBL_상품
    WHERE 상품코드 = V_상품코드;
    
    IF V_재고수량<(V_입고수량-V_이전입고수량)
        THEN RAISE USER_DEFINE_ERROR;
    END IF;
    
    UPDATE TBL_입고
    SET 입고수량 = V_입고수량
    WHERE 입고번호 = V_입고번호;
    
    UPDATE TBL_상품
    SET 재고수량 = (V_입고수량 - V_이전입고수량) + 재고수량
    WHERE 상품코드 = V_상품코드;
    
    COMMIT;
    
    EXCEPTION
        WHEN USER_DEFINE_ERROR
            THEN RAISE_APPLICATION_ERROR(-20003, '재고수량이 부족합니다');
                ROLLBACK;
        WHEN OTHERS
            THEN ROLLBACK;
END;
--==>> Procedure PRC_입고_UPDATE이(가) 컴파일되었습니다.


--○ TBL_출고 테이블에서 출고사량을 살제하는 프로시저를 작성한다.
--   프로시저 명 : PRC_출고_DELETE(출고번호)
CREATE OR REPLACE PROCEDURE PRC_출고_DELETE
( V_출고번호    IN TBL_출고.출고번호%TYPE
)
IS
    V_상품코드  TBL_상품.상품코드%TYPE;
    V_출고수량  TBL_출고.출고수량%TYPE;
BEGIN
    SELECT 출고수량, 상품코드 INTO V_출고수량, V_상품코드
    FROM TBL_출고
    WHERE 출고번호 = V_출고번호;
    
    UPDATE TBL_상품
    SET 재고수량 = 재고수량 + V_출고수량
    WHERE 상품코드 = V_상품코드;
    
    DELETE 
    FROM TBL_출고
    WHERE 출고번호 = V_출고번호;
    
    COMMIT;
END;
--==>> Procedure PRC_출고_DELETE이(가) 컴파일되었습니다.


--○ TBL_입고 테이블에서 입고수량을 삭제하는 프로시저를 작성한다.
--   프로시저 명 : PRC_입고_DELETE(입고번호);
CREATE OR REPLACE PROCEDURE PRC_입고_DELETE
( V_입고번호    IN TBL_입고.입고번호%TYPE
)
IS
    V_상품코드  TBL_상품.상품코드%TYPE;
    V_입고수량  TBL_입고.입고수량%TYPE;
    V_재고수량  TBL_상품.재고수량%TYPE;
    
    USER_DEFINE_ERROR EXCEPTION;
BEGIN
    SELECT 상품코드, 입고수량 INTO V_상품코드, V_입고수량
    FROM TBL_입고
    WHERE 입고번호 = V_입고번호;
    
    SELECT 재고수량 INTO V_재고수량
    FROM TBL_상품
    WHERE 상품코드 = V_상품코드;
    
    IF V_재고수량<V_입고수량
        THEN RAISE USER_DEFINE_ERROR;
    END IF;
    
    UPDATE TBL_상품
    SET 재고수량 = 재고수량 - V_입고수량
    WHERE 상품코드 = V_상품코드;
    
    DELETE
    FROM TBL_입고
    WHERE 입고번호 = V_입고번호;
    
    COMMIT;
    
    EXCEPTION
        WHEN USER_DEFINE_ERROR
            THEN RAISE_APPLICATION_ERROR(-20003, '재고수량이 부족합니다');
                ROLLBACK;
        WHEN OTHERS
            THEN ROLLBACK;
END;


--------------------------------------------------------------------------------------------------------------------------------

--■■■ CURSOR(커서) ■■■--

-- 1. 오라클에서 하나의 레코드가 아닌 여러 레코드로 구성된
--    작업 영역에서 SQL 문을 실행하고 그 과정에서 발생한 정보를
--    저장하기 위하여 커서(CURSOR)를 사용하며,
--    커서에는 암시적 커서와 명시적 커서가 있다.

-- 2. 암시적 커서는 모든 SQL 문에 존재하며,
--    SQL 문 실행 후 오직 하나의 행(ROW)만 출력하게 된다.
--    그러나 SQL 문을 실행한 결과물(RESULT SET)이
--    여러 행(ROW)으로 구성된 경우
--    커서(CURSOR)를 명시적으로 선언해야 여러 행(ROW)을 다룰 수 있다.


--○ 커서 이용 전 상황(단일 행 접근 시)
SET SERVEROUTPUT ON;

DECLARE
    V_NAME  TBL_INSA.NAME%TYPE;
    V_TEL   TBL_INSA.TEL%TYPE;
BEGIN
    SELECT NAME, TEL INTO V_NAME, V_TEL
    FROM TBL_INSA
    WHERE NUM=1001;
    
    DBMS_OUTPUT.PUT_LINE(V_NAME||', '||V_TEL);
END;
--==>> 홍길동, 011-2356-4528


--○ 커서 이용 전 상황(다중 행 접근 시)
DECLARE
    V_NAME  TBL_INSA.NAME%TYPE;
    V_TEL   TBL_INSA.TEL%TYPE;
BEGIN
    SELECT NAME, TEL INTO V_NAME, V_TEL
    FROM TBL_INSA;
    
    DBMS_OUTPUT.PUT_LINE(V_NAME||', '||V_TEL);
END;
--==>> 에러 발생
/*
ORA-01422: exact fetch returns more than requested number of rows
*/

--○ 커서 이용 전 상황(다중 행 접근 시 - 반복문을 활용하는 경우)
DECLARE
    V_NAME  TBL_INSA.NAME%TYPE;
    V_TEL   TBL_INSA.TEL%TYPE;
    V_NUM   TBL_INSA.NUM%TYPE := 1001;
BEGIN
    LOOP
        SELECT NAME, TEL INTO V_NAME, V_TEL
        FROM TBL_INSA
        WHERE NUM=V_NUM;
        
        DBMS_OUTPUT.PUT_LINE(V_NAME||', '||V_TEL);
        V_NUM := V_NUM +1;
        
        EXIT WHEN V_NUM >= 1061;
    END LOOP;
END;
--==>>
/*
홍길동, 011-2356-4528
이순신, 010-4758-6532
이순애, 010-4231-1236
          :
          :
김신제, 010-2415-5444
임수봉, 011-4151-4154
김신애, 011-4151-4444
*/


--○ 커서 이용 후 상황(다중 행 접근 시)
DECLARE
    V_NAME  TBL_INSA.NAME%TYPE;
    V_TEL   TBL_INSA.TEL%TYPE;
    
    -- 커서 이용을 위한 커서변수 선언(→ 커서 정의)
    CURSOR CUR_INSA_SELECT
    IS
    SELECT NAME, TEL
    FROM TBL_INSA;
    
BEGIN
    
    -- 커서 오픈
    OPEN CUR_INSA_SELECT;
    
    -- 커서 오픈 시 쏟아져나오는 데이터들 처리(잡아내기)
    LOOP
        -- 한 행 한 행 끄집어내어 가져오는 행위 → 『FETCH』
        FETCH CUR_INSA_SELECT INTO V_NAME, V_TEL;
        
        EXIT WHEN CUR_INSA_SELECT%NOTFOUND;
        
        -- 출력
        DBMS_OUTPUT.PUT_LINE(VNAME||', '||V_TEL);
        
    END LOOP;
    
    -- 커서 클로즈
    CLOSE CUR_INSA_SELECT;
END;


--------------------------------------------------------------------------------------------------------------------------------

--■■■ TRIGGER(트리거) ■■■--

-- 사전적인 의미 : 방아쇠, 촉발시키다, 야기하다, 유발하다

-- 1. TRIGGER(트리거)란 DML 작업 즉, INSERT, UPDATE, DELETE 작업이 일어날 때
--    자동적으로 실행되는(유발되는, 촉발되는) 객체로
--    이와 같은 특징을 강조하여(부각시켜) DML TRIGGER 라고 부르기도 한다.
--    TRIGGER 는 데이터 무결성 뿐 아니라
--    다음과 같은 작업에도 널리 사용된다.

-- 자동으로 파생된 열 값 생성
-- 잘못된 트랜잭션 방지
-- 복잡한 보안 권한 강제 수행
-- 분산 데이터베이스 노드 상에서 참조 무결성 강제 수행
-- 복잡한 업무 규칙 상제 적용
-- 투명한 이벤트 로깅 제공
-- 복잡한 감사 제공
-- 동기 테이블 복제 유지관리
-- 테이블 엑세스 통계 수집

-- 2. TRIGGER 내에서는 COMMIT, ROLLBACK 문을 사용할 수 없다.

-- 3. 특징 및 종류

-- BEFORE STATEMENT
-- SQL 구문이 실행되기 전에 그 문장에 대해 한 번 실행

-- BEFORE ROM
-- SQL 구문이 실행되기 전에(DML 작업을 수행하기 전에)
-- 각 행(ROW)에 대해 한 번씩 실행.

-- AFTER STATEMENT
-- SQL 구문이 실행된 후 그 문장에 대해 한 번 실행

-- AFTER ROW
-- SQL 구문이 실행된 후에(DML 작업을 수행한 후에)
-- 각 행(ROW)에 대해 한 번씩 실행

-- 4. 형식 및 구조
/*
CREATE [OR REPLACE] TRIGGER 트리거명
    [BEFORE | ARTER]
    이벤트1 [OR 이벤트2 [OR 이벤트3]] ON 테이블명
    [FOR EACH ROW [WHEN TRIGGER 조건]]
[DECLARE]
    -- 선언 구문;
BEGIN
    -- 선언 구문;
END;
*/


--■■■ AFTER STATEMENT TRIGGER 상황 실습 ■■■--
--※ DML 작업에 대한 이벤트 기록

--○ TRIGGER(트리거) 생성(TRG_EVENTLOG)
CREATE OR REPLACE TRIGGER TRG_EVENTLOG
    AFTER
    INSERT OR UPDATE OR DELETE ON TBL_TEST1
DECLARE     -- 따로 선언한게 없는 경우 DECLARE 생략 가능
BEGIN
    -- 이벤트 종류 구분(조건문을 통한 분기)
    IF (INSERTING)
        THEN INSERT INTO TBL_EVENTLOG(MEMO)
             VALUES('INSERT 쿼리문이 수행되었습니다.');
    ELSIF (UPDATING)
        THEN INSERT INTO TBL_EVENTLOG(MEMO)
             VALUES('UPDATE 쿼리문이 수행되었습니다.');
    ELSIF (DELETING)
        THEN INSERT INTO TBL_EVENTLOG(MEMO)
             VALUES('DELETE 쿼리문이 수행되었습니다.');
    END IF;
    
    --COMMIT; 
    --※ TRIGGER 내에서는 COMMIT 구문 사용 불가
END;
--==>> Trigger TRG_EVENTLOG이(가) 컴파일되었습니다.


--■■■ BEFORE STATEMENT TRIGGER 상황 실습 ■■■--
--※ DML 작업 수행 전에 작업 가능여부 확인
--   (보안 정책 적용 / 업무 규칙 적용)

--○ TRIGGER(트리거) 작성(TRG_TEST1_DML)
CREATE OR REPLACE TRIGGER TRG_TEST1_DML
    BEFORE  
    INSERT OR UPDATE OR DELETE ON TBL_TEST1
BEGIN
    IF (시간이 오전 8시 이전이거나 오후 6시 이후라면)
        THEN 예외를 발생시키도록 하겠다.
    END IF;
END;

CREATE OR REPLACE TRIGGER TRG_TEST1_DML
    BEFORE  
    INSERT OR UPDATE OR DELETE ON TBL_TEST1
BEGIN
    IF (TO_NUMBER(TO_CHAR(SYSDATE, 'HH24'))<8 OR TO_NUMBER(TO_CHAR(SYSDATE, 'HH24'))>17)
        THEN RAISE_APPLICATION_ERROR(-20003, '작업은 08:00 ~ 18:00 까지 가능합니다.');
    END IF;  
END;
--==>> Trigger TRG_TEST1_DML이(가) 컴파일되었습니다.


--■■■ BEFORE ROW TRIGGER 상황 실습 ■■■--
--※ 참조 관계가 설정된 데이터(자식) 삭제를 먼저 수행하는 모델

--○ TRIGGER(트리거) 작성(TRG_TEST2_DELETE)
CREATE OR REPLACE TRIGGER TRG_TEST2_DELETE
    BEFORE 
    DELETE ON TBL_TEST2
    FOR EACH ROW
BEGIN
    DELETE
    FROM TBL_TEST3
    WHERE CODE = :OLD.CODE;
END;
--==>> Trigger TRG_TEST2_DELETE이(가) 컴파일되었습니다.

--※ 『:OLD』
--   참조 전 열의 값
--   (INSERT : 입력하기 이전 자료, DELETE : 삭제하기 이전 자료 즉, 삭제할 자료)

--※ UPDATE → DELETE 그리고 INSERT 가 결합된 형태
--             이 과정에서 UPDATE 하기 이전의 자료는 :OLD
--             이 과정에서 UPDATE 한 후의 자료는 :NEW


--■■■ AFTER ROW TRIGGER 상황 실습 ■■■--
--※ 참조 테이블 관련 트랜잭션 처리

-- TBL_상품, TBL_입고, TBL_출고

--○ TBL_입고 테이블의 데이터 입력 시(입고 이벤트 발생 시)
--   TBL_상품 테이블의 재고수량이 변동 트리거 작성
CREATE OR REPLACE TRIGGER TRG_IBGO
    AFTER
    INSERT ON TBL_입고
    FOR EACH ROW
BEGIN
    IF (INSERTING)
        THEN UPDATE TBL_상품
             SET 재고수량 = 재고수량+새로입고되는 입고수량
             HERE 상품코드 = 새로입고되는 상품코드;
    
    END IF;
END;

CREATE OR REPLACE TRIGGER TRG_IBGO
    AFTER
    INSERT ON TBL_입고
    FOR EACH ROW
BEGIN
    IF (INSERTING)
        THEN UPDATE TBL_상품
             SET 재고수량 = 재고수량 + :NEW.입고수량
             WHERE 상품코드 = :NEW.상품코드;
    
    END IF;
END;
--==>> Trigger TRG_IBGO이(가) 컴파일되었습니다.


--○ TBL_상품, TBL_입고, TBL_출고 의 관계에서
--   입고수량, 재고수량의 트랜잭션 처리가 이루어질 수 있도록
--   TRG_IBGO 트리거를 수정한다.
CREATE OR REPLACE TRIGGER TRG_IBGO
    AFTER
    INSERT OR UPDATE OR DELETE ON TBL_입고
    FOR EACH ROW
BEGIN
    IF (INSERTING)
        THEN UPDATE TBL_상품
             SET 재고수량 = 재고수량 + :NEW.입고수량
             WHERE 상품코드 = :NEW.상품코드;
    ELSIF (UPDATING)
        THEN UPDATE TBL_상품
             SET 재고수량 = (:NEW.입고수량 - :OLD.입고수량) + 재고수량
             WHERE 상품코드 = :NEW.상품코드;
    ELSIF (DELETING)
        THEN UPDATE TBL_상품
             SET 재고수량 = 재고수량 - :OLD.입고수량
             WHERE 상품코드 = :OLD.상품코드;
    END IF;
END;
--==>> Trigger TRG_IBGO이(가) 컴파일되었습니다.

--○ TBL_상품, TBL_입고, TBL_출고 의 관계에서
--   출고수량, 재고수량의 트랜잭션 처리가 이루어질 수 있도록
--   TRG_CHULGO 트리거를 수정한다.
CREATE OR REPLACE TRIGGER TRG_CHULGO
    AFTER
    INSERT OR UPDATE OR DELETE ON TBL_출고
    FOR EACH ROW
BEGIN
    IF (INSERTING)
        THEN UPDATE TBL_상품
             SET 재고수량 = 재고수량 - :NEW.출고수량
             WHERE 상품코드 = :NEW.상품코드;
    ELSIF (UPDATING)
        THEN UPDATE TBL_상품
             SET 재고수량 = 재고수량 - (:NEW.출고수량 - :OLD.출고수량)
             WHERE 상품코드 = :NEW.상품코드;
    ELSIF (DELETING)
        THEN UPDATE TBL_상품
             SET 재고수량 = 재고수량 + :OLD.출고수량
             WHERE 상품코드 = :OLD.상품코드;
    END IF;
END;
--==>> Trigger TRG_CHULGO이(가) 컴파일되었습니다.


--------------------------------------------------------------------------------------------------------------------------------

--■■■ PACKAGE(패키지) ■■■--

-- 1. PL/SQL 의 패키지는 관계되는 타입, 프로그램 객체,
--    서브 프로그램(PROCEDURE, FUNCTION 등)을
--    논리적으로 묶어놓은 것으로
--    오라클에서 제공하는 패키지 중 하나가 바로 『DBMS_OUTPUT』 이다.

-- 2. 패키지는 서로 유사한 업무에 사용되는 여러 개의 프로시저와 함수를
--    하나의 패키지로 만들어 관리함으로써 향후 유지보수가 편리하고
--    전체 프로그램을 모듈화 할 수 있는 장점이 있다.

-- 3. 패키지는 명세부(PACKAGE SPECIFICATION)와 
--    몸체부(PACKAGE BODY)로 구성되어 있으며,
--    명세 부분에는 TYPE, CONSTRAINT, VARIABLE, EXCEPTION, CURSOR, 
--    SUBPROGRAM 이 선언되고
--    몸체 부분에는 이들의 실제 내용이 존재하게 된다.
--    그리고 호출할 때에는 『패키지명.프로시저명』형식의 참조를 이용해야 한다.

-- 4. 형식 및 구조(명세부)
/*
CREATE [OR REPLACE] PACKAGE 패키지명
IS
    전역변수 선언;
    커서 선언;
    예외 선언;
    함수 선언;
    프로시저 선언;
        :
        
END 패키지명;
*/

-- 5. 형식 및 구조(몸체부)
/*
CREATE [OR REPLACE] PACKAGE BODY 패키지명                   -- BODY CHECK!
IS
    FUNCTION 함수명[(인수, ...)]
    RETURN 자료형
    IS
        변수 선언;
    BEGIN
        함수 몸체 구성 코드
        RETURN 값;
    END;
    
    PROCEDURE 프로시저명[(인수, ...)]
    IS
        변수 선언;
    BEGIN
        프로시저 몸체 구성 코드;
    END;
    
END 패키지명;
*/

--○ 주민번호 입력 시 성별을 반환하는 함수
--   이 함수를 구성요소로 하는 패키지 작성

-- 함수 준비
CREATE OR REPLACE FUNCTION FN_GENDER(V_SSN VARCHAR2)
RETURN VARCHAR2
IS
    V_RESULT VARCHAR2(20);
BEGIN
    IF (SUBSTR(V_SSN, 8, 1) IN ('1','3'))
        THEN V_RESULT := '남자';
    ELSIF (SUBSTR(V_SSN, 8, 1) IN ('2','4'))
        THEN V_RESULT := '여자';
    ELSE
        V_RESULT := '확인불가';
    END IF;
    
    RETURN V_RESULT;
END;
--==>> Function FN_GENDER이(가) 컴파일되었습니다.

-- 패키지 등록

-- 1. 명세부 작성
CREATE OR REPLACE PACKAGE INSA_PACK
IS
    FUNCTION FN_GENDER(V_SSN VARCHAR2)
    RETURN VARCHAR2;

END INSA_PACK;
--==>> Package INSA_PACK이(가) 컴파일되었습니다.

-- 2. 몸체부 작성
CREATE OR REPLACE PACKAGE BODY INSA_PACK
IS
    FUNCTION FN_GENDER(V_SSN VARCHAR2)
RETURN VARCHAR2
IS
    V_RESULT VARCHAR2(20);
    BEGIN
        IF (SUBSTR(V_SSN, 8, 1) IN ('1','3'))
            THEN V_RESULT := '남자';
        ELSIF (SUBSTR(V_SSN, 8, 1) IN ('2','4'))
            THEN V_RESULT := '여자';
        ELSE
            V_RESULT := '확인불가';
        END IF;
    
        RETURN V_RESULT;
    END;
    
END INSA_PACK;
--==>> Package Body INSA_PACK이(가) 컴파일되었습니다.





=== 20190411_02_scott.sql ===

--○ 실습 테이블 생성(TBL_TEST1)
CREATE TABLE TBL_TEST1
( ID    NUMBER
, NAME  VARCHAR2(30)
, TEL   VARCHAR2(60)
);
--==>> Table TBL_TEST1이(가) 생성되었습니다.

--○ 생성된 테이블에 제약조건 추가
--   ID 컬럼에 PK 제약조건 지정
ALTER TABLE TBL_TEST1
ADD CONSTRAINT TEST1_ID_PK PRIMARY KEY(ID);
--==> Table TBL_TEST1이(가) 변경되었습니다.

--○ 실습 테이블 생성(TBL_EVENTLOG)
CREATE TABLE TBL_EVENTLOG
( MEMO  VARCHAR2(200)
, ILJA  DATE DEFAULT SYSDATE
);
--==>> Table TBL_EVENTLOG이(가) 생성되었습니다.

SELECT *
FROM TBL_TEST1;
--==>> 조회 결과 없음

SELECT *
FROM TBL_EVENTLOG;
--==>> 조회 결과 없음


--○ 날짜 세션 정보 설정 변경
ALTER SESSION SET NLS_DATE_FORMAT = 'YYYY-MM-DD HH24:MI:SS';
--==>> Session이(가) 변경되었습니다.


--○ TBL_TEST1 테이블에 데이터 입력
INSERT INTO TBL_TEST1(ID, NAME, TEL) VALUES(1, '조수연', '010-1111-1111');
--==>> 1 행 이(가) 삽입되었습니다.
INSERT INTO TBL_TEST1(ID, NAME, TEL) VALUES(2, '이지혜', '010-2222-2222');
--==>> 1 행 이(가) 삽입되었습니다.

--○ TBL_TEST1 테이블의 데이터 수정
UPDATE TBL_TEST1
SET NAME = '수여니'
WHERE ID = 1;
--==>> 1 행 이(가) 업데이트되었습니다.

--○ TBL_TEST1 테이블의 데이터 삭제
DELETE
FROM TBL_TEST1
WHERE ID=2;
--==>> 1 행 이(가) 삭제되었습니다.
DELETE
FROM TBL_TEST1
WHERE ID=1;
--==>> 1 행 이(가) 삭제되었습니다.

--○ 커밋
COMMIT;
--==>> 커밋 완료.

--○ 확인
SELECT *
FROM TBL_TEST1;
--==>> 조회 결과 없음

SELECT *
FROM TBL_EVENTLOG;
--==>>
/*
INSERT 쿼리문이 수행되었습니다.	2019-04-11 12:18:57
INSERT 쿼리문이 수행되었습니다.	2019-04-11 12:19:22
UPDATE 쿼리문이 수행되었습니다.	2019-04-11 12:20:17
DELETE 쿼리문이 수행되었습니다.	2019-04-11 12:21:01
DELETE 쿼리문이 수행되었습니다.	2019-04-11 12:21:42
*/


--○ 테스트
INSERT INTO TBL_TEST1(ID, NAME, TEL) VALUES(3, '이기승', '010-3333-3333');
--==>> 1 행 이(가) 삽입되었습니다.
INSERT INTO TBL_TEST1(ID, NAME, TEL) VALUES(4, '곽한얼', '010-4444-4444');
--==>> 1 행 이(가) 삽입되었습니다.

UPDATE TBL_TEST1
SET NAME = '윤희진'
WHERE ID = 3;
--==>> 1 행 이(가) 업데이트되었습니다.

DELETE
FROM TBL_TEST1
WHERE ID = 4;
--==>> 1 행 이(가) 삭제되었습니다.

--○ 커밋
COMMIT;
--==>> 커밋 완료.  


-- 오라클 서버의 시간을 21시 대로 변경

-- 시간이 변경된 상태에서 데이터 입력
INSERT INTO TBL_TEST1(ID, NAME, TEL) VALUES(5, '이승희', '010-5555-5555');
--==>> 에러 발생
/*
ORA-20003: 작업은 08:00 ~ 18:00 까지 가능합니다.
*/

SELECT *
FROM TBL_TEST1;
--==>> 3	윤희진	010-3333-3333

-- 시간이 변경된 상태에서 데이터 수정
UPDATE TBL_TEST1
SET NAME = '권홍비'
WHERE ID = 3;
--==>> 에러발생
/*
ORA-20003: 작업은 08:00 ~ 18:00 까지 가능합니다.
*/

-- 시간이 변경된 상태에서 데이터 삭제
DELETE
FROM TBL_TEST1
WHERE ID = 3;
--==>> 에러발생
/*
ORA-20003: 작업은 08:00 ~ 18:00 까지 가능합니다.
*/

SELECT *
FROM TBL_TEST1;
--==>> 3	윤희진	010-3333-3333


--○ 실습 테이블 생성(TBL_TEST2) → 부모 테이블
CREATE TABLE TBL_TEST2
( CODE  NUMBER
, NAME  VARCHAR2(40)
, CONSTRAINT TEST2_CODE_PK PRIMARY KEY(CODE)
);
--==>> Table TBL_TEST2이(가) 생성되었습니다.

--○ 실습 테이블 생성(TBL_TEST3) → 자식 테이블
CREATE TABLE TBL_TEST3
( SID   NUMBER
, CODE  NUMBER
, SU    NUMBER
, CONSTRAINT TEST3_SID_PK PRIMARY KEY(SID)
, CONSTRAINT TEST3_CODE_FK FOREIGN KEY(CODE)
                REFERENCES TBL_TEST2(CODE)
);
--==>> Table TBL_TEST3이(가) 생성되었습니다.


--○ 실습 데이터 입력
INSERT INTO TBL_TEST2(CODE, NAME) VALUES(1, '냉장고');
INSERT INTO TBL_TEST2(CODE, NAME) VALUES(2, '세탁기');
INSERT INTO TBL_TEST2(CODE, NAME) VALUES(3, '건조기');
--==>> 1 행 이(가) 삽입되었습니다. * 3

SELECT *
FROM TBL_TEST2;
--==>>
/*
1	냉장고
2	세탁기
3	건조기
*/

COMMIT;
--==>> 커밋 완료.


--○ 실습 데이터 입력
INSERT INTO TBL_TEST3(SID, CODE, SU) VALUES(1, 1, 20);
INSERT INTO TBL_TEST3(SID, CODE, SU) VALUES(2, 2, 30);
INSERT INTO TBL_TEST3(SID, CODE, SU) VALUES(3, 1, 40);
INSERT INTO TBL_TEST3(SID, CODE, SU) VALUES(4, 2, 50);
INSERT INTO TBL_TEST3(SID, CODE, SU) VALUES(5, 1, 60);
INSERT INTO TBL_TEST3(SID, CODE, SU) VALUES(6, 1, 20);
INSERT INTO TBL_TEST3(SID, CODE, SU) VALUES(7, 1, 30);
INSERT INTO TBL_TEST3(SID, CODE, SU) VALUES(8, 2, 40);
INSERT INTO TBL_TEST3(SID, CODE, SU) VALUES(9, 1, 50);
--==>> 1 행 이(가) 삽입되었습니다. * 9

SELECT *
FROM TBL_TEST3;
--==>>
/*
1	1	20
2	2	30
3	1	40
4	2	50
5	1	60
6	1	20
7	1	30
8	2	40
9	1	50
*/

SELECT C.SID, P.CODE, P.NAME, C.SU
FROM TBL_TEST2 P JOIN TBL_TEST3 C
ON P.CODE = C.CODE;
--==>>
/*
1	1	냉장고	20
2	2	세탁기	30
3	1	냉장고	40
4	2	세탁기	50
5	1	냉장고	60
6	1	냉장고	20
7	1	냉장고	30
8	2	세탁기	40
9	1	냉장고	50
*/

COMMIT;
--==>> 커밋 완료.

DELETE
FROM TBL_TEST2
WHERE CODE = 3;
--==>> 1 행 이(가) 삭제되었습니다.

SELECT *
FROM TBL_TEST2;
--==>>
/*
1	냉장고
2	세탁기
*/

COMMIT;
--==>> 커밋 완료.

DELETE
FROM TBL_TEST2
WHERE CODE = 2;
--==>> 1 행 이(가) 삭제되었습니다.

SELECT *
FROM TBL_TEST2;
--==>> 1	냉장고

SELECT *
FROM TBL_TEST3;
--==>> 
/*
1	1	20
3	1	40
5	1	60
6	1	20
7	1	30
9	1	50
*/

COMMIT;
--==>> 커밋 완료.


-- 데이터 날림
TRUNCATE TABLE TBL_입고;
--==>> Table TBL_출고이(가) 잘렸습니다.
TRUNCATE TABLE TBL_출고;
--==>> Table TBL_출고이(가) 잘렸습니다.
UPDATE TBL_상품
SET 재고수량 = 0;
--==>> 21개 행 이(가) 업데이트되었습니다.

COMMIT;
--==>> 커밋 완료.


INSERT INTO TBL_입고(입고번호, 상품코드, 입고일자, 입고수량, 입고단가) 
VALUES(1, 'H001', SYSDATE, 100, 1000);
--==>> 1 행 이(가) 삽입되었습니다.


SELECT *
FROM TBL_상품;
SELECT *
FROM TBL_입고;
--==>> 1	H001	19/04/11	100	1000

COMMIT;
--==>> 커밋 완료.


INSERT INTO TBL_입고(입고번호, 상품코드, 입고일자, 입고수량, 입고단가) 
VALUES(2, 'H002', SYSDATE, 100, 1000);


UPDATE TBL_입고
SET 입고수량 = 50
WHERE 상품코드 = 'H002';


DELETE 
FROM TBL_입고
WHERE 상품코드 = 'H002';


INSERT INTO TBL_출고(출고번호, 상품코드, 출고일자, 출고수량, 출고단가)
VALUES(1, 'H001', SYSDATE, 50, 1000);

SELECT *
FROM TBL_출고;

UPDATE TBL_출고
SET 출고수량 = 20
WHERE 출고번호 = 1;

DELETE 
FROM TBL_출고
WHERE 출고번호 = 1;


--※ TRIGGER 의 정보 조회
SELECT *
FROM USER_TRIGGERS;
--==>>
/*
"TRG_TEST2_DELETE
    BEFORE 
    DELETE ON TBL_TEST2
    FOR EACH ROW
"
"BEGIN
    DELETE
    FROM TBL_TEST3
    WHERE CODE = :OLD.CODE;
END;"
*/


SELECT INSA_PACK.FN_GENDER('751212-1234567')
FROM DUAL;
--==>> 남자

SELECT INSA_PACK.FN_GENDER('751212-4234567')
FROM DUAL;
--==>> 여자

SELECT NAME, SSN, INSA_PACK.FN_GENDER(SSN)
FROM TBL_INSA;
--==>>
/*
홍길동	771212-1022432	남자
이순신	801007-1544236	남자
이순애	770922-2312547	여자
            :
            :
김신애	810809-2111111	여자
김선아	901212-2234567	여자
한승원	910101-1234567	남자
*/
































































































































































































































 